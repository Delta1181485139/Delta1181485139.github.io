<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode刷题笔记-221-最大正方形</title>
    <url>/2020/07/11/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>如果用暴力法，在遍历的时候以当前元素作为正方形的左上角，再数出正方形的面积大小，时间复杂度为$O(mn*min(m,n))$，显然会超时。事实上在遍历的时候，是可以复用此前计算得的结果的。也就是可以使用动态规划。</p>
<p>我们可以以$matrix[i][j]$作为正方形的右下角，所以有以下情况</p>
<ol>
<li>首先是第一行和第一列的值只取决于$matrix[i][j]$是0或1。</li>
<li>对于除第一行与第一列以外的元素<ol>
<li>如果$matrix[i][j]$为0，说明不能成为正方形，所以直接填0。</li>
<li>如果$matrix[i][j]$为1，那么以$matrix[i][j]$作为右下角的正方形面积最大值与$matrix[i-1][j-1]$，$matrix[i-1][j]$，$matrix[i][j-1]$有关，且$matrix[i][j]$的值为那三个值中的最小值加一。这一点是值得琢磨的。</li>
</ol>
</li>
</ol>
<p>因此可以得出状态转移方程</p>
<script type="math/tex; mode=display">
dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(matrix.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size(),<span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;matrix.size();++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>||j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = matrix[i][j]-<span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                res = max(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>考研核心词汇Unit-4</title>
    <url>/2020/07/01/english/%E8%80%83%E7%A0%94%E6%A0%B8%E5%BF%83%E8%AF%8D%E6%B1%87Unit-4/</url>
    <content><![CDATA[<ul>
<li><p>confine</p>
<ul>
<li>vt. 限制；限定</li>
<li>n. 界限；范围</li>
<li><strong>[fin]</strong>词根 有范围，界限的意思</li>
<li>infinite in-表反义，没有范围的——无限的</li>
<li>define de-往下；分开，把不同范围分开——定义；解释说明</li>
<li>definite   明确的</li>
<li>indefinite 模糊的</li>
<li>confined adj. 被限制的；狭窄的</li>
<li>refine 提炼；精炼</li>
</ul>
</li>
<li><p>democratic</p>
<ul>
<li>adj. 民主的；有民主精神的</li>
<li>democracy n. 民主</li>
<li>democratism n. 民主主义</li>
</ul>
</li>
<li><p>conbine</p>
<ul>
<li>v. 使联合；使结合</li>
<li>combination n. 结合(体)；联合体(体)<ul>
<li>Family is a combination of love and responsibility.</li>
</ul>
</li>
</ul>
</li>
<li><p>current</p>
<ul>
<li>adj. 当前的；现在的</li>
<li>n. 潮流；趋势</li>
<li>n. 电流；水流；气流——stream</li>
<li>current news 时事</li>
<li><strong>[cur]</strong>词根表关心<ul>
<li>curious 什么都关心的——好奇的</li>
</ul>
</li>
</ul>
</li>
<li><p>contradict</p>
<ul>
<li>vt. 反驳；同……矛盾</li>
<li>on the contrary 相反的</li>
<li>contravene 违反；违背</li>
<li>contraband 走私</li>
<li>counteract 对抗；抵消</li>
<li>countermand 撤销；召回</li>
</ul>
</li>
<li><p>extend</p>
<ul>
<li>v. 延长；延申</li>
<li>extension n. 延申；扩展</li>
<li>extensive adj. 广阔的；广泛的；大量的</li>
<li>extent n. 广度；宽度；范围</li>
<li>to a certain extent 在一定程度上</li>
</ul>
</li>
<li><p>attend</p>
<ul>
<li>v. 出席；参加</li>
<li>attendance n.</li>
</ul>
</li>
<li><p>intent</p>
<ul>
<li>n. 意图</li>
<li>adj. 坚决的；急切的</li>
</ul>
</li>
<li><p>pretend</p>
<ul>
<li>v. 假装；伪装</li>
<li>disguise 装扮；伪装；假装</li>
</ul>
</li>
<li><p>expose</p>
<ul>
<li>v. 使暴露；使显露</li>
<li>be expose to 接触…；暴露在…之下</li>
<li><p>exposure n. 暴露；揭发</p>
</li>
<li><p>posture n. 姿势</p>
</li>
<li>depose 下放——免职；废黜</li>
<li>dispose 处理；解决 ——dispose of 固定搭配</li>
<li>disposable 一次性的</li>
<li>deposit 存款；沉淀物</li>
<li>propose 建议；求婚</li>
<li>proposition n. 提议；建议；论点</li>
<li>compose 构成；组成；作曲</li>
<li>impose 将…强加于；征税<ul>
<li>do not impose your idea on me.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-220-存在重复元素III</title>
    <url>/2020/07/01/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0III/</url>
    <content><![CDATA[<p>在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。如果存在则返回 true，不存在返回 false。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span>, t = <span class="number">0</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">1</span>, t = <span class="number">2</span></span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>], k = <span class="number">2</span>, t = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>解法一，暴力搜索，该算法就是遍历序列一遍，然后对每个元素的加减k的范围之内搜索。时间复杂度为$O(n*min(k,n))$，超时是肯定的。</p>
<p>为了提高效率，有必要考虑空间换时间。在线性查找方面，二分查找可以大大提高查找效率。所以自平衡的二叉搜索树就派上用场了。我这里采用了$c++$中的$set$容器，低层其实是一颗红黑树。</p>
<p>我们只要时刻保持扫描到的元素的前后$k$个元素在红黑树内，然后对其进行查找。所以使用自平衡二叉树的算法时间复杂度为$O(nlog(min(k,n)))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int64_t</span>&gt; bst;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> find = bst.lower_bound((<span class="keyword">int64_t</span>)nums[i]-t);</span><br><span class="line">            <span class="keyword">if</span>(find!=bst.end()&amp;&amp;*find&lt;=(<span class="keyword">int64_t</span>)nums[i]+t)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            bst.insert(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(bst.size()&gt;k)bst.erase(nums[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-216-组合总和III</title>
    <url>/2020/06/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</url>
    <content><![CDATA[<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 </p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">9</span></span><br><span class="line">输出: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<a id="more"></a>
<hr>
<p>回溯+剪枝。由于限定在1-9之内，并且不重复，在回溯过程中是可以剪很多枝的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        dfs(res,tmp,<span class="number">1</span>,k,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp,<span class="keyword">int</span> start,<span class="keyword">int</span> k,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!n)res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">            tmp.push_back(i);</span><br><span class="line">            dfs(res,tmp, i+<span class="number">1</span>, k<span class="number">-1</span>,n-i);</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>处理机调度</title>
    <url>/2020/06/28/os/%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h1><p>在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免，处理机调度是对处理机进行分配。即从就绪队列中按照一定的公平高效的算法选择一个进程，并将处理机分配给它运行，以实现进程并发地执行。</p>
<p>处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</p>
<a id="more"></a>
<h2 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h2><p>一个作业从提交开始直到完成，往往要经历以下三级调度</p>
<h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><p>又称高级调度，其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个或多个作业，给它们分配内存，输入输出设备等必要的资源，并建立相应的进程，使它们获得竞争处理机的权利。</p>
<p>简言之，<strong>作业调度就是内存与辅存之间的调度</strong>。<strong>对于每个作业只调入一次，调出一次</strong>。</p>
<h3 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h3><p>又称内存调度，其作用是提高内存利用率和系统吞吐量。为此，应将那些暂时不能运行的进程调至外存等待，把此时的进程状态称为<strong>挂起态</strong>。当它们具备运行条件且内存稍有空闲时，<strong>由中级调度来决定把外存上那些已具备运行条件的就绪进程重新调入内存</strong>，并修改其状态为就绪态，在就绪队列上等待。</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>又称低级调度，其主要任务是<strong>按照某种方法和策略从就绪队列中选取一个进程，并将处理机分配给它</strong>。进程调度是操作系统中最基本的一种调度，在一般的操作系统中必须配置进程调度。进程调度的频率很高，通常几十毫秒一次。</p>
<h2 id="三层调度的联系"><a href="#三层调度的联系" class="headerlink" title="三层调度的联系"></a>三层调度的联系</h2><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并将其状态改为运行态，将处理机分配给它。</p>
<p>中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p>
<ul>
<li>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li>
<li>作业调度次数少，中级调度次数略多，进程调度频率最高。</li>
<li>进程调度是最基本的，不可或缺。</li>
</ul>
<h1 id="调度的时机、切换与过程"><a href="#调度的时机、切换与过程" class="headerlink" title="调度的时机、切换与过程"></a>调度的时机、切换与过程</h1><p>进程调度和切换程序是操作系统内核程序。请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪进程之后，才有可能进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，操作系统内核程序运行时，若某时发生引起进程调度的因素，则不一定能够马上发生进程的调度与切换。</p>
<p>现代操作系统中，不能进行进程调度与切换的情况有以下几种</p>
<ol>
<li>在处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换。而且中断处理是系统工作的一部分，逻辑上不属于任何进程，不应被剥夺处理机资源。</li>
<li>进程在操作系统内核程序临界区中。进入临界区之后，需要独占式地访问共享数据，理论上必须加锁，以防止其它并行程序进入，在解锁前不应切换到其他程序运行 ，以加快共享数据的释放。</li>
<li>其它需要完全屏蔽中断的原子操作过程中。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</li>
</ol>
<p>应该进行进程调度与切换的情况如下</p>
<ol>
<li>发生引起调度条件且当前进程无法进行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，属于<strong>非剥夺式调度。</strong></li>
<li>中断处理结束或自陷处理结束后，返回被中断进程的用户态执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，属于<strong>剥夺式的调度</strong>。</li>
</ol>
<h1 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h1><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。为了比较处理机调度算法的性能，人们提出了很多评价准则。</p>
<h2 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h2><p>$CPU$是计算机系统中最重要和昂贵的资源之一，所以尽可能使$CPU$保持忙状态，使这一资源利用率最高。</p>
<h2 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h2><p>表示单位时间内$CPU$完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p>
<h2 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h2><p>周转时间是指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、在处理机上运行及进行输入输出操作所花费时间的总和。</p>
<p>作业周转时间可用公式表示如下</p>
<script type="math/tex; mode=display">
周转时间=作业完成时间-作业提交时间</script><p>平均周转时间是指多个作业周转时间的平均值</p>
<script type="math/tex; mode=display">
平均周转时间=\frac{\sum_{i=1}^{n}作业i的周转时间}{n}</script><p>带权周转时间是指作业周转时间与作业实际运行时间的比值</p>
<script type="math/tex; mode=display">
带权周转时间=\frac{作业周转时间}{作业实际运行时间}</script><p>平均带权周转时间是指多个作业的带权周转时间的平均值</p>
<script type="math/tex; mode=display">
平均带权周转时间=\frac{\sum_{i=1}^n作业i的带权周转时间}{n}</script><h2 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h2><p>等待时间是指进程处于等处理机状态的时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不能影响作业执行或输入输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个算法的优劣，通常只需要简单地考察等待时间。</p>
<h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>响应时间是指用户从提交请求到系统首次产生响应所用的时间。在交互式系统中周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p>
<h1 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h1><p>操作系统中存在着多种调度算法，有的调度算法适用于作业调度，有点调度算法适用于进程调度，有的调度算法两者都适用。</p>
<h2 id="FCFS算法"><a href="#FCFS算法" class="headerlink" title="FCFS算法"></a>FCFS算法</h2><p>先来先服务算法是一种最简单的调度算法，它既可用于作业调度，又可用于进程调度。</p>
<p>$FCFS$调度算法属于不可剥夺算法。从表面上看，它对所有作业是公平的，但若一个长作业先到达系统，就会使后面很多短作业等待很多时间，因此它不能作为分时操作系统和实时操作系统的调度策略。但它常被结合在其它许多调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按$FCFS$原则处理。</p>
<p>$FCFS$调度算法的特点是算法简单，但效率低。对长作业比较有利，但对短作业不利(相对$SJF$和高响应比)；有利于$CPU$繁忙型作业，而不利于$I/O$繁忙型作业。</p>
<h2 id="SJF算法"><a href="#SJF算法" class="headerlink" title="SJF算法"></a>SJF算法</h2><p>短作业优先算法从后备队列中选择一个或若干估计运行时间最短的作业，将它们调入内存运行；短进程(SPF)优先调度算法从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p>
<p>$SJF$调度算法也存在着不可忽视的缺点</p>
<ul>
<li>该算法对长进程不利。$SJF$调度算法中长作业的周转时间会增加，容易发生饥饿现象。</li>
<li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。</li>
<li>由于作业的长短只是根据用户所提供的估计执行时间而定的，因此难以保证数据的可靠性。</li>
</ul>
<p>$SJF$调度算法的平均等待时间、平均周转时间是最少的。</p>
<h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p>优先级调度算法即可用作作业调度又可用作进程调度。该算法中的优先级用于描述作业运行的紧迫程度。</p>
<p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为</p>
<ul>
<li>非剥夺式优先级调度算法。即需等待处理机上的进程完成或阻塞之后才可占用处理机。</li>
<li>剥夺式优先级调度算法。即无条件直接占用处理机。</li>
</ul>
<p>根据进程创建后其优先级是否可变，可将进程优先级分为</p>
<ul>
<li>静态优先级。即在创建进程时就确定其优先级，并在整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</li>
<li>动态优先级。在进程运行过程中，会根据进程情况动态变化其优先级。动态调整的主要依据有占有$CPU$时间的长短、就绪进程等待$CPU$时间的长短。</li>
</ul>
<p>一般来说，进程优先级设置可以参照以下原则</p>
<ul>
<li>系统进程&gt;用户进程。</li>
<li>交互型进程&gt;非交互型进程。</li>
<li>$I/O$型进程&gt;计算型进程。</li>
</ul>
<h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>高响应比优先调度算法主要用于作业调度，是对$FCFS$调度算法和$SJF$调度算法的一种折衷方案。同时考虑了每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
<p>相应比的变化规律可描述为</p>
<script type="math/tex; mode=display">
响应比R_p=\frac{等待时间+要求服务时间}{要求服务时间}</script><p>根据公式可知</p>
<ol>
<li>作业等待时间相同时，要求服务时间越短，响应比越高，有利于短作业。</li>
<li>要求服务时间相同时，作业响应比由其等待时间决定，等待时间越长，其响应比越高，因而实现的是先来先服务。对于长作业，也避免了饥饿现象。</li>
</ol>
<h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p>时间片轮转调度算法主要用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中的第一个进程执行，即先来先服务原则，但仅能运行一个时间片。在使用完一个时间片后，处理机将被剥夺给下一个就绪的进程，而被剥夺处理机的进程如果未执行完成，需到就绪队列末尾重新排队。</p>
<p>在时间片轮转调度算法中，时间片的大小对系统性能影响很大。</p>
<ul>
<li>若时间片足够大，以至于所有进程都在一个时间片内执行完毕，那么时间片轮转调度算法将退化为先来先服务调度算法。</li>
<li>若时间片很小，则处理机将在进程间过于频繁地切换，使处理机的开销增大，而真正用于运行用户进程的时间占比将减少。</li>
</ul>
<p>时间片的长短通常由以下因素决定</p>
<ul>
<li>系统响应时间</li>
<li>就绪队列中进程的数目</li>
<li>系统的处理能力</li>
</ul>
<h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标，并不必实现估计进程的执行时间。</p>
<p>实现思想</p>
<ol>
<li>设置多个就绪队列，并为各个队列赋予不同的优先级，第一级队列的优先级最高，其余队列优先级逐次降低。</li>
<li>赋予各个队列中进程执行时间片的大小各不相同。在优先级越高的队列中，每个进程运行的时间片越小。</li>
<li>当一个新进程进入内存后，首先将它放入第一优先级队列的末尾，按$FCFS$原则排队等待调度。当轮到该进程执行时，若其无法在一个时间片内完成，调度程序将其转入第二优先级队列的末尾，之后以此类推。直到依次降到第n优先级队列后，就在第n级队列采用时间片轮转的方式运行。</li>
<li>仅当第$i$优先级队列为空时，调度程序才调度第$i+1$优先级队列中的进程。若处理机正在执行第$i$级队列中的进程，这时有进程进入优先级更高的队列，那么新进程将抢占处理机，调度程序将之前的进程放回到第$i$优先级队列的末尾。</li>
</ol>
<p>多级反馈队列调度算法的优点</p>
<ul>
<li>终端型作业用户：短作业优先</li>
<li>短批处理作业用户：周转时间较短</li>
<li>长批处理作业用户：经过前面几个队列得到部分执行，不至于长期得不到处理。</li>
</ul>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-215-数组中的第K个最大元素</title>
    <url>/2020/06/28/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] 和 k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure><br>说明:</p>
<ul>
<li>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</li>
</ul>
<a id="more"></a>
<hr>
<p>需要得到数组的第K个最大的元素很自然会想到堆排序。因为堆排序过程中，每次取的就是当前最大(小)的元素，那么第K大就是第K次取的元素。这里建立的是大根堆。</p>
<p>堆排序最重要的部分是每次进行调整的过程。对于一个需要调整的节点，观察其是否满足大于其左右孩子，否则取左右孩子中最大的那个与当前节点进行交换，之后再对交换后的孩子节点继续这个递归过程。</p>
<p>所以整个堆排序分为两步：</p>
<ol>
<li>遍历整个序列进行建堆。即，对序列中每个元素都做一次调整。</li>
<li>建完堆之后，序列中第一个元素肯定是最大值，那么每次将其与末尾元素交换，并令序列逻辑长度减一。循环此操作，直到序列的逻辑长度为0为止。</li>
</ol>
<p>而此题为了找到第K大的元素，其实只需要执行K次取最大元素的操作就可结束了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">ceil</span>(size/<span class="number">2</span>);i&gt;=<span class="number">0</span>;--i)heapify(nums,i,size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size<span class="number">-1</span>;i&gt;<span class="number">-1</span>&amp;&amp;--k;--i)&#123;</span><br><span class="line">            swap(nums[<span class="number">0</span>],nums[i]);</span><br><span class="line">            heapify(nums,<span class="number">0</span>,--size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lagest = index, left = index*<span class="number">2</span>+<span class="number">1</span>, right = index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;size&amp;&amp;nums[lagest]&lt;nums[left])lagest = left;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;size&amp;&amp;nums[lagest]&lt;nums[right])lagest = right;</span><br><span class="line">        <span class="keyword">if</span>(lagest!=index)&#123;</span><br><span class="line">            swap(nums[index],nums[lagest]);</span><br><span class="line">            heapify(nums,lagest,size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>考研核心词汇Unit-3</title>
    <url>/2020/06/27/english/%E8%80%83%E7%A0%94%E6%A0%B8%E5%BF%83%E8%AF%8D%E6%B1%87Unit-3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<ul>
<li>blush<ul>
<li>vi/n. 脸红</li>
</ul>
</li>
<li>flush<ul>
<li>n/v. 脸红；冲洗</li>
<li>厕所的冲洗按钮上就是这个词</li>
<li>splash v. 飞溅</li>
</ul>
</li>
<li>considerable<ul>
<li>adj. 相当大（或多）的；值得考虑的</li>
</ul>
</li>
<li>casual<ul>
<li>adj. 漫不经心的；偶然的；非正式的</li>
<li>休闲装的标签上有这个词</li>
<li>casually adv. 偶然地；随便地；临时地</li>
<li>casualness n. 随便；漫不经心</li>
</ul>
</li>
<li>contempt<ul>
<li>n. 轻视；轻蔑</li>
<li>tempt v. 诱惑</li>
<li>temptation n. 诱惑；诱饵</li>
<li>lure v/n. 诱惑</li>
<li>contemptuous adj. 轻蔑的；</li>
<li>对于诱惑的人表示很轻蔑</li>
</ul>
</li>
<li>circumstance<ul>
<li>n. 环境，境况</li>
<li>circum—-⚪ stance—-stand 围绕的站着的=环境</li>
<li><strong>under no circumstances</strong><ul>
<li>在任何情况下绝不</li>
<li>写作的时候可以用 等于not</li>
<li>放句首整句用倒装</li>
</ul>
</li>
</ul>
</li>
<li>accommodate<ul>
<li>v. 为…提供住宿；适应</li>
<li>com—-来—-date—-约会</li>
<li>一再的来约会<ul>
<li>需要提供住宿</li>
<li>慢慢的就适应的</li>
</ul>
</li>
</ul>
</li>
<li>comparsion<ul>
<li>n. 比较；对照</li>
<li>by comparsion 相比之下</li>
</ul>
</li>
<li>compile<ul>
<li>vt. 汇编；编纂</li>
<li>pile n. 堆；大量</li>
<li>piles of 一大批；一大团</li>
</ul>
</li>
<li>contact<ul>
<li>n. 联系；接触</li>
<li>vt. 使接触；有联系</li>
<li>intact 未触动的；完整的</li>
</ul>
</li>
<li>catalog(ue)<ul>
<li>n. 目录</li>
<li>v. 将…编入目录</li>
</ul>
</li>
<li>counter<ul>
<li>n. 柜台；计算器；计数器</li>
<li>adj. 相对的；</li>
<li>英雄联盟里面的对位康特</li>
<li>count v/n. 数数</li>
<li>account n. 账户；账目</li>
<li>accountant n. 会计</li>
<li>uncountable adj. 不可数的；很多的</li>
<li>counterpart n. 相似的人或物</li>
<li>encounter v. 遇见；遭遇</li>
<li>discount n. 折扣；vt. 把…打折</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-213-打家劫舍II</title>
    <url>/2020/06/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</url>
    <content><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<hr>
<p>这题相比之前的线性状的房屋，环状的区别在于第一间房和最后一间房不能够同时抢。因此可以把问题转化为求两个线性序列的最大值，它们的首尾分别是从0到length-1和1到length。</p>
<ul>
<li>分别的求解过程依然是动态规划，保存不取上一间房的结果和取上一间房的结果，再判断当前这间房该不该抢。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>)<span class="keyword">return</span> nums.empty()?<span class="number">0</span>:nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">auto</span> ergodic = [&amp;](<span class="keyword">int</span> begin,<span class="keyword">int</span> end)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> last = <span class="number">0</span>;begin&lt;end;++begin)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = res;</span><br><span class="line">                res = max(last + nums[begin],res);</span><br><span class="line">                last = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> max(ergodic(<span class="number">0</span>,nums.size()<span class="number">-1</span>),ergodic(<span class="number">1</span>,nums.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>考研核心词汇Unit-2</title>
    <url>/2020/06/26/english/%E8%80%83%E7%A0%94%E6%A0%B8%E5%BF%83%E8%AF%8D%E6%B1%87Unit-2/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<ul>
<li>adapt<ul>
<li>v. 适应；改编</li>
</ul>
</li>
<li>adopt<ul>
<li>v. 收养；采取</li>
</ul>
</li>
<li>adept<ul>
<li>adj. 熟练的</li>
<li>n. 专家</li>
</ul>
</li>
<li>award<ul>
<li>n. 奖金；奖品</li>
</ul>
</li>
<li>reward<ul>
<li>n. 报答；奖赏</li>
</ul>
</li>
<li>amuse<ul>
<li>vt. 逗乐；逗笑</li>
<li>amusing <ul>
<li>adj. 娱乐的；搞笑的</li>
</ul>
</li>
<li>amusement</li>
<li>amaze</li>
<li>amazing</li>
</ul>
</li>
<li>aggressive<ul>
<li>adj. 好斗的；侵略性的；有闯劲的；有进取心的</li>
<li>progress——<strong>[gress]</strong>词根表示 进步,走</li>
<li>ag-gress 一再地走 sive——形容词</li>
<li>congress 一起往里走—— n. 国会；议会</li>
<li>digress 两个走—— n. 离题；跑题</li>
<li>aggression</li>
<li>aggressor</li>
</ul>
</li>
<li>apply<ul>
<li>vi. 申请；适用于</li>
<li>vt. 使用；应用；实施</li>
<li>applicant n. 申请人</li>
<li>application n. 申请；应用程序</li>
<li>applicable adj. 可适用的；明智的</li>
</ul>
</li>
<li>accurate<ul>
<li>adj. 正确的；精确的</li>
<li>accuracy n. 精确性；正确度</li>
<li>inaccurate adj. 不准确的；模糊的</li>
</ul>
</li>
<li>approximate<ul>
<li>adj. 近似的；大约的</li>
<li>intimate 知己；密友</li>
<li>inmate 狱友</li>
</ul>
</li>
<li>adhere<ul>
<li>v. 沾着；粘着</li>
<li>一再的在这</li>
<li>attach v. 沾着；附加</li>
</ul>
</li>
<li>assure<ul>
<li>v. 保证；使确信</li>
<li>一再确定</li>
<li>ensure</li>
</ul>
</li>
<li>accelerate<ul>
<li>v. 加速</li>
<li>一再地走——加速</li>
<li>decelerate v. 减速</li>
</ul>
</li>
<li>approve<ul>
<li>v. 批准；赞同(后跟of)</li>
</ul>
</li>
<li>awkward<ul>
<li>adj. 令人尴尬的</li>
<li>old flame 旧情人 没有new flame 不要乱编</li>
<li>awkwardly adv. 笨拙地；无技巧地</li>
</ul>
</li>
<li>annoy<ul>
<li>vt. 使苦恼；骚扰</li>
<li>annoyed adj. 恼怒的；烦的</li>
<li>distrub v. 打扰；妨碍</li>
</ul>
</li>
<li>bare<ul>
<li>adj. 赤裸的；光秃秃的</li>
<li>vt. 使裸露；露出</li>
<li>bar 圆木棍—-光秃的—-酒吧里很裸露<ul>
<li>barren 不孕不育的；贫瘠的  bar—-ren 酒吧里的人 喝多了酒容易不孕不育</li>
<li>bargain v. 讨价还价的；便宜货；协议 bar—-gain 用棍子得到 便宜货 讨价还价</li>
<li>barbarian n. 野蛮人；原始人 bar—-bar—-ian 拿着棍子的人</li>
<li>barbarous adj. 野蛮的；暴力的</li>
<li>barrier n. 障碍 bar—-rier 棍子做成的—-障碍物</li>
<li>embarrassing adj. 使人尴尬的 em—-bar—-ass 棍子打屁股 很尴尬</li>
</ul>
</li>
</ul>
</li>
<li>blunt<ul>
<li>adj. 不锋利的；钝的；率直的；直言不讳的</li>
<li>sharp adj. 锋利的；清晰的</li>
</ul>
</li>
<li>benefit<ul>
<li>n. 利益；津贴；救济金</li>
<li>beneficial adj. 有益的</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-235-二叉搜索树的最近公共祖先</title>
    <url>/2020/06/26/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<a id="more"></a>
<hr>
<p>两个节点同属于一个节点之下的时候，其特征为这两个节点是同时大于等于或小于等于这个节点的。因此可直接对二叉搜索树进行一次查找，两个节点的查找的公共路径的分叉节点即为最近的公共祖先节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = root;</span><br><span class="line">        <span class="keyword">while</span>(res)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;res-&gt;val&amp;&amp;q-&gt;val&lt;res-&gt;val)&#123;</span><br><span class="line">                res = res-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val&gt;res-&gt;val&amp;&amp;q-&gt;val&gt;res-&gt;val)&#123;</span><br><span class="line">                res = res-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-211-添加与搜索单词-数据结构设计</title>
    <url>/2020/06/26/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addWord(word)</li>
<li>bool search(word)</li>
<li>search(word) </li>
</ul>
<p>可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。 . 可以表示任何一个字母。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"bad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"dad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">addWord</span><span class="params">(<span class="string">"mad"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"pad"</span>)</span></span> -&gt; false</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"bad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">".ad"</span>)</span></span> -&gt; true</span><br><span class="line"><span class="function"><span class="title">search</span><span class="params">(<span class="string">"b.."</span>)</span></span> -&gt; true</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>你可以假设所有单词都是由小写字母 a-z 组成的。</li>
</ul>
<a id="more"></a>
<hr>
<p>需要构造一颗字典树，由于字符的种类是限定好的，方便起见可以构造一颗固定叉树。与以往不同的是，在搜索的对象中可能会有正则表达字符。这时候只需要将该节点的每个非空子树搜索一遍即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    <span class="keyword">bool</span> end;</span><br><span class="line">    <span class="built_in">vector</span>&lt;WordDictionary*&gt; son;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary():val(<span class="string">'\0'</span>),end(<span class="literal">false</span>) &#123;</span><br><span class="line">        son = <span class="built_in">vector</span>&lt;WordDictionary*&gt;(<span class="number">26</span>,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WordDictionary(<span class="keyword">char</span> v):val(v),end(<span class="literal">false</span>) &#123;</span><br><span class="line">        son = <span class="built_in">vector</span>&lt;WordDictionary*&gt;(<span class="number">26</span>,<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.empty())&#123;</span><br><span class="line">            end = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = word[<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[index])son[index] = <span class="keyword">new</span> WordDictionary(word[<span class="number">0</span>]);</span><br><span class="line">        son[index]-&gt;addWord(word.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.empty())<span class="keyword">return</span> end;</span><br><span class="line">        <span class="keyword">if</span>(word[<span class="number">0</span>]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = word[<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">return</span> son[index]&amp;&amp;son[index]-&gt;search(word.substr(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> index:son)</span><br><span class="line">                <span class="keyword">if</span>(index&amp;&amp;index-&gt;search(word.substr(<span class="number">1</span>)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>考研核心词汇Unit-1</title>
    <url>/2020/06/25/english/%E8%80%83%E7%A0%94%E6%A0%B8%E5%BF%83%E8%AF%8D%E6%B1%87Unit-1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>
<ul>
<li>ascend<ul>
<li>v. 升高，攀登</li>
<li><strong>[ce]</strong>当词根的时候有 <strong>走</strong> 的意思。</li>
</ul>
</li>
<li>descend<ul>
<li>vi. 下来；下降</li>
<li><strong>[de]</strong>当词根有 <strong>下降，分开</strong>的意思</li>
</ul>
</li>
<li>descent<ul>
<li>n. 下降；下落</li>
</ul>
</li>
<li>descendant<ul>
<li>n. 子孙；后裔；后代</li>
</ul>
</li>
<li>absent<ul>
<li>adj. 缺席的；不存在的</li>
<li>除了带<strong>[ab]</strong>词根的词带否定，其它所有<strong>[a*]</strong>词根没有意思，表示强调，一再。</li>
<li>absent from school/meeting</li>
<li>absent-minded</li>
</ul>
</li>
<li>absence<ul>
<li>n. 缺席</li>
</ul>
</li>
<li>astonish<ul>
<li>vt. 使惊讶</li>
<li>记法：a stone 你死 = 惊讶</li>
</ul>
</li>
<li>access<ul>
<li>n. 通道；人口接近(或见面、使用)的机会(或权力)</li>
</ul>
</li>
<li>accessible<ul>
<li>adj. 后缀：可…的；（一个人）可接近的</li>
</ul>
</li>
<li>assess<ul>
<li>vt. 评价；估价，确定金额</li>
</ul>
</li>
<li>assessment n. 估价；估定</li>
<li>agent<ul>
<li>n. 代理商；动因</li>
<li>记法：发音有点像engine，即动机。代理商自己背</li>
<li>drying agent 干燥剂</li>
</ul>
</li>
<li>agency<ul>
<li>n. 代理处；专业行政部门</li>
<li>travel agency 旅行社</li>
</ul>
</li>
<li>assign<ul>
<li>vt. 委派；指派；分配</li>
</ul>
</li>
<li>assignment<ul>
<li>n. 分配；委派；任务</li>
</ul>
</li>
<li>appeal<ul>
<li>n/v. 请求；呼吁；有吸引力；上诉</li>
</ul>
</li>
<li>appreciate<ul>
<li>vt. 重视；欣赏；感激</li>
<li>记法：<ul>
<li>price n.价格</li>
<li>precious adj. 珍贵的</li>
</ul>
</li>
</ul>
</li>
<li>annual<ul>
<li>n. 年刊；一年生植物</li>
<li>adj. 一年一次的</li>
<li><strong>[ann-]</strong>前缀表示 一年</li>
<li>anniversary 周年纪念<ul>
<li>记法：<ul>
<li><strong>[verse]</strong> 转</li>
<li>universe 联合起来转表示宇宙</li>
<li>一年转一次表示 周年纪念</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>accuse<ul>
<li>v. 谴责；指责；控告</li>
<li>记法：cuse——curse 诅咒 一再的诅咒你</li>
<li>用法：accuse sb of doing sth.</li>
</ul>
</li>
<li>accusation<ul>
<li>n. 指责；谴责</li>
</ul>
</li>
<li>approve<ul>
<li>vt. 赞成；同意；批准</li>
<li>记法：<ul>
<li>prove 证明</li>
<li>validate 证明 <ul>
<li>valid 有效的+<strong>[-ate]</strong>动词后缀</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>以后表示政府 除了grovement 还能用 authority</li>
<li>abuse<ul>
<li>vt. 滥用；虐待</li>
<li><strong>[ab-]</strong>前缀表否定</li>
<li>ab-use 非-正常使用</li>
<li>引申：<ul>
<li>abandon 抛弃；放弃</li>
<li>abortion 流产；堕胎——不让出生</li>
<li>aboard 登机；上船——离开板子</li>
</ul>
</li>
<li>drug abuse 滥用药物</li>
<li>child abuse 虐带儿童</li>
</ul>
</li>
<li>appropriate<ul>
<li>adj. 适当的</li>
<li>proper 合适的 property 财产 最合适的即财产最多的 asset 财产 破产的时候会一再的放置 </li>
<li>ap-propri-ate 一再合适的=合适的</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-210-课程表II</title>
    <url>/2020/06/25/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-210-%E8%AF%BE%E7%A8%8B%E8%A1%A8II/</url>
    <content><![CDATA[<p>现在你总共有 n 门课需要选，记为 0 到 n-1。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]。给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。要学习课程 <span class="number">1</span>，你需要先完成课程 <span class="number">0</span>。因此，正确的课程顺序为 [<span class="number">0</span>,<span class="number">1</span>] 。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">4</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">or</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释: 总共有 <span class="number">4</span> 门课程。要学习课程 <span class="number">3</span>，你应该先完成课程 <span class="number">1</span> 和课程 <span class="number">2</span>。并且课程 <span class="number">1</span> 和课程 <span class="number">2</span> 都应该排在课程 <span class="number">0</span> 之后。</span><br><span class="line">     因此，一个正确的课程顺序是 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 。另一个正确的排序是 [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。</li>
</ul>
<p>提示:</p>
<ul>
<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>
<li>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>
<li>拓扑排序也可以通过 BFS 完成。</li>
</ul>
<a id="more"></a>
<hr>
<p>这道题就是要拓扑排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; hash;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> pair:prerequisites)&#123;</span><br><span class="line">            hash[pair[<span class="number">1</span>]].insert(pair[<span class="number">0</span>]);</span><br><span class="line">            ++num[pair[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(num[i] == <span class="number">0</span>)q.push(i);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:hash[q.front()])</span><br><span class="line">                <span class="keyword">if</span>(--num[i] == <span class="number">0</span>)q.push(i);</span><br><span class="line">            res.push_back(q.front());</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:num)<span class="keyword">if</span>(i)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-234-回文链表</title>
    <url>/2020/06/24/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>请判断一个链表是否为回文链表。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>进阶：</p>
<ul>
<li>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</li>
</ul>
<a id="more"></a>
<hr>
<p>由于单链表难以访问上一个节点，因此如果想在常数级空间完成回文串判断，必须进行多趟遍历。</p>
<ul>
<li>第一趟找出单链表的中点。</li>
<li>第二趟将中点之后的部分翻转。</li>
<li>第三趟双指针分别指向表头和中点，同步前进进行搜索判断。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = find_mid(head);</span><br><span class="line">        reverse(mid);</span><br><span class="line">        <span class="keyword">for</span>(mid = mid-&gt;next;mid;mid = mid-&gt;next,head = head-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(mid&amp;&amp;mid-&gt;val!=head-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">find_mid</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> *H = <span class="keyword">new</span> ListNode();</span><br><span class="line">        H-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> i = H, j = H;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;j-&gt;next)&#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> H;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode* H)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = H-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(i-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = H-&gt;next;</span><br><span class="line">            H-&gt;next = i-&gt;next;</span><br><span class="line">            i-&gt;next = i-&gt;next-&gt;next;</span><br><span class="line">            H-&gt;next-&gt;next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-232-用栈实现队列</title>
    <url>/2020/06/24/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) — 将一个元素放入队列的尾部。</li>
<li>pop() — 从队列首部移除元素。</li>
<li>peek() — 返回队列首部的元素。</li>
<li>empty() — 返回队列是否为空。</li>
</ul>
<p>示例:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">MyQueue <span class="built_in">queue</span> = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">queue</span>.push(<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">queue</span>.<span class="built_in">peek</span>();  <span class="comment">// 返回 1</span></span><br><span class="line"><span class="built_in">queue</span>.pop();   <span class="comment">// 返回 1</span></span><br><span class="line"><span class="built_in">queue</span>.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>你只能使用标准的栈操作 — 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<a id="more"></a>
<hr>
<p>与用队列实现栈不同的是，栈比队列要畸形一些，因为它只有一个口是开放的。所以如果用单栈无法实现队列的功能，需要用一个辅助栈来帮助调转栈中的元素。让每次入栈的元素都沉入栈底。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span>(!mystack.empty())&#123;</span><br><span class="line">            tmp.push(mystack.top());</span><br><span class="line">            mystack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        mystack.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!tmp.empty())&#123;</span><br><span class="line">            mystack.push(tmp.top());</span><br><span class="line">            tmp.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = mystack.top();</span><br><span class="line">        mystack.pop();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mystack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-225-用队列实现栈</title>
    <url>/2020/06/24/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<p>使用队列实现栈的下列操作：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span><span class="params">(x)</span></span> -- 元素 x 入栈</span><br><span class="line"><span class="function"><span class="title">pop</span><span class="params">()</span></span> -- 移除栈顶元素</span><br><span class="line"><span class="function"><span class="title">top</span><span class="params">()</span></span> -- 获取栈顶元素</span><br><span class="line"><span class="function"><span class="title">empty</span><span class="params">()</span></span> -- 返回栈是否为空</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p>你只能使用队列的基本操作— 也就是 </p>
<ul>
<li>push to back</li>
<li>peek/pop from front</li>
<li>size</li>
<li>is empty </li>
</ul>
<p>这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p>
<a id="more"></a>
<hr>
<p>队列与栈的差别在于一个先进先出，一个先进后出。而用队列实现栈，只要每次将入队之后的元素挪到队头即可实现先进先出。因此入队的时间复杂度为$O(n)$，而出队的时间复杂度为$O(1)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        myqueue.push(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;myqueue.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = myqueue.front();</span><br><span class="line">            myqueue.pop();</span><br><span class="line">            myqueue.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = myqueue.front();</span><br><span class="line">        myqueue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myqueue.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myqueue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2020/06/23/os/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在多道程序环境下，允许多个程序并发执行，此时它们失去封闭性，并具有间断性和不可再现性。为此引入进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的<strong>并发性</strong>和<strong>共享性</strong>。</p>
<a id="more"></a>
<h1 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h1><p>从不同的角度，进程可以有不同的定义，比如</p>
<ul>
<li>进程是程序的一次执行过程。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
</ul>
<h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><p>进程是操作系统进行资源分配和调度的基本单位。进程映像由程序段，数据段和$PCB$构成。</p>
<h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>为了使参与并发执行的程序，包括数据能独立运行，必须为之配置一个专门的数据结构，称为进程控制块</p>
<script type="math/tex; mode=display">
(Process\ Control\ Block,PCB)</script><p>系统利用$PCB$来描述进程的基本情况和运行状态进而控制和管理进程。所谓创建进程，实质上是创建进程映像中的$PCB$；而撤销进程，实质上就是撤销进程的$PCB$。值得注意的是，进程映像是静态的，进程则是动态的。$PCB$<strong>是进程存在的唯一标志</strong>。</p>
<p>进程控制块通常包括以下内容：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">进程描述信息</th>
<th style="text-align:center">进程控制和管理信息</th>
<th style="text-align:center">资源分配清单</th>
<th style="text-align:center">处理机相关信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进程标识符(PID)</td>
<td style="text-align:center">进程当前状态</td>
<td style="text-align:center">代码段指针</td>
<td style="text-align:center">通用寄存器值</td>
</tr>
<tr>
<td style="text-align:center">用户标识符(UID)</td>
<td style="text-align:center">进程优先级</td>
<td style="text-align:center">数据段指针</td>
<td style="text-align:center">地址寄存器值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">代码运行入口地址</td>
<td style="text-align:center">堆栈段指针</td>
<td style="text-align:center">控制寄存器值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">程序的外存地址</td>
<td style="text-align:center">文件描述符</td>
<td style="text-align:center">标志寄存器值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">进入内存时间</td>
<td style="text-align:center">键盘</td>
<td style="text-align:center">状态字</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">处理机占用时间</td>
<td style="text-align:center">鼠标</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">信号量使用</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>在一个系统中通常存在许多进程的$PCB$。为了方便管理和调度，需要将它们用适当的方法组织起来。常用的组织方式有链接方式和索引方式两种。</p>
<h3 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h3><p>程序段是能被进程调度程序调度到$CPU$执行的程序代码段。程序是可被多个进程共享的，即多个进程可以运行同一个程序。</p>
<h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行是产生的中间或最终结果。</p>
<h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序顺序执行提出的，也是对进程管理提出的基本要求。</p>
<ol>
<li>动态性。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程的最基本特征。</li>
<li>并发性。指多个进程映像同时存在内存中，能在一段时间内同时运行。并发性是进程的重要特征，同时也是操作系统的重要特征。引入进程的目的就是为了使程序能与其它进程的程序并发执行，以提高资源利用率。</li>
<li>独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立$PCB$的程序，都不能作为一个独立的单位参与运行。</li>
<li>异步性。由于进程的相互制约，使得进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</li>
<li>结构性。每一个进程都配置一个$PCB$对其进行描述。</li>
</ol>
<h1 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h1><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境变化，使得进程的状态也在不断地发生变化。通常有以下五种状态，前三种是进程的基本状态</p>
<ol>
<li>运行态。进程在处理机上运行。在单处理机的环境下，每个时刻最多只有一个进程处于运行态。</li>
<li>就绪态。进程获得除处理机外的一切所需资源，一旦得到处理机，便可立即执行。</li>
<li>阻塞态。又称等待态。进程正在等待某一事件而暂停运行。即使处理机空闲，该进程也不能占用处理机。</li>
<li>创建态。进程正在被创建，尚未转到就绪态。</li>
<li>结束态。进程正在从系统中消失。进程需要结束运行时，系统必须置该进程为结束态，然后进一步处理资源释放和回收等工作。</li>
</ol>
<pre class="mermaid">graph LR
NEW(新建)--创建-->READY(就绪)
READY--调度-->RUN(运行)
RUN--退出-->END(终止)
RUN--时间片结束-->READY
RUN--事件等待-->BLOCK(阻塞)
BLOCK--事件结束-->READY</pre>

<p>需要注意的是，一个进程从运行态变成阻塞态是主动行为；而从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助。</p>
<h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><p>进程控制的主要功能是对系统中所有进程实施有效管理。在操作系统中，一般将进程控制用的程序段称为原语，即执行期间不可中断，是一个不可分割的基本单位。</p>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应当将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，必须撤销其所有子进程。</p>
<p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建原语如下</p>
<ol>
<li>为新进程分配一个唯一的进程标识号，并申请一个空白的$PCB$。若$PCB$申请失败，则创建失败。</li>
<li>为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间，体现在$PCB$中。若资源不足，<strong>创建进程的进程</strong>则进入阻塞态，等待内存资源。</li>
<li>初始化$PCB$，主要包括初始化标准信息，处理机状态信息，处理机控制信息，设置进程的优先级。</li>
<li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</li>
</ol>
<h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>进程终止原语如下</p>
<ol>
<li>根据被终止进程的标识符，检索$PCB$，从中读出该进程的状态。</li>
<li>若被终止进程处于运行态，立即终止执行，将处理机资源分配给其它进程。</li>
<li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li>
<li>将该进程所拥有的全部资源，或归还给父进程，或归还给操作系统。</li>
<li>将该PCB从所在队列中删除。</li>
</ol>
<h2 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h2><p>因为进程阻塞是进程自身的一种主动行为，所以只有处于运行态的进程才可能将其转为阻塞态。阻塞原语如下</p>
<ol>
<li>找到将要被阻塞进程的标识号对应的PCB。</li>
<li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</li>
<li>把该$PCB$插入相应事件的等待队列，并将处理机资源调度给其它就绪进程。</li>
</ol>
<p>当被阻塞进程所期待完成的事件完成后，将等待该事件的进程唤醒。唤醒原语如下</p>
<ol>
<li>在该事件的等待队列中找到相应进程的$PCB$。</li>
<li>将其从等待队列中移除，并置其状态为就绪态。</li>
<li>把该$PCB$插入就绪队列，等待调度程序调度。</li>
</ol>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程切换是在操作系统内核的支持下实现的，因此任何进程都是在操作系统内核的支持下运行的。在进程切换的过程中，进程的运行环境发生了实质性变化。进程切换过程如下(参考中断的过程)</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其它寄存器。</li>
<li>更新$PCB$信息。</li>
<li>把进程的$PCB$移入相应的队列。</li>
<li>选择另一个进程执行，并更新其$PCB$。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<p>进程切换和处理机切换是不同的，模式切换时，处理机逻辑上可能还在同一进程中运行。若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的程序运行，则操作系统只需恢复进程进入内核时所保存的$CPU$现场，而无需改变当前进程的环境信息。但若要切换进程，当前运行进程改变了，则当前进程的环境信息也需要改变。</p>
<h1 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h1><p>进程通信是指进程之间的信息交换。$PV$操作就是一种低级的通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三种：</p>
<h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行读写操作实现进程之间的信息交换。在对共享空间进行读写时，需要使用同步互斥工具，对共享空间的读写进行控制。共享存储也有两种</p>
<ul>
<li>低级方式的共享是基于数据结构的共享。</li>
<li>高级方式的共享则是基于存储区的共享。</li>
</ul>
<p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读写指令完成。</p>
<pre class="mermaid">graph LR
process1(进程)-->room(共享空间)
room-->process2(进程)
process2-->room
room-->process1</pre>

<p>用户进程空间一般是独立的，进程运行期间一般不能访问其它进程的空间，如果希望两个用户进程共享存储空间，必须通过特殊的系统调用来实现，当然同一进程内的线程是自然共享进程空间的。</p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>在消息传递系统中，进程间的数据交换是以格式化的消息为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送信息和接收消息两个原语进行数据交换。</p>
<ul>
<li>直接通信方式。发送进程直接把消息发送给接受进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得信息。</li>
</ul>
<pre class="mermaid">graph LR
process1(进程)-->process2(进程)
process2-->process1</pre>

<ul>
<li>间接通信方式。发送进程把信息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般被称为信箱。这种通信方式又被称为信箱通信方式，被广泛应用于计算机网络中。</li>
</ul>
<h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>管道通信是消息传递的一种特殊方式。所谓管道是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名$pipe$文件。向管道提供输入的发送进程，以字符流形式将大量的数据送入(写)管道；而接收管道输出的接收进程，则从管道中接收(读)数据。为了协调双方的通信，管道机制必须提供以下三方面协调能力：<strong>互斥，同步，确定对方的存在</strong>。</p>
<pre class="mermaid">graph LR
process1(进程)-->buffer1(缓冲区1)
buffer1-->process2(进程)
process2-->buffer2(缓冲区2)
buffer2-->process1</pre>

<p>管道可以理解为共享存储的优化和发展，因为在共享存储中，若某进程要访问共享存储空间，则必须没有其他进程在该共享存储空间中进行写操作，否则访问行为就会收到阻塞。而管道通信中存储空间进化成了缓冲区，缓冲区只允许一边写入，另一边读出，因此只要缓冲区中有数据进程就能从缓冲区中读出，而不必担心会因为其它进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，然后才让读进程读，当缓冲区中还有数据时，写进程不会往缓冲区写数据。这也决定了管道通信是半双工通信。</p>
<h1 id="线程与多线程模型"><a href="#线程与多线程模型" class="headerlink" title="线程与多线程模型"></a>线程与多线程模型</h1><h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><p>引入进程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
<p>线程最直接的理解就是“轻量级进程”，它是一个基本的$CPU$执行单元，也是程序执行流的最小单元。由线程$ID$、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不会拥有系统资源，只拥有运行所必须的那部分资源。进程内的所有资源是由它的所有线程共享的。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪，阻塞和运行三种基本状态。</p>
<p>引入线程后，进程的内涵发生了改变，进程只作为$CPU$外的系统资源的分配单元，而线程作为处理机的分配单元。由于一个进程内有多个线程，若线程的切换发生在同一个进程中只需要很小的时空开销。</p>
<h2 id="进程VS线程"><a href="#进程VS线程" class="headerlink" title="进程VS线程"></a>进程VS线程</h2><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>在传统操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中切换线程，则会引起进程切换。</p>
<h3 id="拥有资源"><a href="#拥有资源" class="headerlink" title="拥有资源"></a>拥有资源</h3><p>不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程除了运行时必须的资源外不拥有系统资源。但线程可以访问其隶属进程的系统资源。若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念就没有提出的必要了。</p>
<h3 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h3><p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高系统的吞吐量。</p>
<h3 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h3><p>由于创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、$I/O$设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。此外，由于同一进程内多个线程共享进程的地址空间，因此线程之间的同步与通信很容易实现，甚至不需要操作系统的干预。</p>
<h3 id="地址空间与其它资源"><a href="#地址空间与其它资源" class="headerlink" title="地址空间与其它资源"></a>地址空间与其它资源</h3><p>进程的地址空间之间相互独立，同进程内的线程共享地址空间和其它资源，进程内的线程对其它线程不可见。</p>
<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>进程间通信需要进程同步和互斥手段来辅助，而线程间可以直接读写进程数据段来进行通信，如全局变量。</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中的线程。</p>
<h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>在内核级线程中，线程管理所有工作由内核来完成，应用程序没有进行线程管理的代码，只有一个内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。</p>
<hr>
<p>有些系统使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些内核级线程上，这些内核级线程的数目是小于等于用户级线程的。</p>
]]></content>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-209-长度最小的子数组</title>
    <url>/2020/06/23/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例: </span><br><span class="line">输入: s = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>
<p>进阶:</p>
<ul>
<li>如果你已经完成了$O(n)$ 时间复杂度的解法, 请尝试 $O(nlogn)$ 时间复杂度的解法。</li>
</ul>
<a id="more"></a>
<hr>
<p>在数组里确定一个范围，自然会想到双指针方法。快慢指针分别确定子数组的范围。</p>
<ul>
<li>如果范围内的和小于目标值且快指针还未移动到顶，那么就让快指针自增，直到范围内的和大于等于目标值。</li>
<li>如果范围内的和大于等于目标值，就让慢指针自增，并重新计算范围内的和，并更新结果。</li>
<li>如果不满足上述两种情况说明快指针到顶且此时快慢指针范围内的和小于目标值。</li>
</ul>
<p>进阶中所说的$O(nlogn)$，应该是用二分法对暴力查找的一种改进。之所以可以用二分法，虽然数组看起来是无序了，但是它的变限积分是有序的，即随着下标增长，和是越来越大的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, sum = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;s&amp;&amp;j&lt;nums.size())</span><br><span class="line">                sum+=nums[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;=s)&#123;</span><br><span class="line">                res = min(j-i,res);</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res!=INT_MAX?res:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2020/06/22/datastructure/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>在线性表和数表当中，记录在表中位置与记录的关键字之间不存在确定关系。因此，在这些表中查找记录时需进行一系列的关键字比较。这类查找方法是建立在比较的基础上的。而查找的效率取决于比较的次数。而理想情况下对散列表进行查找的时间复杂度为$O(1)$，即与表中元素的个数无关。</p>
<a id="more"></a>
<h1 id="散列表的基本概念"><a href="#散列表的基本概念" class="headerlink" title="散列表的基本概念"></a>散列表的基本概念</h1><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>一个把查找表中的关键字映射成该关键字地址的函数，记为$Hash(key)=Addr$，这里的地址可以是数组下标，索引或内存地址等。</p>
<p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发生碰撞的不同关键字称为<strong>同义词</strong>。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>根据关键字而直接进行访问的数据结构。<strong>也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系</strong>。</p>
<h1 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h1><p>在构造散列函数时，必须注意以下几点：</p>
<ol>
<li>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>
<li>散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。</li>
<li>散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。</li>
</ol>
<h2 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h2><p>直接取关键字的某个线性函数值为散列地址，散列函数为</p>
<script type="math/tex; mode=display">
H(key)=key\\OR\\H(key)=a*key+b</script><p>式中，$a$和$b$是常数。这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p>
<h2 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h2><p>这是一种最简单、最常用的方法，假定散列表表长为$m$，取一个不大于$m$但最接近或等于$m$的质数$p$，利用以下公式把关键字转换成散列地址。散列函数为</p>
<script type="math/tex; mode=display">
H(key)=key\%p</script><p>除留余数法的关键是选好$p$，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而减少冲突的可能性。</p>
<h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><p>设关键字是$r$进制数(如十进制数)，而$r$个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</p>
<h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不均匀或均小于散列地址所需的位数。</p>
<p>在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况，但目标是为了尽量降低产生冲突的可能性。</p>
<h1 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h1><p>应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个空的散列地址。用$H_i$表示处理冲突中第$i$次探测得到的散列地址，假设得到的另一个散列地址$H_1$仍然发生冲突，只得寻求下一个地址$H_2$，以此类推，直到$H_k$不发生冲突为止，则$H_k$为关键字在表中的地址。</p>
<h2 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h2><p>所谓开放地址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为</p>
<script type="math/tex; mode=display">
H_i=(H(key)+d_i)\%m</script><p>式中，$H(key)$为散列函数：$i=0,1,2,…,k(k\leq m-1)$；$m$表示散列表长度；$di$为增量序列。取定某一增量序列后，对应的处理方法就是确定的。通常有以下$4$中取法。</p>
<h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>当$d_i=0,1,2,…,m-1$时，称为线性探测法。这种方式的特点是</p>
<ul>
<li>冲突发生时，顺序查看表中下一个单元(探测到表尾地址$m-1$时，下一个探测地址是表首地址)，直到找出一个空闲单元，当表未填满时一定能找到一个空闲单元。</li>
</ul>
<p>线性探测法可能使第$i$个散列地址的同义词存入第$i+1$个散列地址，这样本应存入第$i+1$个散列地址的元素就争夺第$i+2$个散列地址的元素的地址，以此类推。从而造成大量元素在相邻散列地址上<strong>堆积</strong>起来，大大降低查找效率。</p>
<h3 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h3><p>当$d_i=0^2,1^2,-1^2,2^2,-2^2,…,k^2,-k^2$时称为平方探测法，其中$k\leq m/2$，散列表长度$m$必须是一个可以表示成$4k+3$的素数，又称<strong>二次探测法</strong>。之所以长度需要为能表示为$4k+3$的素数是为了使发生冲突时的探查序列不重复。</p>
<p>平方探测法是一种较好的处理冲突的方法，可以避免出现<strong>堆积</strong>问题，它的缺点是不能探测到散列表上所有的单元，但至少能探测到一半单元。</p>
<h3 id="再散列法"><a href="#再散列法" class="headerlink" title="再散列法"></a>再散列法</h3><p>当$d_i=Hash_2(key)$时，称为再散列法。需要使用两个散列函数，当通过第一个散列函数$H(key)$得到的地址发生冲突的时候，则利用第二个散列函数$Hash_2(key)$计算该关键字的地址增量。它的具体散列函数形式如下</p>
<script type="math/tex; mode=display">
H_i=(H(key)+i*Hash_2(key))\%m</script><p>初始探测位置$H_0=H(key)\%m$。$i$是冲突次数，初始为0。在再散列法中，最多经过$m-1$次探测就会遍历表中所有位置。回到$H_0$位置。</p>
<h3 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a>伪随机序列法</h3><p>当$d_i=$伪随机序列时，称为伪随机序列法。</p>
<p><em>在开放定址的情形下，不能随便物理删除表中的已有元素，因为若删除元素，则会截断其他具有相同散列地址的元素的查找地址。因此要删除一个元素时，可以做一个删除标记，进行逻辑删除。但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有很多位置未利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</em></p>
<h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为$i$的同义词链表的头指针存放在散列表的第$i$个单元中，因而查找、插入和删除操作主要在同义词链中进行，拉链法适用于经常进行插入删除的情况。</p>
<h1 id="散列表的查找"><a href="#散列表的查找" class="headerlink" title="散列表的查找"></a>散列表的查找</h1><p>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字$key$，根据散列函数可以计算出其散列地址，执行步骤如下</p>
<ol>
<li>初始化：<code>Addr=Hash(key);</code></li>
<li>检测查找表中地址为$Addr$的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与$key$的值，若相等，则返回查找成功的标志，否则执行步骤3。</li>
<li>用给定的处理冲突方法计算下一个散列地址，并把$Addr$置为此地址，转入步骤2。</li>
</ol>
<p>由散列表的查找过程可见</p>
<ul>
<li>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于冲突的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍要以平均查找长度作为衡量散列表的查找效率度量。</li>
<li>散列表的查找效率取决于三个因素：散列函数，处理冲突的方法和<strong>装载因子</strong>。</li>
</ul>
<p>装载因子。散列表的装载因子一般记为$\alpha$，定义为一个表的装满程度，即</p>
<script type="math/tex; mode=display">
\alpha=\frac{表中记录数n}{散列表长度m}</script><p>散列表的平均查找长度依赖于散列表的装载因子$\alpha$，而不直接依赖于$n$或$m$。直观地看，$\alpha$越大，表示装填的记录越满，发生冲突的可能性越大，反之发生冲突的可能性越小。</p>
]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-322-零钱兑换</title>
    <url>/2020/06/22/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: coins = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], amount = <span class="number">11</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: <span class="number">11</span> = <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: coins = [<span class="number">2</span>], amount = <span class="number">3</span></span><br><span class="line">输出: <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>说明:<br>你可以认为每种硬币的数量是无限的。</p>
<a id="more"></a>
<hr>
<p>这里我想到的是深度优先遍历，由于同种面值硬币可以无限取，那么可以通过大量的剪枝以获得更高的效率。相比最基本的dfs，这题需要做以下调整以提速。</p>
<ul>
<li>将硬币面值从大到小排序，试取硬币时从大的开始试，这样对获得更少的硬币数量更有利。</li>
<li>每一种面值的硬币一开始尝试取最多，如果不能满足走凑成总金额，再逐一减少。</li>
<li>一旦取当前面值硬币的数目加上此前取硬币的数目大于此前得到的一个最终硬币个数，则直接终止当前取法。这一步是剪枝的关键。没有这一条件基本上会超时。</li>
</ul>
<p>最后要注意的是，虽然从面值大的硬币开始取的确有利于更快的找到硬币数最少的方案，这有利于剪枝。但在这种类似贪心的方案，第一次出现的解却不一定是最优解，比如<code>[1,7,10] 14</code>这种奇葩情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        sort(coins.rbegin(),coins.rend());</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        dfs(coins,amount,<span class="number">0</span>,<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res != INT_MAX?res:<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins,<span class="keyword">int</span> amount,<span class="keyword">int</span> index,<span class="keyword">int</span> count,<span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</span><br><span class="line">            res = min(count,res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index == coins.size())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = amount/coins[index];i&gt;=<span class="number">0</span>&amp;&amp;i+count&lt;res;--i)</span><br><span class="line">            dfs(coins,amount-i*coins[index],index+<span class="number">1</span>,count+i,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Huffman树和Huffman编码</title>
    <url>/2020/06/21/datastructure/Huffman%E6%A0%91%E5%92%8CHuffman%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Huffman树的定义"><a href="#Huffman树的定义" class="headerlink" title="Huffman树的定义"></a>Huffman树的定义</h1><p>在许多应用中，数中节点常常被赋予一个表示某种意义的数值，称为该节点的权。从树根到任意节点的路径长度(经过的边数)与该节点上权值的乘积，成为该节点的带权路径长度。树中所有叶节点的带权路径长度之和称为该树的带权路径长度，记为：</p>
<script type="math/tex; mode=display">
WPL=\sum^{n}_{i=1}w_il_i</script><p>式中，$w_i$是第$i$个叶节点所带的权值，$l_i$是该叶节点到根节点的路径长度。在含有$n$个带权叶节点的二叉树中，其中带权路径长度$(WPL)$最小的二叉树称为Huffman树，也称最优二叉树。</p>
<a id="more"></a>
<h1 id="Huffman树的构造"><a href="#Huffman树的构造" class="headerlink" title="Huffman树的构造"></a>Huffman树的构造</h1><p>给定$n$个权值分别为$w_1,w_2,…,w_n$的节点，构造Huffman树的算法描述如下：</p>
<ol>
<li>将这$n$个节点分别作为$n$棵仅含有一个节点的二叉树，构成森林$F$。</li>
<li>构造一个新节点，从$F$中选取两棵根节点权值最小的树作为新节点的左右子树，并且将新节点的权值置为左右子树上根节点的权值之和。</li>
<li>从$F$中删除刚才选出的两棵树，同时将新得到的树加入$F$中。</li>
<li>重复步骤2和3，直至$F$中只剩下一棵树为止。</li>
</ol>
<p>从上述构造过程中可以看出Huffman树具有以下特点：</p>
<ol>
<li>每个初始节点最终都成为叶节点，且权值越小的节点到根节点的路径长度越大。</li>
<li>构造过程中共新建$n-1$个节点(双分支节点)，因此Huffman树的节点总数为$2n-1$。</li>
<li>每次构造都选择2棵树作为新节点的孩子，因此Huffman树中不存在度为1的节点。</li>
</ol>
<h1 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h1><p>在数据通信中，若对每个字符用相等长度的二进制位表示，称这种方式为<strong>固定长度编码</strong>。若允许对不同字符用不等长的二进制位表示，则这种编码方式称为<strong>可变长度编码</strong>。可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋予短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。Huffman编码是一种被广泛应用而且非常有效的数据压缩编码。</p>
<p>若没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>。对前缀编码的解码很简单，因为没有一个编码是其它编码的前缀。所以识别出第一个编码。将它翻译成源码，再对余下的编码文件重复同样的解码操作。</p>
<p>由Huffman树得到的Huffman编码是很自然的过程。首先，将每个出现的字符当作一个独立的节点，其权值为它出现的频度(或次数)，构造出对应的Huffman树。显然，所有字符节点都出现在叶节点中。我们可将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为0表示”转向左孩子“，标记为1表示”转向右孩子“。</p>
<p>因此，利用Huffman树可以设计出总长度最短的二进制前缀编码。</p>
]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-208-实现Trie前缀树</title>
    <url>/2020/06/21/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">Trie trie = <span class="built_in">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.<span class="keyword">insert</span>("apple");</span><br><span class="line">trie.<span class="keyword">search</span>("apple");   // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">search</span>("app");     // 返回 <span class="keyword">false</span></span><br><span class="line">trie.startsWith("app"); // 返回 <span class="keyword">true</span></span><br><span class="line">trie.<span class="keyword">insert</span>("app");   </span><br><span class="line">trie.<span class="keyword">search</span>("app");     // 返回 <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ul>
<li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<a id="more"></a>
<hr>
<p>其实就是构造一颗字典树。我的方法是除根节点外树中每个节点存储一个字符。采用孩子兄弟表示法。并用一个字段来表示当前字符是否可以作为单词的终结。</p>
<p>看了下那些效率比较高的方法，发现虽然我这个方法效率较低，但是可以存储任意的字符，灵活度较高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    Trie* first;</span><br><span class="line">    Trie* next;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() : val(<span class="string">'\0'</span>),first(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>),isEnd(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line">    Trie(<span class="keyword">char</span> v):first(<span class="literal">nullptr</span>),next(<span class="literal">nullptr</span>),isEnd(<span class="literal">false</span>)&#123;val = v;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.empty())&#123;</span><br><span class="line">            isEnd = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;first)&#123;</span><br><span class="line">            root = first;</span><br><span class="line">            <span class="keyword">while</span>(root-&gt;next&amp;&amp;root-&gt;val!=word[<span class="number">0</span>])root = root-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val!=word[<span class="number">0</span>])&#123;</span><br><span class="line">                root-&gt;next = <span class="keyword">new</span> Trie(word[<span class="number">0</span>]);</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;first = <span class="keyword">new</span> Trie(word[<span class="number">0</span>]);</span><br><span class="line">            root = root-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;insert(word.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.empty()&amp;&amp;isEnd)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur = <span class="keyword">this</span>-&gt;first;</span><br><span class="line">        <span class="keyword">while</span>(cur&amp;&amp;cur-&gt;val != word[<span class="number">0</span>])cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur&amp;&amp;cur-&gt;val == word[<span class="number">0</span>]&amp;&amp;cur-&gt;search(word.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix.empty())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur = <span class="keyword">this</span>-&gt;first;</span><br><span class="line">        <span class="keyword">while</span>(cur&amp;&amp;cur-&gt;val != prefix[<span class="number">0</span>])cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur&amp;&amp;cur-&gt;val == prefix[<span class="number">0</span>]&amp;&amp;cur-&gt;startsWith(prefix.substr(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-166-分数到小数</title>
    <url>/2020/06/20/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</url>
    <content><![CDATA[<p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: numerator = <span class="number">1</span>, denominator = <span class="number">2</span></span><br><span class="line">输出: <span class="string">"0.5"</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: numerator = <span class="number">2</span>, denominator = <span class="number">1</span></span><br><span class="line">输出: <span class="string">"2"</span></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">输入: numerator = <span class="number">2</span>, denominator = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"0.(6)"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>做这道题首先要了解除法的竖式运算的本质。即用分子除分母：</p>
<p>首先可以算出结果的符号是正还是负，然后将分子和分母全取绝对值，则为正整数进行运算。</p>
<ul>
<li><p>得出商和余数</p>
<ul>
<li><p>余数为0，则得到结果</p>
</li>
<li><p>余数不为0，则令余数自乘10</p>
<ol>
<li><p>第一次得到商的时候且余数不为0时除了在结果中追加商之外还要追加一个小数点。</p>
</li>
<li><p>如果余数比分母小，则循环乘10直到大于等于分母为止，乘一次10在结果上追加一个0。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>在哈希表中查看是否当前余数已经出现过，</p>
<ul>
<li>出现过则记录循环开始位置并退出竖式运算，表明此结果为循环小数。</li>
<li>没出现过则将其记录进哈希表。</li>
</ul>
</li>
<li><p>将调整过后的余数作为分子进行下一轮运算。</p>
</li>
</ul>
<p>最后如果判断是循环小数，那么在循环开始位置插入左括号，在结果末尾插入右括号。</p>
<p>但这题坑还是很多的，比如</p>
<ul>
<li>分子为0的时候不太好用一条表达式来判断结果正负，需要将分子为0的情况单独提出。</li>
<li>小数除大数的时候，余数的循环乘10容易发生上溢出。因此我直接把竖式中的数值全都调整为无符号64位整型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numerator == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">bool</span> symbol = numerator&gt;<span class="number">0</span>^denominator&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint64_t</span> up = <span class="built_in">abs</span>(numerator),down = <span class="built_in">abs</span>(denominator);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">bool</span> dot = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> loopbegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> quotient = up/down,remainder = up%down;</span><br><span class="line">            res+=to_string(quotient);</span><br><span class="line">            <span class="keyword">if</span>(!remainder)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dot)&#123;</span><br><span class="line">                res.push_back(<span class="string">'.'</span>);</span><br><span class="line">                dot = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(hash.find(remainder)!=hash.end())&#123;</span><br><span class="line">                loopbegin = hash[remainder];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hash[remainder] = res.size();</span><br><span class="line">            &#125;</span><br><span class="line">            remainder*=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span>(remainder&lt;down)&#123;</span><br><span class="line">                remainder*=<span class="number">10</span>;</span><br><span class="line">                res.push_back(<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            up = remainder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(loopbegin)&#123;</span><br><span class="line">            res.insert(loopbegin,<span class="string">"("</span>);</span><br><span class="line">            res.push_back(<span class="string">')'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> symbol?<span class="string">"-"</span>+res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>B树和B+树</title>
    <url>/2020/06/19/datastructure/B%E6%A0%91%E5%92%8CB+%E6%A0%91/</url>
    <content><![CDATA[<p>B树和B+树因为其身短体宽的特点多用于组织外存信息，以避免过多的IO开销。</p>
<a id="more"></a>
<h1 id="B树及其基本操作"><a href="#B树及其基本操作" class="headerlink" title="B树及其基本操作"></a>B树及其基本操作</h1><p>B树，又称<strong>多路平衡查找树</strong>，B树中所有孩子节点个数的最大值成为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树:</p>
<ol>
<li><p>树中每个节点至多有$m$颗子树，即最多含有$m-1$个关键字。</p>
</li>
<li><p>若根节点不是终端节点，则至少有两棵子树。</p>
</li>
<li><p>若根节点外所有非叶节点至少有$\lceil m/2\rceil$棵子树，即至少含有$\lceil m/2\rceil-1$个关键字。</p>
</li>
<li><p>所有非叶节点的结构如下：</p>
<blockquote>
<p>$n\rightarrow P_0\rightarrow K_1\rightarrow P_1\rightarrow K_2\rightarrow P_2\rightarrow…\rightarrow K_n\rightarrow P_n$</p>
</blockquote>
<ul>
<li>其中，$K_i(i=1,2,…,n)$为节点的关键字，且满足$K_1&lt;K_2&lt;…&lt;K_n$；$P_i(i=0,1,…,n)$为指向子树根节点的指针，且指针$P_{i-1}$所指子树中所有节点的关键字均小于$K_i$，$P_i$所指子树中所有节点的关键字均大于$K_i$。$n(\lceil m/2\rceil-1\leq n\leq m-1)$为节点中关键字的个数。</li>
</ul>
</li>
<li><p>所有的叶节点都出现在同一层次上，并且不带信息(可以视为外部节点或类似于折半查找判定树的查找失败节点，实际上这些节点不存在，指向这些节点的指针为空)。</p>
</li>
</ol>
<p>B树是所有节点的平衡因子均等于0的多路平衡查找树。</p>
<h2 id="B树的高度-磁盘存取次数"><a href="#B树的高度-磁盘存取次数" class="headerlink" title="B树的高度(磁盘存取次数)"></a>B树的高度(磁盘存取次数)</h2><p>B树中的大部分操作所需的磁盘存取次数与B树的高度成正比。</p>
<p>下面来分析B树在不同情况下的高度。当然，首先规定B树的高度不包括最后的不带任何信息的叶节点所处的那一层。</p>
<p>若$n\geq1$，则对任意一棵包含$n$个关键字，高度为$h$，阶数为$m$的B树：</p>
<ol>
<li><p>因为B树中每个节点最多有$m$棵子树，$m-1$个关键字，所以在一棵高度为$h$的$m$阶B树中关键字的个数应满足</p>
<script type="math/tex; mode=display">
n\leq(m-1)(1+m+m^2+...+m^{h-1})=m^h-1</script><p>因此有</p>
<script type="math/tex; mode=display">
h\geq log_m(n+1)</script></li>
<li><p>若让每个节点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大。</p>
<p>由B树的定义：第一层至少有1个节点；第二层至少有2个节点；除根节点外的每个非终端节点至少有$\lceil m/2\rceil$棵子树，则第三层至少有$2\lceil m/2\rceil$个节点…第$h+1$层至少有$2(\lceil m/2\rceil)^{h-1}$个节点，注意到第$h+1$层是不包含任何信息的叶节点。</p>
<p>对于关键字个数为$n$的B树，叶节点即查找不成功的节点为$n+1$，由此有$n+1\geq2(\lceil m/2\rceil)^{h-1}$，即$h\leq log_{\lceil m/2\rceil}((n+1)/2)+1$。</p>
<p>例如，假设一棵3阶B树共有8个关键字，则其高度范围为$2\leq h\le3.17$。</p>
</li>
</ol>
<h2 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h2><ul>
<li><p>在B树上进行查找与二叉查找树很相似，只是每个节点都是多个关键字的有序表 ，在每个节点上所作的不是两路分支决定，而是根据该节点的子树所做的多路分支决定。</p>
</li>
<li><p>B树的查找包含两个基本操作：</p>
<ol>
<li>在B树中找节点</li>
<li>在节点内找关键字。</li>
</ol>
<p>由于B树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标节点后，先将节点信息读入内存，然后在节点内采用顺序查找法或折半查找法。</p>
</li>
<li><p>在B树上查找到某个节点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找。查找到叶节点时(对应指针为空指针)，则说明树中没有对应关键字，查找失败。</p>
</li>
</ul>
<h2 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h2><p>与二叉查找树的插入操作相比，B树的插入操作要复杂的多。在二叉查找树中，仅需查找到需插入的终端节点的位置。但是在B树中找到插入的位置后，并不能简单地将其添加到终端节点中，因为此时可能会导致整棵树不再满足B树定义的要求。将关键字key插入B树的过程如下：</p>
<ol>
<li><strong>定位</strong>。利用前述的B树查找算法，找出插入该关键字的最底层中的某个非叶子节点(在B树中查找key时，会找到表示查找失败的叶节点，这样就确定了最底层非叶节点的插入位置。注意：插入位置一定是最低层中的某个非叶节点)。</li>
<li><strong>插入</strong>。在B树中，每个非失败节点的关键字个数都在区间$[\lceil m/2\rceil-1,m-1]$内。插入后的节点关键字个数小于$m$，可以直接插入；插入后检查被插入节点内关键字的个数，当插入后的节点个数大于$m-1$时，必须对节点进行分裂。</li>
</ol>
<h3 id="分裂的方法"><a href="#分裂的方法" class="headerlink" title="分裂的方法"></a>分裂的方法</h3><ul>
<li>取一个新节点，在插入key后的原节点，从中间位置$(\lceil m/2\rceil)$将其中的关键字分为两部分，左部分包含的关键字放在原节点中，右部分包含的关键字放到新节点中，中间位置$(\lceil m/2\rceil)$的节点插入原节点的父节点。</li>
<li>若此时导致其父节点的关键字个数也超过了上限，则继续进行这种分裂操作。直至这个过程传到根节点为止，进而使B树的高度增1。</li>
</ul>
<h2 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h2><p>B树中的删除操作与插入操作类似，但要稍微复杂一点，即要使得删除后的节点中的关键字个数$\geq\lceil m/2\rceil-1$，因此将涉及节点的合并问题。</p>
<p>当被删关键字$k$不在终端节点(最低层非叶节点)中时，可以用$k$的前驱(或后继)$k’$来替代$k$，然后在相应的节点中删除$k’$，关键字$k’$必定落在某个终端节点中，则<strong>转换成了被删关键字在终端节点</strong>的情形。</p>
<p>当被删关键字在终端节点(最低层非叶节点)中时，有下列三种情况：</p>
<ol>
<li><strong>直接删除关键字</strong>。若被删除关键字所在节点的关键字个数$\geq\lceil m/2\rceil$，表明删除该关键字后仍满足B树的定义，则直接删去该关键字。</li>
<li><strong>兄弟够借</strong>。若被删除关键字所在节点删除前的关键字个数$=\lceil m/2\rceil-1$，且与此节点相邻的右(或左)兄弟节点的关键字个数$\geq\lceil m/2\rceil$，则需要调整该节点、右(或左)兄弟节点及其双亲节点(父子换位法)，以达到新的平衡。</li>
<li><strong>兄弟不够借</strong>。若被删除关键字所在节点删除前的关键字个数$=\lceil m/2\rceil-1$，且此时与该节点的相邻左右兄弟节点的关键字个数均$=\lceil m/2\rceil-1$，则将关键字删除后与左(或右)兄弟节点及双亲节点中的关键字进行合并。</li>
</ol>
<p>在合并过程中，双亲节点中的关键字个数会减1。若双亲节点是根节点且关键字个数减少至0(根节点关键字个数为1时，有两棵子树)，则直接将根节点删除，合并后的新节点成为根；若双亲节点不是根节点，且关键字个数减少到$\lceil m/2\rceil-2$，则又要与它自己的兄弟节点进行调整或合并操作，并重复以上操作，直至符合B树的要求为止。</p>
<h1 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B+树的基本概念"></a>B+树的基本概念</h1><p>B+树是应数据库所需而出现的一种B树的变形树。相比较而言更适合进行遍历操作。</p>
<p>一颗m阶的B+树需满足下列条件：</p>
<ol>
<li>每个分支节点最多有m棵子树(孩子节点)。</li>
<li>非叶根节点至少有两颗子树，其他每个分支节点至少有$\lceil m/2\rceil$棵子树。</li>
<li>节点的子树个数和关键字个数相等。</li>
<li>所有叶节点包含全部关键字及指向相应记录的指针，叶节点中将关键字按大小顺序排列，并且相邻叶节点按大小顺序相互链接起来。</li>
<li>所有分支节点(可视为索引的索引)中仅包含它的各个子节点(即下一级的索引块)中关键字的最大值及指向其子节点的指针。</li>
</ol>
]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-207-课程表</title>
    <url>/2020/06/18/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。在选修某些课程之前需要一些先修课程。 例如，想要学习课程0，你需要先完成课程1，我们用一个匹配来表示他们：[0,1]。给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要完成课程 <span class="number">0</span>。所以这是可能的。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 总共有 <span class="number">2</span> 门课程。学习课程 <span class="number">1</span> 之前，你需要先完成课程 <span class="number">0</span>；并且学习课程 <span class="number">0</span> 之前，你还应先完成课程 <span class="number">1</span>。这是不可能的。</span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>：<br>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br>1 &lt;= numCourses &lt;= 10^5</p>
<a id="more"></a>
<hr>
<p>课程的先后顺序可看作一个有向图，如果可以完成所有课程的学习，那么这应该是一个有向无环图。我先用拓扑排序，然后看是否有课程没有参与排序，如果有，则无法完成所有课程。</p>
<p>拓扑排序的过程也很简单：</p>
<ul>
<li>将所有入度为0的节点入队。</li>
<li>如果队列非空<ul>
<li>每次取出一个节点，将所有以这个节点为入度的节点的入度数减1。</li>
<li>如果减1后的节点的入度数为0，那么将该节点入队。</li>
</ul>
</li>
<li>到最后如果所有的节点都入过队，那么拓扑排序成功，否则失败。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; course;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> pair:prerequisites)&#123;</span><br><span class="line">            course[pair[<span class="number">0</span>]].insert(pair[<span class="number">1</span>]);</span><br><span class="line">            ++num[pair[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;num.size();++i)</span><br><span class="line">            <span class="keyword">if</span>(!num[i])q.push(i);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            --numCourses;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:course[q.front()])</span><br><span class="line">                <span class="keyword">if</span>(!(--num[i]))q.push(i);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-231-2的幂</title>
    <url>/2020/06/16/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-231-2%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p>
<a id="more"></a>
<ul>
<li>显然2的幂次方首先是个正数。</li>
<li>其次观察它每一位的二进制，只含有一个1。去判断只含有一个1的数方法还是很多的。但我有了个很简便的方法。那就是注意到如果该数只含有一个1，那么该数减1的结果就是相同位上为0，其余位均为1。可以发现这两个数按位相与是为零的。这种情况仅发生在2的幂次整数上，因此可以作为判断法则。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span>&amp;&amp;((n<span class="number">-1</span>)&amp;n) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>语义分析器</title>
    <url>/2020/06/16/c++/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>通过语法分析得到了一颗以关键字为非叶节点，标识符和常量为叶节点的语法分析树。大部分的编译时异常都已检查完毕。而之所以在语法分析的时候需要生成一颗树，是因为树这种数据结构有着层次分明的特点，而程序在逻辑上的确就是层次分明的。因此总体上就是通过对语法分析树的遍历来确定程序的语义，并且生成中间代码(伪汇编)。</p>
<a id="more"></a>
<hr>
<h1 id="表达式树的语义分析"><a href="#表达式树的语义分析" class="headerlink" title="表达式树的语义分析"></a>表达式树的语义分析</h1><p>通过输入一个树根，将这棵树的语义的四元组向量形式输出。为方便起见，四元组内的元素依然采用之前词法分析生成的二元组。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;std::pair&lt;size_t,std::string&gt;&gt;&gt; getExpTuple(generalTreeNode* root);</span><br></pre></td></tr></table></figure></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>两个栈，一个用来在后序遍历的时候存父节点，另一个用来存计算结果。</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><h3 id="树的后序遍历"><a href="#树的后序遍历" class="headerlink" title="树的后序遍历"></a>树的后序遍历</h3><p>总体采用树的后序遍历，即按顺序遍历完所有孩子节点之后再去遍历父节点。如果树根不是个操作符，那么直接返回以这个树根作为元素的四元组。</p>
<ul>
<li>首先要注意的是，我们需要遍历的是输入这个节点作为根节点的那颗子树，但输入的这个节点是有可能有兄弟的。因此我们应该在函数的一开始对根节点进行一次拷贝，但指向兄弟节点的指针置空。在函数结束的时候再释放这个拷贝节点。</li>
<li>普通树的后序遍历较二叉树更简单一些，因为所有有兄弟的节点都有直接指向兄弟的指针，过程如下：<ul>
<li>首先先将指针指向最开始拷贝的节点。在指针非空或者节点栈非空的时候执行以下循环：<ul>
<li>如果指针非空，则当前节点入栈，并将其指向当前节点的首个孩子。</li>
<li>如果指针为空，那么弹出栈顶节点给指针，如果这个节点中的值<strong>是操作符那么访问</strong>这个节点。</li>
<li>访问结束之后指针指向当前节点的下一个兄弟节点。</li>
</ul>
</li>
<li>释放最开始拷贝节点的空间。</li>
</ul>
</li>
<li>返回得到的一个四元组向量。</li>
</ul>
<h3 id="操作符节点的访问"><a href="#操作符节点的访问" class="headerlink" title="操作符节点的访问"></a>操作符节点的访问</h3><p>在这里便是生成四元组的地方，规定算术表达式四元组的格式：<code>&lt;操作码，操作数1，操作数2，结果寄存器&gt;</code></p>
<p>如果是向取非那样的一元运算符，那么操作数2的位置可以缺省。</p>
<p>生成四元组过程如下：</p>
<ul>
<li>操作码：可以直接用树节点内的二元组。</li>
<li>操作数1：如果节点的首个孩子不是寄存器地址，那么置节点首孩子的值。否则从计算结果栈中弹出栈顶作为操作数1。</li>
<li>操作数2：如果是一元运算符，该位缺省。否则做法与操作数1的取法雷同。</li>
<li>结果寄存器：寄存器暂时以无符号整数来编号，每得到一个结果都将其入计算结果栈。</li>
</ul>
<h1 id="执行语句的语义分析"><a href="#执行语句的语义分析" class="headerlink" title="执行语句的语义分析"></a>执行语句的语义分析</h1><p>通过输入一个代码块的树根，输出这个代码块的语义分析结果(伪汇编代码)，以四元组形式表示，其中只包含基本运算指令，条件转移指令，无条件转移指令。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;std::pair&lt;size_t, std::string&gt;&gt;&gt; translator::getTuple(generalTreeNode* root);</span><br></pre></td></tr></table></figure>
<h2 id="四元组格式"><a href="#四元组格式" class="headerlink" title="四元组格式"></a>四元组格式</h2><ul>
<li>声明指令：<code>&lt;声明数据类型，声明数据格式，-，-&gt;</code></li>
<li>算数指令：<code>&lt;操作码，操作数1，操作数2，结果寄存器&gt;</code></li>
<li>条件转移指令：<code>&lt;转移地址，如果结果寄存器为真或假则转移，-，-&gt;</code></li>
<li>无条件转移指令：<code>&lt;转移地址，-，-，-&gt;</code></li>
<li>打印输出指令：<code>&lt;代表输出的操作码，-，-，-&gt;</code></li>
</ul>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>树节点栈：遍历过程中用于存放父节点。</li>
<li>循环信息栈：用于存放最近一层循环的循环信息，包括循环语句块的起始地址，循环语句块的判断语句长度，循环语句块的总长度。</li>
<li>条件转移信息栈：用于存放最近一层的条件选择语句块信息，即不符合顺序执行条件的时候的跳转地址。</li>
</ul>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>这里还用到了一个计算语句块中包含的语句数的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">translator::count_instruction</span><span class="params">(generalTreeNode* root)</span></span></span><br></pre></td></tr></table></figure>
<p>原理也很简单，就是对子树的一次遍历并条件计数。语句块中的语句条数对于计算条件转移和无条件转移的目标地址尤为重要。</p>
<h2 id="地址设定"><a href="#地址设定" class="headerlink" title="地址设定"></a>地址设定</h2><p>语义分析的过程中暂且以输出四元组的下标来表示地址。</p>
<h2 id="算法过程-1"><a href="#算法过程-1" class="headerlink" title="算法过程"></a>算法过程</h2><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>这里的遍历只需要遍历关键字节点，因为如果遇到表达式只需要调用算数表达式的语义分析即可。先序遍历的过程其实和后序遍历是一样的。只不过访问顺序不同而已。但可以确定的是所有的关键字节点将会被访问两次，在这两次访问当中都会有事情做，因此该算法的解释将以关键字节点的第一次访问和第二次访问还有生成表达式树的语义分析作区分。</p>
<h3 id="第一次访问关键字"><a href="#第一次访问关键字" class="headerlink" title="第一次访问关键字"></a>第一次访问关键字</h3><ul>
<li>如果是声明关键字(int, double, char, void)<ul>
<li>那么计算其孩子的个数得出声明数量，并生成四元组。</li>
</ul>
</li>
<li>如果是if<ul>
<li>如果右兄弟是else，那么计算其语句条数的时候要多加1，因为需要额外一个无条件转移语句来跳过这个else语句块。</li>
<li>将计算所得的条件转移地址压入条件转移信息栈中。</li>
</ul>
</li>
<li>如果是else<ul>
<li>计算出这个else最近的一个if结果为真时的无条件转移地址，并得出其四元组。</li>
</ul>
</li>
<li>如果是while<ul>
<li>计算出这个while中条件判断语句数和总语句数，连同起始地址压入循环信息栈中。</li>
<li>计算出条件判断为假时的转移地址，并压入条件转移信息栈中。</li>
</ul>
</li>
<li>如果是break<ul>
<li>意味着直接去找当前循环语句块的结束地址，而这个信息恰好存在循环信息栈的栈顶。结束地址的计算方法为循环语句块的起始地址加上总长度。最后生成无条件转移的四元组。</li>
</ul>
</li>
<li>如果是continue<ul>
<li>意味着直接去寻找当前循环语句块的条件判断语句，信息依然在循环信息栈的栈顶。计算方法是循环语句块起始地址加总长度再减去条件判断语句长度。最后生成无条件转指令。</li>
</ul>
</li>
<li>如果是print<ul>
<li>意味着下一个结果寄存器中的数据需要打印输出。因此需要打印输出标志位置1。</li>
</ul>
</li>
</ul>
<h3 id="访问到操作符"><a href="#访问到操作符" class="headerlink" title="访问到操作符"></a>访问到操作符</h3><ul>
<li>直接生成对表达式树的语义分析四元组。</li>
<li>如果条件转移信息栈非空，说明现在的表达式是置于一个if或while块中。<ul>
<li>如果是在if语句块中，条件转移地址的计算方法为语句块起始地址加上条件判断语句长度加2。并生成四元组。</li>
<li>如果是在while语句块中，条件转移地址的计算方法为语句块起始地址加上条件判断语句长度。</li>
</ul>
</li>
<li>如果当前节点还有右兄弟那么访问右兄弟，否则弹出树节点栈栈顶元素作为当前节点。</li>
</ul>
<h3 id="第二次访问关键字"><a href="#第二次访问关键字" class="headerlink" title="第二次访问关键字"></a>第二次访问关键字</h3><p>这个时候便是每次关键字节点从树节点栈中出栈的时候。</p>
<ul>
<li>如果循环节点栈非空且出栈的树节点是一个while节点时，说明此前生成的四元组序列是在一个循环当中，现在刚好结束。那么根据栈顶信息的第一个字段得出循环的起始地址，并无条件转移至起始地址，为了进行下一轮判断。并生成无条件转移四元组。</li>
<li>如果此时打印输出标志位为1，那么生成打印输出的四元组，最后将打印输出标志位置0。</li>
</ul>
<p>最后得到栈顶元素之后继续访问其右兄弟。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-219-存在重复元素II</title>
    <url>/2020/06/15/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<a id="more"></a>
<hr>
<p>用一个散列表来记录并不断更新每个不同元素距离现在最近的位置，如果发现重复元素，且查表发现距离上一个相同的元素小于给定值，则可返回真。遍历完所有数据后返回假。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.find(nums[i])!=<span class="built_in">map</span>.end()&amp;&amp;i - <span class="built_in">map</span>[nums[i]]&lt;=k)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">map</span>[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-226-翻转二叉树</title>
    <url>/2020/06/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>翻转一棵二叉树。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">输出：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>备注：</p>
<blockquote>
<p>这个问题是受到 Max Howell 的 原问题 启发的<br>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>不知道这个备注在说什么。不过二叉树简直就是为递归而生的一个数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            swap(root-&gt;left,root-&gt;right);</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-217-存在重复元素</title>
    <url>/2020/06/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<a id="more"></a>
<hr>
<p>很简单的题，实际上就是判断需要去重。对于我这种去重老手只好拿出我的unordered_set大法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(),nums.end()).size()!=nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-206-反转链表</title>
    <url>/2020/06/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>反转一个单链表。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<a id="more"></a>
<ul>
<li><p>递归法</p>
<p>递归法无非就是要找到在已经处理好一段链表时，应该怎么做。试想对下面这样一个链表进行递归操作：</p>
<script type="math/tex; mode=display">
n_1\rightarrow n_2\rightarrow n_3\rightarrow n_4\rightarrow ...\rightarrow n_k\rightarrow n_{k+1}\rightarrow n_{k+2}\rightarrow n_{k+3}\rightarrow ...\rightarrow n_m\rightarrow \varnothing</script><p>此时如果已经对$n_k$之后的链表完成了反转，而$n_k\rightarrow next=n_{k+1}$，所以应该让$n_k\rightarrow next=n_k\rightarrow next\rightarrow next$，最后令$n_k\rightarrow next=\varnothing$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> p = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代法</p>
<p>我这里用的迭代法是新增哨兵节点的头插法。每次迭代到的节点都插到链表的头部。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* H = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        H-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(head&amp;&amp;head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">            tmp-&gt;next = H-&gt;next;</span><br><span class="line">            H-&gt;next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> res = H-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> H;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-205-同构字符串</title>
    <url>/2020/06/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>给定两个字符串 s 和 t，判断它们是否是同构的。如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<a id="more"></a>
<hr>
<p>这题的难点主要是在理解题意。我也是直到看了题解才大致明白具体的规则。就是字符串s到t有着一个唯一的映射关系，而t到s也有着唯一的一个映射关系，而这两个映射关系实可以不同的。我一开始一直以为这两个映射关系可以相同，所以很久都没想出来。了解规则之后方法就很简单了。</p>
<p>用两个哈希表来记录这两个映射关系，遍历一遍发现有不符合映射关系的直接返回false即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; dict1,dict2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            dict1[s[i]] = t[i];</span><br><span class="line">            dict2[t[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dict1[s[i]]!=t[i]||dict2[t[i]]!=s[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-204-计数质数</title>
    <url>/2020/06/12/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 小于 <span class="number">10</span> 的质数一共有 <span class="number">4</span> 个, 它们是 <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> 。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>这又是一道经典题。大一学习C语言做的寻找质数的题，使用的是暴力解法。放在这里当然是不适用的，毕竟$O(n^2)$的算法超时很严重。于是就可以考虑埃拉托斯特尼筛法了。其实思想也很简单，在给定范围的数之内，将所有数都做上是质数的标记。然后从2开始，将2的倍数都标记为不是质数，然后到下一个质数，再将这个质数的倍数都标记为不是质数，以此类推，直到遍历完毕。</p>
<p>优化方案：</p>
<ul>
<li>首先我们可以发现偶数中除了2全不是质数，因此我们在遍历的时候可以从3开始并只考虑奇数，相应的步长也变为2。</li>
<li>其次内层循环中将倍数置非可以直接从遍历数值的平方项开始，因为省过的这一段在此前已经判断并置值过了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> count = n&lt;<span class="number">3</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">uint64_t</span> i = <span class="number">3</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i])&#123;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">uint64_t</span> j = i*i;j&lt;n;j+=<span class="number">2</span>*i)a[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-203-移除链表元素</title>
    <url>/2020/06/11/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>删除链表中等于给定值val的所有节点。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">6</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>, val = <span class="number">6</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>放置哨兵节点以方便处理首尾的节点。不过我很奇怪为什么大家都是这样的算法我的效率却这么低。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> H = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = H;</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;<span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = H-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> H;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-202-快乐数</title>
    <url>/2020/06/11/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<p>编写一个算法来判断一个数 n 是不是快乐数。「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">19</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">12</span> + <span class="number">92</span> = <span class="number">82</span></span><br><span class="line"><span class="number">82</span> + <span class="number">22</span> = <span class="number">68</span></span><br><span class="line"><span class="number">62</span> + <span class="number">82</span> = <span class="number">100</span></span><br><span class="line"><span class="number">12</span> + <span class="number">02</span> + <span class="number">02</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>对于这题一开始是很容易把人看懵的。因为我们似乎不知道根据题目所说的将数字的每一位取平方和会是个什么样的结果。不过根据题意我们可以对其作以下猜测，对于一个任意的数，做无限次按位平方和之后：</p>
<ul>
<li><p>会收敛为1。因为1的按位平方和永远是1。</p>
</li>
<li><p>会回到最原来的数。开始无限循环。</p>
</li>
<li><p>不会回到原来的数，可能变的无穷大。</p>
</li>
</ul>
<p>之后可以对这三种情况进行分析。结果发现第三种情况是经不起推敲的。试想，假如给出的数字是一个两位数，为了测试其极端情况，令其为99，那么$9^2+9^2=162$，这将得到一个三位数，而三位数每位取最大$9^2+9^2+9^2=243$，也才得到一个243。对于位数较多的数字也有相同的结论。</p>
<p>归根结底就是这里的平方和始终是一些一位数进行运算，这一定会有一个很低的上限。所以结果无穷大是不可能的。</p>
<p>另外，有没有可能有点类似于无理数的样子，无限出现不同的数字。那当然也是不可能的，因为上面已经认证过了，加入给出一个两位数，如果进行无穷次按位平方和运算，它的数值一定不会大于243。那么这属于有限个整数，极端情况下，把这所有的数字都经过一遍，最终还是会回到原来的数字。</p>
<p>所以结论是，经过无限次运算之后，结果有可能收敛于1，也有可能回到原来的数并无限循环。另外，假如真的会结果趋向无穷大的话，以我的理解这个问题似乎是不可解的。所以接下来问题就转化成了一个判环问题。自然是用快慢指针来解了。</p>
<ul>
<li>如果会收敛为1。那么快指针会比慢指针先到达1。</li>
<li>如果会回到原来的数，那么快慢指针迟早会相遇。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = n, fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = getNext(slow);</span><br><span class="line">            fast = getNext(getNext(fast));</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> num = to_string(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:num)</span><br><span class="line">            res+=(ch-<span class="string">'0'</span>)*(ch-<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-201-数字范围按位与</title>
    <url>/2020/06/10/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    <content><![CDATA[<p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
<a id="more"></a>
<p>最开始看这题感觉出人意料的简单，有点儿不对劲，有种超时的预感。当我用一次遍历对范围内每一个数进行按位与运算之后确实超时了。结果确实是暗藏玄机。</p>
<p>之后对这个按位与运算细细地分析了一下，当知道0和任何数量的数与都为0时，其实问题就迎刃而解了。试想，我们先将整个范围内的数按顺序垒成一沓，存在n&gt;=0，使得所有垒起来的数的前n位完全相同。那么每一位相同的情况下，进行与运算值是不会变的。那么这些垒起来的数中的后(32-n)位中，每一位必定有数在这一位是为0的。因此进行与运算的结果的后(32-n)位肯定是全为0的。</p>
<p>那么问题就转化为了在范围内的所有数内寻找它们的公共前缀，除了这个前缀之外，其余位全为0就是结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&lt;n)&#123;</span><br><span class="line">            m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            ++offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&lt;&lt;offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-200-岛屿数量</title>
    <url>/2020/06/10/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">11000</span></span><br><span class="line"><span class="number">00100</span></span><br><span class="line"><span class="number">00011</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>这题又是似曾相识。我的想法是用一个状态矩阵来记录网格中岛屿的访问情况。通过遍历一遍二维网格，每遇到一个’1’，就对其进行深度优先搜素，找出其所有连接在一起的’1’，并将它们的状态设置为已访问。令计数器加一。这样就可以数出岛屿数量了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.size()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">statement</span><span class="params">(grid.size(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].size(),<span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;grid.size();++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;grid[<span class="number">0</span>].size();++j)</span><br><span class="line">                <span class="keyword">if</span>(!statement[i][j]&amp;&amp;grid[i][j]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    dfs(grid,statement,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; statement,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        statement[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;!statement[i<span class="number">-1</span>][j]&amp;&amp;grid[i<span class="number">-1</span>][j]==<span class="string">'1'</span>)dfs(grid,statement,i<span class="number">-1</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;grid[<span class="number">0</span>].size()<span class="number">-1</span>&amp;&amp;!statement[i][j+<span class="number">1</span>]&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="string">'1'</span>)dfs(grid,statement,i,j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;grid.size()<span class="number">-1</span>&amp;&amp;!statement[i+<span class="number">1</span>][j]&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="string">'1'</span>)dfs(grid,statement,i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;!statement[i][j<span class="number">-1</span>]&amp;&amp;grid[i][j<span class="number">-1</span>]==<span class="string">'1'</span>)dfs(grid,statement,i,j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-199-二叉树的右视图</title>
    <url>/2020/06/10/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;---</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;---</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>方法是利用队列对二叉树进行层序遍历，保留每一层最后一个节点。取得其值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">int</span> last_val = root-&gt;val, last_floor = <span class="number">0</span>;</span><br><span class="line">        que.push(make_pair(root,last_floor));</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            pair&lt;TreeNode*,<span class="keyword">int</span>&gt; p = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            <span class="keyword">if</span>(p.first)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.first-&gt;left)que.push(make_pair(p.first-&gt;left,p.second+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(p.first-&gt;right)que.push(make_pair(p.first-&gt;right,p.second+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(p.second!=last_floor)res.push_back(last_val);</span><br><span class="line">                last_val = p.first-&gt;val;</span><br><span class="line">                last_floor = p.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(last_val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-198-打家劫舍</title>
    <url>/2020/06/08/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">1</span>) ，然后偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">3</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>这题不妨将自己代入到这个环境中。假设此前已经经过了n间房屋，现在决定要不要偷第n+1间房屋。</p>
<ul>
<li>这个时候当然要权衡，到第n-1间房截止所偷的钱与第n+1间房的钱的总和是否能大于偷到第n间房所偷到的钱。如果要多于，那么经过第n+1间房所获得的最大总价值就是经过第n-1间房的总价值加上这间房的价值，否则依然还是经过第n间房所获得的总价值，即第n+1间房不能偷。</li>
</ul>
<p>本质上还是动态规划，但状态方程中的每一步结果都只取决于当前项和前两项的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> value:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = res;</span><br><span class="line">            res = max(last + value,res);</span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-191-位1的个数</title>
    <url>/2020/06/07/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p>
<p>示例 :</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">00000000000000000000000000001011</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：输入的二进制串 <span class="number">00000000000000000000000000001011</span> 中，共有三位为 '<span class="number">1</span>'。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>循环右移，每次判断最后一位是不是1，是则计数器加1。判断方法自然是和1相与了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res+=(<span class="number">1</span>&amp;n);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-190-颠倒二进制位</title>
    <url>/2020/06/07/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">10111111111111111111111111111111</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">     因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10111111111111111111111111111111</span> 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<a id="more"></a>
<hr>
<p>考虑要反转该数的二进制，那么就从这个无符号整数的高位开始往低位遍历，依次记录得到的位。具体方式为：</p>
<ul>
<li>将原数右移若干位，将其与1相与取得该位是0还是1。如果是1的话那么应该将1右移若干位的结果加到答案中。</li>
</ul>
<p>其实在草纸上比划一下过程就很容易想到了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">            res += (<span class="number">1</span>&amp;(n&gt;&gt;i))&lt;&lt;(<span class="number">31</span>-i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-189-旋转数组</title>
    <url>/2020/06/05/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>通过观察可以发现，旋转之后的结果与原数组相比，就是以数组首部加步长为分割线，对数组的两部分分别进行翻转。最后再对整个数组进行翻转。为省时间用了c++标准库中的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*auto mid = nums.rbegin() + k%nums.size();</span></span><br><span class="line"><span class="comment">        reverse(nums.rbegin(),mid);</span></span><br><span class="line"><span class="comment">        reverse(mid,nums.rend());</span></span><br><span class="line"><span class="comment">        reverse(nums.begin(),nums.end());*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::rotate(nums.rbegin(),nums.rbegin()+k%nums.size(),nums.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-187-重复的DNA序列</title>
    <url>/2020/06/05/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：<span class="attr">s</span> = <span class="string">"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span></span><br><span class="line">输出：[<span class="string">"AAAAACCCCC"</span>, <span class="string">"CCCCCAAAAA"</span>]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>我这个算法算是朴素查找算法。将每个检索到的字符串对比哈希表，如果没有则插入哈希表中，如果有则插入结果集中。最后做一次去重即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; remove_multiple;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">10</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">auto</span> left = s.begin(), right = left + <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; table;</span><br><span class="line">        <span class="keyword">auto</span> checkAndInsert = [&amp;](<span class="keyword">const</span> <span class="built_in">string</span>&amp; tmp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(table.find(tmp)!=table.end())remove_multiple.insert(tmp);</span><br><span class="line">            <span class="keyword">else</span> table.insert(tmp);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">while</span>(right!=s.end())&#123;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(left++,right++)</span></span>;</span><br><span class="line">            checkAndInsert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(left,right)</span></span>;</span><br><span class="line">        checkAndInsert(tmp);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">res</span><span class="params">(remove_multiple.begin(),remove_multiple.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>语法分析器</title>
    <url>/2020/06/03/c++/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>词法分析过后得到的是一串二元组序列，并且这些序列都是合法的关键字，分隔符，运算符，标识符，常数。语法分析的目的是将这个线性的序列根据语法逻辑关系建立一颗树，以便于后序的代码分析。总体是采用自上而下的LL(1)分析法。(其实没怎么好好学习编译原理理论课，编译器写到目前还是主要靠自己对数据结构的理解，不过自己设计的文法毕竟简单，也挺容易做的)</p>
<a id="more"></a>
<hr>
<h1 id="生成表达式树"><a href="#生成表达式树" class="headerlink" title="生成表达式树"></a>生成表达式树</h1><ul>
<li><p>表达式是程序语句中重要的组成部分。而表达式是由各种标识符，常数，以及运算符组成的。在我设计的文法中，一元运算符只有逻辑非(!)运算，其它所有的运算符都是二元的，换句话说这些二元运算符一个要配对两个标识符或常数。</p>
</li>
<li><p>在脑子中形成了基本的表达式组成后，下一步需要考虑的是各种运算符的优先级，和括号的处理。因为在中缀表达式中优先级的差异会导致运算顺序的不同。</p>
</li>
</ul>
<h2 id="树的结构"><a href="#树的结构" class="headerlink" title="树的结构"></a>树的结构</h2><p>这里表达式中的操作符最多是二元的，因此<strong>二叉树</strong>可以完全满足要求。</p>
<p>但写完算法之后才发现后面的对执行语句的建树，二叉树是肯定满足不了要求的。因此写了一个一般树的基类，还有一个二叉树继承域这个一般树。因此就算得到了一个二叉树节点，也可以将其强制转化为一般树节点。一般树就是采用普通的兄弟表示法，两个指针分别指向其节点的第一个孩子和它的下一个兄弟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">generalTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	generalTreeNode(<span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; val);</span><br><span class="line">	generalTreeNode();</span><br><span class="line">	~generalTreeNode() &#123;&#125;;</span><br><span class="line">	<span class="comment">//std::string val;</span></span><br><span class="line">	<span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; val;</span><br><span class="line">	generalTreeNode* first_son;</span><br><span class="line">	generalTreeNode* next_bro;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span><span class="keyword">public</span> generalTreeNode</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeNode(<span class="built_in">std</span>::pair&lt;<span class="keyword">size_t</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; val);</span><br><span class="line">	TreeNode();</span><br><span class="line">	~TreeNode() &#123;&#125;;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="规定运算符优先级"><a href="#规定运算符优先级" class="headerlink" title="规定运算符优先级"></a>规定运算符优先级</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">种别码</th>
<th style="text-align:center">运算符</th>
<th style="text-align:center">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">35</td>
<td style="text-align:center">!</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center">*</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">/</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td style="text-align:center">%</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center">+</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">-</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center">==</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">!=</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td style="text-align:center">&#124;</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td style="text-align:center">&#124;&#124;</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td style="text-align:center">=</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>将所有运算符的优先级信息存储在哈希表中：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span>,<span class="keyword">size_t</span>&gt; priority_table&#123;</span><br><span class="line">		&#123;<span class="number">35</span>,<span class="number">0</span>&#125;,&#123;<span class="number">24</span>,<span class="number">1</span>&#125;,&#123;<span class="number">25</span>,<span class="number">1</span>&#125;,&#123;<span class="number">38</span>,<span class="number">1</span>&#125;,&#123;<span class="number">22</span>,<span class="number">2</span>&#125;,&#123;<span class="number">23</span>,<span class="number">2</span>&#125;,&#123;<span class="number">26</span>,<span class="number">3</span>&#125;,&#123;<span class="number">27</span>,<span class="number">3</span>&#125;,&#123;<span class="number">29</span>,<span class="number">3</span>&#125;,&#123;<span class="number">30</span>,<span class="number">3</span>&#125;,&#123;<span class="number">28</span>,<span class="number">4</span>&#125;,&#123;<span class="number">31</span>,<span class="number">4</span>&#125;,</span><br><span class="line">		&#123;<span class="number">33</span>,<span class="number">5</span>&#125;,&#123;<span class="number">34</span>,<span class="number">6</span>&#125;,&#123;<span class="number">36</span>,<span class="number">7</span>&#125;,&#123;<span class="number">37</span>,<span class="number">8</span>&#125;,&#123;<span class="number">32</span>,<span class="number">9</span>&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>优先级判断函数：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">generic::priority</span><span class="params">(<span class="keyword">size_t</span> a, <span class="keyword">size_t</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//a的优先级比b高 返回真</span></span><br><span class="line">	<span class="keyword">return</span> priority_table.at(a) &lt; priority_table.at(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成算法"><a href="#生成算法" class="headerlink" title="生成算法"></a>生成算法</h2><p>函数输入：需要生成表达式树的范围，以之前使用的双向链表的迭代器对象来指定，原则是左闭右开。</p>
<p>函数输出：一颗二叉树。</p>
<p>数据结构解释：主要采用两个<strong>栈</strong>，一个是表达式根节点栈，一个是运算符栈。由于中缀表达式不同于前缀和后缀表达式可以顺序读取顺序生成表达式树。因为运算符必须作为非叶节点，二元运算符的两个操作数又分别在其前后，所以同时记录前后的状态是不可避免的。</p>
<p>算法思路：</p>
<ul>
<li>遍历函数参数给出的迭代器所表示的二元组表示的符号范围。<ol>
<li>如果当前遇到一个<strong>操作符</strong>。<ol>
<li>如果操<strong>作符栈非空</strong>且<strong>栈顶元素不为左括号</strong>。<ol>
<li>如果栈顶元素为<strong>逻辑非</strong>运算符，那么从表达式栈中弹出一个表达式节点，新建一个以逻辑非操作符为根节点，以栈顶表达式树为左子树的树。再将这个新生成的树根节点压入表达式栈。</li>
<li>如果当前遇到的操作符的<strong>优先级小于或等于</strong>操作符栈栈顶的运算符，那么将操作符栈栈顶的运算符弹出，并将其作为根节点，从表达式栈中弹出两颗表达式树作为其左右子树。最后将这颗新建的树压入表达式栈。</li>
</ol>
</li>
<li>最后无论如何将当前遇到的运算符压入运算符栈中。</li>
</ol>
</li>
<li>如果当前遇到了一个<strong>左括号</strong>，直接将其压入运算符栈中。</li>
<li>如果当前遇到了一个<strong>右括号</strong>。依次从运算符栈中弹出运算符，直到将一个左括号弹出为止。<ul>
<li>每弹出一个运算符，将执行与之前相似的操作。如果是逻辑非则从表达式栈中取一个表达式重新组成树，再压入栈中，如果不是逻辑非则弹出两个表达式组成新树后压入一个表达式。</li>
</ul>
</li>
<li>如果当前遇到一个<strong>标识符或常数</strong>。直接将其<strong>作为一个树节点</strong>压入表达式栈中。</li>
</ol>
</li>
<li>扫描完一遍二元组序列后，如果操作符栈<strong>非空</strong>。那么进行之前遇到右括号的操作，但是要一直进行下去，直到操作符栈栈空为止。</li>
<li>正常情况下函数执行结束之后表达式栈中只剩下一个元素，而这个元素就是我们想得到的表达式树的根节点。</li>
</ul>
<p>注：表达式树节点中存的值为单词对应的种别码。如果是标识符，常数，常字符串则保存它们本身。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在这个算法中，一般来说如果输入的表达式不符合规则，体现在程序运行中将会常常出现栈空的时候访问栈顶。具体处理如下：</p>
<ul>
<li>在运算符栈中弹出运算符和表达式栈中弹出一个或两个表达式栈的lambda表达式操作之前判断栈是否为空。为空则抛出异常，终止编译程序。一般在这里出现栈空的原因是<strong>缺少左括号或运算符和表达式个数不匹配以及顺序错误</strong>。</li>
<li>在遇到右括号后的循环建树操作中也可能出现栈空却访问栈顶的情况，这里也要抛出异常终止程序。原因一般也是<strong>缺少左括号或运算符和表达式个数不匹配以及顺序错误</strong>。</li>
<li>在遇到<strong>非法字符</strong>的时候自然也要抛出异常。</li>
<li>在最后对非空的运算符栈的出栈建树的过程中，如果遇到了左括号，那么也需要抛出异常，因为这是一个<strong>没有右括号与之匹配的左括号</strong>。算法中一旦遇到了一个右括号是要立即与一个最近的左括号(栈弹出的第一个左括号)进行处理的，这也是栈的妙用了。</li>
</ul>
<h1 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h1><h2 id="生成算法-1"><a href="#生成算法-1" class="headerlink" title="生成算法"></a>生成算法</h2><p>函数输入：一个存储若干个二元组链表的首尾迭代器。</p>
<p>函数输出：一颗多叉树。</p>
<p>数据结构解释：算法总体用的是迭代的方法。用到了两个<strong>栈</strong>：</p>
<ul>
<li>多叉树节点栈。函数中所有的树节点插入操作均为这个栈的栈顶元素。</li>
<li>括号匹配栈。由于括号的配对与语法一一相关，用一个栈来存储括号的配对信息，既能发现语法错误，又可以防止编译程序往错误的方向进行下去。</li>
</ul>
<p>算法思路：</p>
<ul>
<li>遍历整个序列：<ol>
<li>如果遇到一个<strong>关键字</strong>。<ol>
<li>将其作为一个树的节点，<strong>接入多叉树</strong>节点栈的栈顶节点，作为其的孩子。</li>
<li>如果该关键字为<strong>if，while，print</strong>，这三个关键字后一定要接一对圆括号，括号内是表达式。<strong>确定表达式的起始范围</strong>后，调用生成表达式树的那个函数，将其多叉树节点栈的栈顶节点，作为其的孩子。</li>
</ol>
</li>
<li>如果遇到一个<strong>左括号</strong>，包括’[‘，’(‘，’{‘。将其入括号匹配栈。</li>
<li>如果遇到一个<strong>右括号</strong>，和括号栈栈顶元素进行配对并出栈。如果遇到的是’}’，那么多叉树节点栈的栈顶元素出栈。</li>
<li>如果遇到一个<strong>标识符</strong>，说明接下来是一个<strong>表达式</strong>。为了保证出栈入栈匹配而不出现错误，如果这个表达式是一个独立的语句，需要为此增加一个节点为这个表达式充当“关键字”的作用，将这个<strong>辅助节点</strong>入多叉树栈。将这个表达式生成树连接在这个“关键字”节点上。</li>
<li>如果遇到<strong>分号</strong>，意味着语句结束，也将多叉树节点栈的栈顶元素出栈。</li>
<li>如果遇到除逗号以外的单词或符号，则可认为是非法字符，直接报错。</li>
</ol>
</li>
<li>遍历结束之后再检查一下括号匹配栈是否为空，如果非空则说明缺少右括号。</li>
</ul>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li>处理关键字的时候，如果多叉树栈空了，这是非法的，意味着有过多的右括号或者分号导致的出栈操作。因此抛出<strong>分隔符错误的异常</strong>。</li>
<li>处理if，while，print关键字的时候<ul>
<li>如果后面没检测到圆括号，则是<strong>语法错误</strong>。</li>
<li>如果确定表达式范围所引起的迭代器访问最后一个末尾迭代器，则是因为<strong>缺少分隔符</strong>。</li>
</ul>
</li>
<li>处理右括号的时候如果与括号栈栈顶不匹配会抛出<strong>缺少左括号的异常</strong>。</li>
<li>处理标识符时如果检测到表达式没有一个正确的分号结尾，体现在程序运行上就是出现表达式中的非法字符或者迭代器访问末尾迭代器。这时抛出<strong>缺少分号的异常</strong>。</li>
<li>最后是遍历完成之后检查括号栈的情况，非空则抛出<strong>缺少右括号的异常</strong>。</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>词法分析器</title>
    <url>/2020/06/01/c++/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<p>设计内容：处理一个简单的c语言源程序，过滤掉多余的符号，注释。判断源程序中单词的合法性。分解出正确的单词，以二元组的形式输出。</p>
<a id="more"></a>
<hr>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><ul>
<li>这一步的主要工作就是<strong>将源代码中的单行注释和多行注释以及多余的换行和缩进删除</strong>。</li>
<li>算法思路是通过一次扫描，检查当前字符以及下一个字符的状态并记录，在合适的情况下用<code>std::string &amp;std::string::erase(size_t _Off,size_t _Count)</code>进行对字符串的删除操作。</li>
</ul>
<h1 id="自定义单词集"><a href="#自定义单词集" class="headerlink" title="自定义单词集"></a>自定义单词集</h1><ul>
<li>为了规范输出格式，下面将源程序中可能出现的关键字，分隔符，运算符，标识符，数字进行编号。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">单词</th>
<th style="text-align:center">种别码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">if</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">else</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">while</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">print</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">;</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">,</td>
<td style="text-align:center">13</td>
</tr>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">“</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">{</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">}</td>
<td style="text-align:center">17</td>
</tr>
<tr>
<td style="text-align:center">[</td>
<td style="text-align:center">18</td>
</tr>
<tr>
<td style="text-align:center">]</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td style="text-align:center">(</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">)</td>
<td style="text-align:center">21</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">22</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">23</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">24</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">27</td>
</tr>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">28</td>
</tr>
<tr>
<td style="text-align:center">>=</td>
<td style="text-align:center">29</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">30</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">31</td>
</tr>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">33</td>
</tr>
<tr>
<td style="text-align:center">&#124;</td>
<td style="text-align:center">34</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">35</td>
</tr>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">36</td>
</tr>
<tr>
<td style="text-align:center">&#124;&#124;</td>
<td style="text-align:center">37</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">38</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">标识符</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">数字</td>
<td style="text-align:center">101</td>
</tr>
<tr>
<td style="text-align:center">字符串常量</td>
<td style="text-align:center">102</td>
</tr>
<tr>
<td style="text-align:center">赋值表达式</td>
<td style="text-align:center">103</td>
</tr>
<tr>
<td style="text-align:center">数组</td>
<td style="text-align:center">104</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>将这个表定义在一个哈希表中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; sym_table &#123;</span><br><span class="line">		&#123;<span class="string">"int"</span>,<span class="number">1</span>&#125;,&#123;<span class="string">"char"</span>,<span class="number">2</span>&#125;,&#123;<span class="string">"double"</span>,<span class="number">3</span>&#125;,&#123;<span class="string">"void"</span>,<span class="number">4</span>&#125;,&#123;<span class="string">"return"</span>,<span class="number">5</span>&#125;,&#123;<span class="string">"if"</span>,<span class="number">6</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"else"</span>,<span class="number">7</span>&#125;,&#123;<span class="string">"while"</span>,<span class="number">8</span>&#125;,&#123;<span class="string">"break"</span>,<span class="number">9</span>&#125;,&#123;<span class="string">"continue"</span>,<span class="number">10</span>&#125;,&#123;<span class="string">"print"</span>,<span class="number">11</span>&#125;,</span><br><span class="line">		&#123;<span class="string">";"</span>,<span class="number">12</span>&#125;,&#123;<span class="string">","</span>,<span class="number">13</span>&#125;,&#123;<span class="string">"'"</span>,<span class="number">14</span>&#125;,&#123;<span class="string">"\""</span>,<span class="number">15</span>&#125;, &#123;<span class="string">"&#123;"</span>,<span class="number">16</span>&#125;,&#123;<span class="string">"&#125;"</span>,<span class="number">17</span>&#125;,&#123;<span class="string">"["</span>,<span class="number">18</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"]"</span>,<span class="number">19</span>&#125;,&#123;<span class="string">"("</span>,<span class="number">20</span>&#125;,&#123;<span class="string">")"</span>,<span class="number">21</span>&#125;,&#123;<span class="string">"+"</span>,<span class="number">22</span>&#125;,&#123;<span class="string">"-"</span>,<span class="number">23</span>&#125;,&#123;<span class="string">"*"</span>,<span class="number">24</span>&#125;,&#123;<span class="string">"/"</span>,<span class="number">25</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"&gt;"</span>,<span class="number">26</span>&#125;,&#123;<span class="string">"&lt;"</span>,<span class="number">27</span>&#125;,&#123;<span class="string">"=="</span>,<span class="number">28</span>&#125;,&#123;<span class="string">"&gt;="</span>,<span class="number">29</span>&#125;,&#123;<span class="string">"&lt;="</span>,<span class="number">30</span>&#125;,&#123;<span class="string">"!="</span>,<span class="number">31</span>&#125;,&#123;<span class="string">"="</span>,<span class="number">32</span>&#125;,</span><br><span class="line">		&#123;<span class="string">"&amp;"</span>,<span class="number">33</span>&#125;,&#123;<span class="string">"|"</span>,<span class="number">34</span>&#125;,&#123;<span class="string">"!"</span>,<span class="number">35</span>&#125;,&#123;<span class="string">"&amp;&amp;"</span>,<span class="number">36</span>&#125;,&#123;<span class="string">"||"</span>,<span class="number">37</span>&#125;,&#123;<span class="string">"%"</span>,<span class="number">38</span>&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="单词的识别"><a href="#单词的识别" class="headerlink" title="单词的识别"></a>单词的识别</h1><p>主要用到的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">isKeyWord</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">isSeparater</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isVariaty</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="识别关键字"><a href="#识别关键字" class="headerlink" title="识别关键字"></a>识别关键字</h2><ul>
<li>输入一个单词，如果是关键字则会输出其对应的种别码。否则输出0。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">scanner::isKeyWord</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="识别分隔符"><a href="#识别分隔符" class="headerlink" title="识别分隔符"></a>识别分隔符</h2><ul>
<li>输入一个单词，如果是分隔符则会输出其对应的种别码。否则输出0。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">scanner::isSeparater</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="识别运算符"><a href="#识别运算符" class="headerlink" title="识别运算符"></a>识别运算符</h2><ul>
<li>输入一个单词，如果是运算符符则会输出其对应的种别码。否则输出0。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">scanner::isOperator</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="识别数字"><a href="#识别数字" class="headerlink" title="识别数字"></a>识别数字</h2><ul>
<li>输入一个单词，如果是数字则返回真。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanner::isNumber</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="识别标识符"><a href="#识别标识符" class="headerlink" title="识别标识符"></a>识别标识符</h2><ul>
<li>输入一个单词，如果是标识符则返回真。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scanner::isVariaty</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>输入：预处理后的源代码字符串</p>
<p>输出：一个<strong>链表</strong>，每个链表节点是一个二元组，即词法分析的结果。</p>
<p>数据结构的解释：整个词法分析操作分为两次遍历，第一次是将原代码串中的所有合法字符识别出来并存储在顺序链表中，考虑到有一些运算符实际上包含了两个ASCII字符，因此第二次需要遍历的是第一次遍历得到的链表，进行节点的合并操作。这时候就体现链表的常数时间的增删操作了。唯一不方便的是list这个容器的迭代器只支持自增自减运算，而无法随机访问。虽然其实可以把这两次遍历整合到一次遍历中，而且要是整合到一次遍历中的话可以用动态数组来存。但一开始只想着解耦，结果解过头了。不过现在这样可读性也不错，也易拓展，以后如果想加入什么新的符号也挺方便的。</p>
<p>算法步骤：</p>
<ul>
<li>遍历源代码字符串<ul>
<li>异常处理：若扫描到的字符<strong>非ASCII字符</strong>，那么将异常抛出，在控制台显示错误提示。</li>
<li>如果字符<strong>不是空格</strong><ol>
<li>如果字符是<strong>分隔符或操作符</strong>，将缓冲区内的单词进行关键词或标识符或数字的检测，然后将缓冲区内单词检测结果接入链表，最后将当前字符检测结果接入链表。</li>
<li>否则将字符压入缓冲区。</li>
</ol>
</li>
<li>如果字符<strong>是空格</strong>，将缓冲区内单词进行关键词或标识符或数字的检测，如果是正确单词，则接入链表。</li>
</ul>
</li>
<li>遍历刚才得到的链表，如果<strong>遇到连续的运算符</strong>，则考虑是否将这两个链表节点合并。如果出现<strong>单双引号</strong>，那么将中间的字符串作为字符串常量，将它们合并。如果遇到<strong>按位与或按位或</strong>需要判断是否能够与下一个字符组成逻辑与或逻辑或。如果遇到<strong>方括号对</strong>则将其附近的有关符号并入到一个数组变量二元组里。</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-145-二叉树的后序遍历</title>
    <url>/2020/06/01/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>给定一个二叉树，返回它的后序遍历。</p>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<a id="more"></a>
<hr>
<p>与前序和中序不同的是，对于一个根节点，我们可能需要访问两次，而第一次是为了通过它找到右孩子，第二次才是为了访问。因此需要用一个标记序列来记录每个节点的访问情况。以此为基础进行左右根顺序的访问。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;pair&lt;TreeNode*,<span class="keyword">bool</span>&gt;&gt; sta;</span><br><span class="line">        <span class="function">TreeNode* <span class="title">p</span><span class="params">(root)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(p||!sta.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p)&#123;</span><br><span class="line">                sta.push(make_pair(p,<span class="literal">false</span>));</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pair&lt;TreeNode*,<span class="keyword">bool</span>&gt; tmp(sta.top());</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp.second)res.push_back(tmp.first-&gt;val);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sta.push(make_pair(tmp.first,<span class="literal">true</span>)); </span><br><span class="line">                    p = tmp.first-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>request和response对象</title>
    <url>/2020/05/29/java/request%E5%92%8Cresponse%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="request和response对象的原理"><a href="#request和response对象的原理" class="headerlink" title="request和response对象的原理"></a>request和response对象的原理</h1><ul>
<li>request和response对象是由服务器创建的，被程序员使用。</li>
<li>request对象是用来获取请求消息的，response对象是用来设置响应消息的。</li>
</ul>
<p>浏览器向服务器发送请求消息</p>
<ol>
<li>tomcat服务器会根据请求url中的资源路径，创建对应的ServletDemo的对象。</li>
<li>tomcat服务器，会创建request和response对象，request对象中封装请求消息数据。</li>
<li>tomcat将request和response两个对象传递给service方法，并且调用service方法。</li>
<li>程序员可以通过request对象获取请求数据消息，通过response对象设置响应消息数据。</li>
</ol>
<p>服务器向浏览器发送响应消息</p>
<ol>
<li>服务器再给浏览器做出响应之前，会从response对象中拿程序员设置的响应消息数据。</li>
</ol>
<a id="more"></a>
<h1 id="request对象继承体系结构"><a href="#request对象继承体系结构" class="headerlink" title="request对象继承体系结构"></a>request对象继承体系结构</h1><ul>
<li>ServletRequest — 接口</li>
<li>HttpServletRequest — ServletRequest的子接口</li>
<li>org.apache.catalina.connector.RequestFacade — 类(tomcat) — 实现了HttpServletRequest接口</li>
</ul>
<h1 id="request功能"><a href="#request功能" class="headerlink" title="request功能"></a>request功能</h1><h2 id="获取请求消息数据"><a href="#获取请求消息数据" class="headerlink" title="获取请求消息数据"></a>获取请求消息数据</h2><ol>
<li>获取请求行数据<ul>
<li>获取请求方式：<code>String getMethod()</code></li>
<li><strong>获取虚拟目录</strong>：<code>String getContextPath()</code></li>
<li>获取Servlet路径：<code>String getServletPath()</code></li>
<li>获取GET方式请求参数：<code>String getQueryString()</code></li>
<li><strong>获取请求URI</strong>：<code>String getRequestURI()</code>,<code>StringBuffer getRequestURL()</code></li>
<li>获取协议及版本：<code>String getProtocol</code></li>
<li>获取客户机的IP地址：<code>String getRemoteAddr()</code></li>
</ul>
</li>
<li>获取请求头数据<ul>
<li><strong>通过请求头的名称获取请求头的值</strong>：<code>String getHeader(String name)</code></li>
<li>获取所有请求头名称：<code>Enumeration&lt;String&gt; getHeaderNames()</code></li>
</ul>
</li>
<li>获取请求体数据<ul>
<li>只有POST请求方式才有请求体，在请求体中封装了POST请求的请求参数</li>
<li>步骤：<ol>
<li>获取流对象<ul>
<li>获取字符输入流，只能操作字符数据：<code>BufferReader getReader()</code></li>
<li>获取字节输入流，可以操作所有类型数据：<code>ServletInputStream getInputStream()</code></li>
</ul>
</li>
<li>再从流对象中读数据</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="其它功能"><a href="#其它功能" class="headerlink" title="其它功能"></a>其它功能</h2><ol>
<li><p>获取请求参数通用方式</p>
<ol>
<li>根据参数名称获取参数值：<code>String getParameter(String name)</code></li>
<li>根据参数名称获取参数值的数组(多用于复选框)：<code>String[] getParameterValues(String name)</code></li>
<li>获取所有请求的参数名称：<code>Enumeration&lt;String&gt; getParameterNames()</code></li>
<li>获取所有参数的Map集合：<code>Map&lt;String,String[]&gt; getParameterMap()</code></li>
<li>中文乱码问题：tomcat 8 已经解决了GET方式的乱码问题。如果采用POST方式，可以在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></li>
</ol>
</li>
<li><p>请求转发(一种在服务器内部的资源跳转方式，浏览器路径不会发生变化，只能转发到当前服务器内部资源中，转发是一次请求)</p>
<ol>
<li>通过request对象获取请求转发器对象：<code>RequestDispatcher getRequestDispatcher(String path)</code></li>
<li>使用RequestDispatcher对象来进行转发：<code>forward(ServletRequest request, ServletResponse response)</code></li>
</ol>
</li>
<li><p>共享数据</p>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li>
<li>方法：<ol>
<li>存储数据：<code>setAttribute(String name, Object obj)</code></li>
<li>通过键获取值：<code>Object getAttribute(String name)</code></li>
<li>通过键移除键值对：<code>void removeAttribute(String name)</code></li>
</ol>
</li>
</ul>
</li>
<li><p>获取ServletContext</p>
<ol>
<li>ServletContext getServletContext()</li>
</ol>
</li>
</ol>
<h1 id="response功能"><a href="#response功能" class="headerlink" title="response功能"></a>response功能</h1><h2 id="设置响应消息"><a href="#设置响应消息" class="headerlink" title="设置响应消息"></a>设置响应消息</h2><ol>
<li>设置响应行<ol>
<li>格式：HTTP/1.1 200 ok</li>
<li>设置状态码：<code>setStatus(int sc)</code></li>
</ol>
</li>
<li>设置响应头：<code>setHeader(String name, String value)</code></li>
<li>设置响应体：<ol>
<li>获取输出流<ul>
<li>字符输出流：<code>PrintWriter getWriter()</code></li>
<li>字节输出流：<code>ServletOutputStream getOutputStream()</code></li>
</ul>
</li>
<li>使用输出流，将数据输出到浏览器</li>
</ol>
</li>
</ol>
<h1 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>代表整个web应用，可以和程序的容器(服务器)来通信</li>
</ul>
<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><ol>
<li>通过request对象获取：<code>request.getServletContext();</code></li>
<li>通过HttpServlet获取：<code>this.getServletConetext();</code></li>
</ol>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li><p>获取MIME类型：</p>
<ul>
<li>MIME类型：在互联网通信过程中定义的一种文件数据类型</li>
<li>格式：大类型/小类型    text/html    image/jpeg</li>
<li>获取：<code>String getMimeType(String file)</code></li>
</ul>
</li>
<li><p>域对象：共享数据</p>
<ol>
<li><code>setAtrribute(String name,Object value)</code></li>
<li><code>getAttribute(String name)</code></li>
<li><code>removeAttribute(String name)</code></li>
</ol>
<ul>
<li>ServletContext对象范围：所有用户所有请求的数据</li>
</ul>
</li>
<li><p>获取文件的真实(服务器)路径：<code>String getRealPath(String path)</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/05/29/java/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="Hyper-Text-Transfer-Protocol"><a href="#Hyper-Text-Transfer-Protocol" class="headerlink" title="Hyper Text Transfer Protocol"></a>Hyper Text Transfer Protocol</h1><ul>
<li><p>超文本传输协议，定义了客户端和服务器端通信时发送数据的格式。</p>
</li>
<li><p>特点：</p>
<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号：80</li>
<li>基于请求/响应模型的：一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
</li>
<li>历史版本：<ul>
<li>1.0：每一次请求响应都会建立新的连接</li>
<li>1.1：复用连接</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h1 id="请求消息数据格式"><a href="#请求消息数据格式" class="headerlink" title="请求消息数据格式"></a>请求消息数据格式</h1><ul>
<li>客户端浏览器告诉服务器一些信息</li>
</ul>
<h2 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h2><blockquote>
<p>请求方式    请求url    请求协议/版本</p>
</blockquote>
<ul>
<li><p>请求方式</p>
<ul>
<li><p>HTTP协议有7种请求方式，常用的有两种</p>
<ul>
<li><p>GET:</p>
<ol>
<li>请求参数在请求行中，在url后</li>
<li>请求的url长度有限制</li>
<li>不太安全POST:</li>
</ol>
</li>
<li><p>POST:</p>
<ol>
<li>请求参数在请求体中</li>
<li>请求的url长度没有限制</li>
<li>相对安全</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><blockquote>
<p>请求头名称：请求头值</p>
</blockquote>
<ul>
<li><p>常见的请求头：</p>
<ol>
<li>Host: 请求的主机</li>
<li>User-Agent: 浏览器告诉服务器使用的浏览器版本信息<ul>
<li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li>
</ul>
</li>
<li>Accept: 浏览器可接受的响应格式</li>
<li>Accept-Language: 浏览器可支持的语言环境</li>
<li>Accept-Encoding: 浏览器支持的编码类型</li>
<li>Referer: <ul>
<li>告诉服务器，当前请求从哪里来(链接)<ul>
<li>作用：<ol>
<li>防盗链</li>
<li>统计工作</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>Connection: 连接是否被复用<h2 id="请求空行"><a href="#请求空行" class="headerlink" title="请求空行"></a>请求空行</h2></li>
</ol>
</li>
<li><p>空行，就是用于分割POST请求头和请求体的。</p>
</li>
</ul>
<h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><ul>
<li>封装POST请求消息的请求参数(GET请求没有请求体)</li>
</ul>
<h1 id="响应消息数据格式"><a href="#响应消息数据格式" class="headerlink" title="响应消息数据格式"></a>响应消息数据格式</h1><ul>
<li>服务器端发送给客户端的数据</li>
</ul>
<h2 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h2><blockquote>
<p>协议/版本    响应状态码    状态码描述</p>
</blockquote>
<ul>
<li>响应状态码：服务器告诉客户端本次请求和响应的一个状态</li>
<li>状态码都是3位数字</li>
<li>分类<ol>
<li>1xx：服务器接受客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li>
<li>4xx：客户端错误。代表：404(路径没有对应的资源)；405(请求方式没有对应的方法)</li>
<li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li>
</ol>
</li>
</ul>
<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><blockquote>
<p>头名称：值</p>
</blockquote>
<ul>
<li>常见的头名称<ol>
<li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据</li>
</ol>
</li>
<li>值<ol>
<li>in-line：默认值，在当前页面打开</li>
<li>attachment; filename-xxx：以附件形式打开响应体。文件下载</li>
</ol>
</li>
</ul>
<h2 id="响应空行"><a href="#响应空行" class="headerlink" title="响应空行"></a>响应空行</h2><h2 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h2><ul>
<li>传输的数据</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-179-最大数</title>
    <url>/2020/05/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-179-%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">10</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">210</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">9534330</span></span><br></pre></td></tr></table></figure>
<p>说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<a id="more"></a>
<hr>
<p>我自己原来的想法是遍历整个数组将它们两两比较，并组合。但显然超时了。后面看到官方提供的一个脑洞，代码非常简单。首先我们先定义一种大小关系：</p>
<ul>
<li>如果 a连接b之后的数大于b连接a，那么我们称 a大于b。</li>
</ul>
<p>按照这个比较关系，将原数组进行排序。排序之后的数组直接前后拼接出来的字符串就是它们组合所得到的最大的数。如果最后得到的字符串首位为0，说明该字符串后面都是0，那么只需要返回一个0即可。</p>
<p>算法实现起来是很简单的，但算法的正确性实在令人费解。官方是这样解释的：</p>
<blockquote>
<p>假设（不是一般性），某一对整数 a 和 b，我们的比较结果是 a 应该在 b 前面，这意味着$ a\frown b &gt; b\frown a$，其中 $\frown$表示连接。如果排序结果是错的，说明存在一个 c ， b 在 c 前面且 c 在 a 的前面。这产生了矛盾，因为 $a\frown b &gt; b\frown a$和$b\frown c &gt; c\frown b$意味着 $a\frown c &gt; c\frown a$ 。换言之，我们的自定义比较方法保证了传递性，所以这样子排序是对的。</p>
<p>一旦数组排好了序，最“重要”的数字会在最前面。有一个需要注意的情况是如果数组只包含 0 ，我们直接返回结果 00 即可。否则，我们用排好序的数组形成一个字符串并返回。</p>
</blockquote>
<p>总所周知力扣官方题解不讲人话。但我认为大概也可以用贪心的思想，实际上就是要将数组中的每一位移动到最合适的位置，那么就需要将数组的每一位进行比较。按照这种思考，有点冒泡排序的味道，每一轮都会确定一个数的最终位置。那么微观上是贪心，宏观上就是排序了，既然是排序，那就可以用更高效的排序方法了。</p>
<p>当然我的理解仅仅是从直觉上理解，事实上算法正确性的证明还是需要严谨的数学推导的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)s.push_back(to_string(i));</span><br><span class="line">        sort(s.begin(),s.end(),[](<span class="built_in">string</span> a,<span class="built_in">string</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b&gt;b+a;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> i:s)res+=i;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] == <span class="string">'0'</span>?<span class="string">"0"</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2020/05/28/c++/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>我们可以向一个算法传递任何类别的<strong>可调用对象(callable object)</strong>。lambda表达式是其中是一种形式。一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内敛函数。与任何函数类似，一个lambda具有一个返回类型，一个参数列表和一个函数体，但与函数不同，lambda可能定义在函数内部。</p>
<a id="more"></a>
<h1 id="lambda表达式的形式"><a href="#lambda表达式的形式" class="headerlink" title="lambda表达式的形式"></a>lambda表达式的形式</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">capture list</span>](<span class="link">parameter list</span>) -&gt; return type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>capture list</em> 是一个lambda所在函数中定义的局部变量的列表。</li>
<li><em>parameter list</em> 是参数列表。</li>
<li><em>return type</em> 是返回类型。 </li>
<li><em>function body</em> 是函数体。</li>
</ul>
<p>和普通函数不同的是，lambda必须使用尾置返回来指定返回类型。 参数列表和返回类型是可以忽略的，但必须包含捕获列表和函数体。</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure>
<p>此例中，我们定义了一个可调用对象f，它不接受参数，返回42。lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//打印42</span></span><br></pre></td></tr></table></figure>
<p>在lambda中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用f时，参数列表为空。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体只是一个return语句，则返回类型从返回的表达式的类型推断而来，否则返回类型为void。</p>
<h2 id="向lambda传递参数"><a href="#向lambda传递参数" class="headerlink" title="向lambda传递参数"></a>向lambda传递参数</h2><p>与普通函数类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常实参和形参的类型必须匹配。但与普通函数不同，lambda不能有默认参数。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。</p>
<h2 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h2><p>虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。</p>
<h1 id="lambda捕获与返回"><a href="#lambda捕获与返回" class="headerlink" title="lambda捕获与返回"></a>lambda捕获与返回</h1><p>当定义一个lambda的时候，编译器生成一个与lambda对应的新的(未命名)类类型。</p>
<h2 id="lambda本质是函数对象"><a href="#lambda本质是函数对象" class="headerlink" title="lambda本质是函数对象"></a>lambda本质是函数对象</h2><p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象。在lambda表达式产生的类中含有一个重载的函数调用运算符，例如，对于这个传递给stable_sort作为其最后一个实参的lambda表达式来说：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据单词长度对其进行排序，对于长度相同的单词按照字母表顺序排序</span></span><br><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.size() &lt; b.size();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其行为类似于下面这个类的一个未命名对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生的类只有一个函数调用运算符成员，它负责接收两个string并比较它们的长度，它的形参列表和函数体与lambda表达式完全一样。默认情况下lambda不能改变它捕获的常量，因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符就不是const的了。</p>
<p>用这个类替代lambda表达式后，我们可以重写并重新调用stable_sort:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), ShorterString());</span><br></pre></td></tr></table></figure>
<p>第三个实参是新构建的ShorterString对象，当stable_sort内部的代码每次比较两个string时就会“调用”这一对象，此时该对象将调用运算符的函数体，判断第一个string的大小小于第二个时返回true。</p>
<h2 id="lambda的捕获及相应捕获行为的类"><a href="#lambda的捕获及相应捕获行为的类" class="headerlink" title="lambda的捕获及相应捕获行为的类"></a>lambda的捕获及相应捕获行为的类</h2><h3 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h3><p>一个以引用方式捕获的变量与其他任何类型的引用行为相似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。</p>
<p>当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引的对象确实存在。因此，编译器可以直接使用该引用而无需在lambda产生的类中将其存储为数据成员。</p>
<h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>与传值参数类似，采用值捕获的前提是变量可以拷贝。但与参数不同，被捕获的变量是在lambda创建时的拷贝，而不是调用时的拷贝。由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。</p>
<p>通过值捕获的变量被拷贝到lambda中，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第一个指向满足条件元素的迭代器，该元素满足size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123;</span><br><span class="line">   <span class="keyword">return</span> a.size() &gt;= sz; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>该lambda表达式产生的类将形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span> &#123;</span></span><br><span class="line">    SizeComp(<span class="keyword">size_t</span> n): sz(n) &#123;&#125; <span class="comment">//该形参对应捕获的变量</span></span><br><span class="line">    <span class="comment">//该调用运算符的返回类型、形参和函数体都与lambda一致</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.size() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> sz; <span class="comment">//该数据成员对应通过值捕获的变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和ShorterString类不同，上面这个类含有一个数据成员以及一个用于初始化该成员的构造函数。这个合成的类不含有默认构造函数，因此想要使用这个类必须提供一个实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第一个指向满足条件元素的迭代器，该元素满足size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), SizeComp(sz));</span><br></pre></td></tr></table></figure>
<p>lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认拷贝/移动构造函数则通常要视捕获的数据成员类型而定。</p>
<h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><p>除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们需要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=表示采用值捕获方式。</p>
<p>当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。显式捕获的变量必须使用与隐式捕获不同的方式。即：</p>
<ul>
<li>如果隐式捕获是引用方式(使用了&amp;)，则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&amp;。</li>
<li>如果隐式捕获采用的是值方式(使用了=)，则显式捕获命名变量必须采用引用方式，即在名字前使用&amp;。</li>
</ul>
<blockquote>
<p><strong>lambda捕获列表</strong></p>
<ol>
<li><p>[]，空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它&gt;们。</p>
</li>
<li><p>[<em>names</em>]，<em>names</em>是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。&gt;默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了&amp;，则采用引用捕获方式。</p>
</li>
<li><p>[&amp;]，隐式捕获列表，采用引用捕获方式。lambda体中所使用的来自所在函数的实体都采用引用方式使用。</p>
</li>
<li><p>[=]，隐式捕获列表，采用值捕获方式。lambda体将拷贝所使用的来自所在函数实体的值。</p>
</li>
<li><p>[&amp;，<em>identifier_list</em>]，<em>identifier_list</em>是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式的捕获。<em>identifier_list</em></p>
</li>
<li>[=，<em>identifier_list</em>]，<em>identifier_list</em>中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。<em>identifier_list</em>中的名字不能包括this，且这些名字之前必须使用&amp;。</li>
</ol>
</blockquote>
<h3 id="可变lambda"><a href="#可变lambda" class="headerlink" title="可变lambda"></a>可变lambda</h3><p>默认情况下，对于<strong>一个值被拷贝的变量</strong>，lambda不会改变其值。如果我们希望能改变一个被捕获变量的值，就必须在参数列表首加上关键字<strong>mutable</strong>。因此，可变lambda能忽略参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>; <span class="comment">//局部变量</span></span><br><span class="line">    <span class="comment">// f可以改变它所捕获的变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//j为43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个引用捕获的变量</strong>是否可以修改依赖于此引用指向的是一个const类型还是一个非const类型。</p>
<h2 id="指定lambda返回类型"><a href="#指定lambda返回类型" class="headerlink" title="指定lambda返回类型"></a>指定lambda返回类型</h2><p>默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), vi.begin(), [](<span class="keyword">int</span> i) &#123; </span><br><span class="line">    <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这里，由于函数体内仅包含返回语句，因此可以省略返回类型，因为返回类型可以由返回语句推断得出。而如果改为以下写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), vi.begin(), [](<span class="keyword">int</span> i) &#123; </span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个函数体内所包含的除了返回语句之外，还有条件判断语句。如果不声明返回类型，将会默认返回为空，那么在此例中将会引发编译错误。在这种情况下必须显式声明尾置返回类型。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>中缀表达式的计算(栈实现)</title>
    <url>/2020/05/27/algorithms/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97(%E6%A0%88%E5%AE%9E%E7%8E%B0)/</url>
    <content><![CDATA[<p>最近在学编译原理，其中有个实验要求是建立算术表达式的语法分析树。其实我感觉难点就在于如何将中缀表达式转化为前缀或后缀表达式。而建立语法分析树的目的和求值的目的实质上是一样的。特此记录一下在数据结构中算术表达式在栈的应用中的表现。</p>
<a id="more"></a>
<hr>
<p>事实上对于机器来说，前缀表达式和后缀表达式相对于中缀表达式是更容易看懂的，因为不涉及到优先级的比较。而中缀表达式中的优先级则体现在括号的应用上。</p>
<h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>首先初始化一个栈，用于保存<strong>暂时还不能确定运算顺序的运算符</strong>。</p>
<p>从左往右依次处理各个元素，直到末尾。可能会遇到以下三种情况：</p>
<ol>
<li>遇到<strong>操作数</strong>。直接加入后缀表达式。</li>
<li>遇到<strong>界限符</strong>。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符并加入后缀表达式，直到弹出”(“为止。</li>
<li>遇到<strong>运算符</strong>。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若遇到”(“或栈空则停止。之后再把当前运算符入栈。</li>
</ol>
<p>按上述方法处理完所有字符之后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<h1 id="中缀表达式的计算"><a href="#中缀表达式的计算" class="headerlink" title="中缀表达式的计算"></a>中缀表达式的计算</h1><p>初始化两个栈，操作数栈和运算符栈。</p>
<ul>
<li>若扫描到操作数，压入操作数栈。</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈(期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈)</li>
</ul>
<h1 id="中缀表达式生成语法分析树"><a href="#中缀表达式生成语法分析树" class="headerlink" title="中缀表达式生成语法分析树"></a>中缀表达式生成语法分析树</h1><p>和中缀表达式的计算区别在于操作数栈改为二叉树节点栈，数值运算改为基本二叉树的建立。</p>
<ul>
<li>二叉树的定义如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeNode(<span class="keyword">char</span> val);</span><br><span class="line">	TreeNode();</span><br><span class="line">	~TreeNode();</span><br><span class="line">	<span class="keyword">char</span> val;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode::TreeNode(<span class="keyword">char</span> val)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode::TreeNode()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;val = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode::~TreeNode()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优先级的判断(只考虑加减乘除)，如果a的优先级高于b，返回真，否则返回假。：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">priority</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="string">'*'</span> || b == <span class="string">'/'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="string">'*'</span> || a == <span class="string">'/'</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生成语法树：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">genericTree</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">exp</span>;</span><br><span class="line">	<span class="keyword">auto</span> genericMiniTree = [&amp;]() &#123;</span><br><span class="line">		TreeNode* tmp = <span class="keyword">new</span> TreeNode(op.top());</span><br><span class="line">		op.pop();</span><br><span class="line">		tmp-&gt;right = <span class="built_in">exp</span>.top();</span><br><span class="line">		<span class="built_in">exp</span>.pop();</span><br><span class="line">		tmp-&gt;left = <span class="built_in">exp</span>.top();</span><br><span class="line">		<span class="built_in">exp</span>.pop();</span><br><span class="line">		<span class="built_in">exp</span>.push(tmp);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> i : str) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="string">'+'</span> || i == <span class="string">'-'</span> || i == <span class="string">'*'</span> || i == <span class="string">'/'</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!op.empty() &amp;&amp; op.top() != <span class="string">'('</span>)</span><br><span class="line">				<span class="keyword">if</span> (!priority(i, op.top()))genericMiniTree();</span><br><span class="line">			op.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">'('</span>) &#123;</span><br><span class="line">			op.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">')'</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (op.top() != <span class="string">'('</span>)genericMiniTree();</span><br><span class="line">			op.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(i) || <span class="built_in">isdigit</span>(i)) &#123;</span><br><span class="line">			<span class="built_in">exp</span>.push(<span class="keyword">new</span> TreeNode(i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"wrong expression!"</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!op.empty())genericMiniTree();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">exp</span>.top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-173-二叉搜索树迭代器</title>
    <url>/2020/05/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。<br>提示：</p>
<ul>
<li>next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。</li>
<li>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。</li>
</ul>
<a id="more"></a>
<hr>
<p>实质上就是要对这个二叉搜索树进行一次中序遍历，栈的高度正好符合题目要求的树的高度。但在每次调用next()的时候需要寻找当前节点的右孩子的最左子孙，这一点变数特别大，和树的形态有关。以我目前看来符不符合$O(1)$的时间复杂度是存疑的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* cur;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cur = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;cur)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;cur = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="keyword">this</span>-&gt;cur-&gt;val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cur = <span class="keyword">this</span>-&gt;cur-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>-&gt;cur)&#123;</span><br><span class="line">            s.push(<span class="keyword">this</span>-&gt;cur);</span><br><span class="line">            <span class="keyword">this</span>-&gt;cur = <span class="keyword">this</span>-&gt;cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;cur&amp;&amp;!s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator* obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;next();</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie的使用</title>
    <url>/2020/05/23/java/Cookie%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>java对Cookie的操作主要分为Cookie的建立，Cookie的读取，还有Cookie的生命周期与路径的设定。</p>
<a id="more"></a>
<hr>
<h1 id="Cookie的概念"><a href="#Cookie的概念" class="headerlink" title="Cookie的概念"></a>Cookie的概念</h1><p>客户端会话技术，可以将数据保存到客户端。</p>
<h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><ol>
<li>创建Cookie对象，绑定数据 <code>new Cookie(String name, String value)</code></li>
<li>发送Cookie对象 <code>response.addCookie(Cookie cookie)</code></li>
<li>获取Cookie，拿到数据 <code>Cookie[] resquest.getCookie()</code></li>
</ol>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><ul>
<li>基于响应头set-cookie和请求头cookie实现。</li>
</ul>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="cookie的数量"><a href="#cookie的数量" class="headerlink" title="cookie的数量"></a>cookie的数量</h2><ul>
<li>通过创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</li>
</ul>
<h2 id="cookie在浏览器中的保存时间"><a href="#cookie在浏览器中的保存时间" class="headerlink" title="cookie在浏览器中的保存时间"></a>cookie在浏览器中的保存时间</h2><ol>
<li>默认情况下，当浏览器关闭后，Cookie数据被销毁。</li>
<li>持久化存储：<ul>
<li>setMaxAge(int seconds)<ol>
<li>正数：将Cookie数据写到硬盘中。持久化存储。并指定cookie的存活时间，时间到后，cookie文件自动失效。</li>
<li>负数： 默认值。</li>
<li>零： 删除cookie信息。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="cookie存储中文问题"><a href="#cookie存储中文问题" class="headerlink" title="cookie存储中文问题"></a>cookie存储中文问题</h2><ul>
<li>在tomcat 8 之前 cookie中不能直接存储中文数据。需要将中文数据转码，一般采用URL编码（%E3）。</li>
<li>在tomcat 8之后，cookie支持中文数据。</li>
</ul>
<h2 id="cookie的共享问题"><a href="#cookie的共享问题" class="headerlink" title="cookie的共享问题"></a>cookie的共享问题</h2><h3 id="在同一个服务器中共享"><a href="#在同一个服务器中共享" class="headerlink" title="在同一个服务器中共享"></a>在同一个服务器中共享</h3><ul>
<li>默认情况下cookie不能共享。</li>
<li><code>setPath(String path)</code>:设置cookie的获取范围。默认情况下，设置当前的虚拟目录。如果需要共享，则可以将path设置为”/“。</li>
</ul>
<h3 id="在不同的tomcat服务器间cookie共享"><a href="#在不同的tomcat服务器间cookie共享" class="headerlink" title="在不同的tomcat服务器间cookie共享"></a>在不同的tomcat服务器间cookie共享</h3><ul>
<li><p><code>setDomain(String path)</code>: 如果设置一级域名相同，那么多个服务器之间cookie可以共享。</p>
<p>例如：<code>setDomain(&quot;.baidu.com&quot;)</code>，那么tieba.baidu.com和news.baidu.com中cookie可以共享。</p>
</li>
</ul>
<h2 id="cookie的特点和作用"><a href="#cookie的特点和作用" class="headerlink" title="cookie的特点和作用"></a>cookie的特点和作用</h2><ol>
<li>cookie存储数据在客户端浏览器。</li>
<li>浏览器对于单个cookie的大小有限制(4kb)以及对同一个域名下的总cookie数量也有限制(20个)。</li>
</ol>
<ul>
<li>作用<ol>
<li>cookie一般用于存储少量的不太敏感的数据。</li>
<li>在不登录的情况下，完成服务器对客户端省份识别。</li>
</ol>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-165-比较版本号</title>
    <url>/2020/05/22/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>比较两个版本号 version1 和 version2。如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。<br><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: versio<span class="symbol">n1</span> = <span class="string">"0.1"</span>, versio<span class="symbol">n2</span> = <span class="string">"1.1"</span></span><br><span class="line">输出: <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: versio<span class="symbol">n1</span> = <span class="string">"1.0.1"</span>, versio<span class="symbol">n2</span> = <span class="string">"1"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: versio<span class="symbol">n1</span> = <span class="string">"7.5.2.4"</span>, versio<span class="symbol">n2</span> = <span class="string">"7.5.3"</span></span><br><span class="line">输出: <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line">输入：versio<span class="symbol">n1</span> = <span class="string">"1.01"</span>, versio<span class="symbol">n2</span> = <span class="string">"1.001"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：忽略前导零，“<span class="number">01</span>” 和 “<span class="number">001</span>” 表示相同的数字 “<span class="number">1</span>”。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">5</span>：</span><br><span class="line">输入：versio<span class="symbol">n1</span> = <span class="string">"1.0"</span>, versio<span class="symbol">n2</span> = <span class="string">"1.0.0"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：versio<span class="symbol">n1</span> 没有第三级修订号，这意味着它的第三级修订号默认为 “<span class="number">0</span>”。</span><br></pre></td></tr></table></figure><br>提示：</p>
<ul>
<li>版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。</li>
<li>版本字符串不以点开始或结束，并且其中不会有两个连续的点。</li>
</ul>
<a id="more"></a>
<hr>
<p>题目要求比较复杂，除了对版本号传统的认知外，我需要着重考虑两种情况。一种是在一个版本号中，不管前面加了多少个0，都是同一个版本号，另一种是，如果排除末尾的所有0，前面部分是一样的，那么以后面0多的版本号为高版本。</p>
<p>如果对字符串流的操作比较熟悉那么可以很快解出此题。</p>
<ul>
<li>用一个字符变量来接收小数点。</li>
<li>用两个整型变量来接受数字。</li>
<li>在一个循环内逐步按照小数点分割接受数字，并进行比较。如果有一方遍历结束，那么就将其对应的整型变量置0以便于参与下次比较。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> dot;</span><br><span class="line">        <span class="keyword">int</span> num1,num2;</span><br><span class="line">        stringstream ss1(version1),ss2(version2);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">bool</span>(ss1&gt;&gt;num1)+<span class="keyword">bool</span>(ss2&gt;&gt;num2))&#123;</span><br><span class="line">            <span class="keyword">if</span>(num1&gt;num2)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1&lt;num2)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            num1 = num2 = <span class="number">0</span>;</span><br><span class="line">            ss1&gt;&gt;dot;</span><br><span class="line">            ss2&gt;&gt;dot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-162-寻找峰值</title>
    <url>/2020/05/21/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    <content><![CDATA[<p>峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。你可以假设 nums[-1] = nums[n] = -∞。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: <span class="number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="number">2</span>。</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">1</span> 或 <span class="number">5</span> </span><br><span class="line">解释: 你的函数可以返回索引 <span class="number">1</span>，其峰值元素为 <span class="number">2</span>；</span><br><span class="line">或者返回索引 <span class="number">5</span>， 其峰值元素为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><br>说明:<br>你的解法应该是 O(logN) 时间复杂度的。</p>
<a id="more"></a>
<hr>
<p>题目既然提示了对数的时间复杂度，那么在数组内自然是用二分法了。思路也很简单，既然题目表明如果两个边界只要一边满足要求就能算是峰值的话，那么二分法一定可以找出一个峰值。需要比较的地方在于判断两个指针中间部分的数值的升降趋势。如果是升，那么右边将会有一个峰值，如果是降，那么左边必有一个峰值。需要注意的地方是每次迭代过程中左右指针的移位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        int i(0),j(nums.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = (i+j)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;nums[k+<span class="number">1</span>])j = k;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[k]&lt;nums[k+<span class="number">1</span>])i = k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-155-最小栈</title>
    <url>/2020/05/20/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) —— 将元素 x 推入栈中。</li>
<li>pop() —— 删除栈顶的元素。</li>
<li>top() —— 获取栈顶元素。</li>
<li>getMin() —— 检索栈中的最小元素。</li>
</ul>
<p>提示：pop、top 和 getMin 操作总是在 非空栈 上调用。</p>
<a id="more"></a>
<hr>
<p>为了图方便我就直接用了STL中的栈来写了，毕竟这题的考察点是在于以$O(1)$的时间复杂度找出栈中的最小元素。虽然这已经和栈的朴素定义起了冲突，因为对于一个栈我们确实只应该关心栈顶已经对栈顶元素的操作。</p>
<p>话说回来，实际上想最快的找到最小元素，那么可以使用额外一个栈，每次更新数据是时候都想此时的最小元素压入最小元素栈的栈顶。每次弹出元素的时候如果其值和最小元素栈栈顶元素值相等，那么最小元素栈也需要将栈顶元素弹出。这样的话最小元素栈的栈顶元素就能够保持始终是栈中最小元素。需要取的时候直接访问栈顶就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minmum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minmum.empty()||minmum.top()&gt;=x)</span><br><span class="line">            minmum.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.top() == minmum.top())minmum.pop();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minmum.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-152-乘积最大子数组</title>
    <url>/2020/05/20/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 子数组 [<span class="number">2</span>,<span class="number">3</span>] 有最大乘积 <span class="number">6</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">-2</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 结果不能为 <span class="number">2</span>, 因为 [<span class="number">-2</span>,<span class="number">-1</span>] 不是子数组。</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<hr>
<h1 id="分治法："><a href="#分治法：" class="headerlink" title="分治法："></a>分治法：</h1><p>一开始将数组的结构研究了好一会儿，发现可以这样分析：要想子数组的乘积最大，那么里面就最好不含0，除非情况极坏。所以可以将数组按照0作为分隔符将其分为若干个子数组进行分治。</p>
<ul>
<li>对于每一个子数组来说，如果其乘积小于0，说明其中负数有奇数个，那么分别从左边和右边找到第一个负数，将其截断。取最大值作为这个子数组的乘积最大值。</li>
<li>最后取所有子数组的最大值。当然还要考虑一些特殊情况。</li>
</ul>
<h1 id="贪心算法："><a href="#贪心算法：" class="headerlink" title="贪心算法："></a>贪心算法：</h1><p>其实这道题做着有些似曾相识，这和之前做过的最大子序和不是如出一辙吗。因为要求的是连续数组，所以每次都将当前最优解与最终解比较并更新。</p>
<ul>
<li>与最大子序和不同的是，乘积最大子数组需要存两个临时值，一个是当前数组的最大值，一个是最小值。理由是因为乘法的性质，当乘以一个负数的时候，最大值有可能变最小值，最小值有可能变最大值，这个是难以确定的。</li>
<li>我们需要将数组遍历一遍，如果当前元素是负数，那么就需要将当前最大值与当前最小值互换了。之后分别将当前元素乘上此前记录的最大或最小值。如果乘下来的最大值还不如现在遍历到的元素大，那就直接将当前元素作为最大值，类似的，如果乘下来的最小值还不如当前元素小，那就以当前元素作为最小值。</li>
<li>每一次遍历也都需要将整次遍历所得出的最大值提取出来作为结果输出。</li>
</ul>
<p>之所以能这么做，一切要归功于题目所要求的子数组要连续。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN, max_value = <span class="number">1</span>, min_value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)swap(max_value,min_value);</span><br><span class="line">            max_value = max(max_value*i,i);</span><br><span class="line">            min_value = min(min_value*i,i);</span><br><span class="line">            res = max(res,max_value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-153-寻找旋转排序数组中的最小值</title>
    <url>/2020/05/18/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<hr>
<p>看到评论区一堆用标准库排序输出首元素，还有遍历一遍找旋转点的，我也是服了。有序条件下的查找操作显然是二分法最快啊。但这种题套模板肯定是不行的，但也就是细节上的一些改动而已。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = (i+j)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[k]&lt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                j = k;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> min(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(nums[<span class="number">0</span>],min(nums[i],nums[j]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-133-克隆图</title>
    <url>/2020/05/18/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-133-%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    <content><![CDATA[<p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试用例格式：</p>
<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。</p>
<p>示例：</p>
<image src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png">

<p>提示：</p>
<ol>
<li>节点数不超过 100 。</li>
<li>每个节点值 Node.val 都是唯一的，1 &lt;= Node.val &lt;= 100。</li>
<li>无向图是一个简单图，这意味着图中没有重复的边，也没有自环。</li>
<li>由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。</li>
<li>图是连通图，你可以从给定节点访问到所有节点。</li>
</ol>
<a id="more"></a>
<hr>
<p>为了更好的将原节点与new出来的节点一一对应，用键值对的方式来存储这种一一映射的关系。之后便是基本的广度优先遍历了。map的好处还有容易判断是否存在某个键。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!node)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">		<span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line">		que.push(node);</span><br><span class="line">		<span class="keyword">auto</span> res = <span class="keyword">new</span> Node(node-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">		m[node] = res;</span><br><span class="line">		<span class="keyword">while</span> (!que.empty())&#123;</span><br><span class="line">			<span class="keyword">auto</span> tmp = que.front();</span><br><span class="line">			que.pop();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp-&gt;neighbors)&#123;</span><br><span class="line">				<span class="keyword">if</span> (m.find(i)==m.end())&#123;</span><br><span class="line">					m[i] = <span class="keyword">new</span> Node(i-&gt;val,<span class="built_in">vector</span>&lt;Node*&gt;&#123;&#125;);</span><br><span class="line">					que.push(i);</span><br><span class="line">				&#125;</span><br><span class="line">				m[tmp]-&gt;neighbors.push_back(m[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-151-翻转字符串里的单词</title>
    <url>/2020/05/17/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入: <span class="comment">"the sky is blue"</span></span><br><span class="line">输出: <span class="comment">"blue is sky the"</span></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入: <span class="comment">"  hello world!  "</span></span><br><span class="line">输出: <span class="comment">"world! hello"</span></span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line">输入: <span class="comment">"a good   example"</span></span><br><span class="line">输出: <span class="comment">"example good a"</span></span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>进阶：请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。</li>
</ul>
<a id="more"></a>
<hr>
<p>很好奇为什么只推荐C语言用户使用常数空间来做。其实就是双指针操作字符数组。比较麻烦的还是处理那些特殊情况，但注意考虑，适当加上条件语句就可以应对了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(s.size()<span class="number">-1</span>);i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isspace</span>(s[i]))&#123;</span><br><span class="line">                <span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(i)</span></span>;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;!<span class="built_in">isspace</span>(s[--j]));</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>||<span class="built_in">isspace</span>(s[j]))j++;</span><br><span class="line">                res+=s.substr(j,i-j+<span class="number">1</span>);</span><br><span class="line">                res+=<span class="string">" "</span>;</span><br><span class="line">                i = j<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&gt;<span class="number">0</span>)res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-150-逆波兰表达式求值</title>
    <url>/2020/05/16/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<p>根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>说明：</p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<a id="more"></a>
<hr>
<p>其实就是后缀表达式的求解。需要遍历一次原字符串，用一个辅助栈来实现。步骤如下：</p>
<ul>
<li>若读到的符号是数字，则将其转化为整型入栈。</li>
<li>若读到的符号是操作符，则将栈顶出栈两个元素，进行运算后再压入栈。</li>
<li>遍历结束之后的栈顶元素即为运算结果，当然此时栈中只有一个元素。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">"+"</span>||i == <span class="string">"-"</span>||i == <span class="string">"*"</span>||i == <span class="string">"/"</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                <span class="keyword">int</span> b = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">                sta.push(oper(a,b,i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp;</span><br><span class="line">                <span class="built_in">stringstream</span> ss;</span><br><span class="line">                ss&lt;&lt;i;</span><br><span class="line">                ss&gt;&gt;tmp;</span><br><span class="line">                sta.push(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sta.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">oper</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="built_in">string</span> op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"+"</span>)<span class="keyword">return</span> b+a;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"-"</span>)<span class="keyword">return</span> b-a;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">"*"</span>)<span class="keyword">return</span> b*a;</span><br><span class="line">        <span class="keyword">return</span> b/a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-146-LRU缓存机制</title>
    <url>/2020/05/14/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>LRU算法广泛应用在cache块置换，页面置换等场景当中。计算机组成原理中有介绍一种采用标记位的LRU算法，即刚刚访问的元素或新插入的元素的标记位置零，每次访问的时候将除了访问的元素之外的所有元素的标记位自增。如果需要置换，则将标记位最大的那个元素换出。但由于每次访问时需要对所有的元素操作，因此时间复杂度需要O(n)，而为了达到常数级的时间复杂度，可以换一种思路。</p>
<p>使用一个链表来存储缓冲区的元素，再将链表中的每个节点的地址与它的键存入一个哈希表。这样做是为了获得一个高效的查找，插入删除效率。每次访问一个已存在的元素，需要将其链表中的节点放入链表的首部，并更新哈希表中的地址。每次访问一个不存在的元素，若缓存区已满，则移除链表尾部元素，将一个新的节点插入链表首部，也相应的在哈希表中新增地址，若缓存区不满，那么将新节点直接按照头插法插入，更新哈希表。</p>
<p>事实上，STL中提供的list并不提供将链表中间节点直接移动到头部，只能将其删除并释放，再新建一个节点插入头部。如果能手写一个链表，提供直接移动节点到头部，显然效率是要更高的，并且不需释放节点和更新哈希表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;::iterator&gt; cache;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; li;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;cache.find(key) == <span class="keyword">this</span>-&gt;cache.end())<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="keyword">this</span>-&gt;cache[key]-&gt;second;</span><br><span class="line">        <span class="keyword">this</span>-&gt;li.erase(<span class="keyword">this</span>-&gt;cache[key]);</span><br><span class="line">        <span class="keyword">this</span>-&gt;li.push_front(make_pair(key,value));</span><br><span class="line">        <span class="keyword">this</span>-&gt;cache[key] = <span class="keyword">this</span>-&gt;li.begin();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;cache[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;cache.find(key)!=<span class="keyword">this</span>-&gt;cache.end())</span><br><span class="line">           <span class="keyword">this</span>-&gt;li.erase(<span class="keyword">this</span>-&gt;cache[key]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;li.size() == <span class="keyword">this</span>-&gt;size)&#123;</span><br><span class="line">               <span class="keyword">this</span>-&gt;cache.erase(<span class="keyword">this</span>-&gt;li.back().first);</span><br><span class="line">               <span class="keyword">this</span>-&gt;li.pop_back();</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;li.push_front(make_pair(key,value));</span><br><span class="line">        <span class="keyword">this</span>-&gt;cache[key] = <span class="keyword">this</span>-&gt;li.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-172-阶乘后的零</title>
    <url>/2020/05/09/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/</url>
    <content><![CDATA[<p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
<a id="more"></a>
<hr>
<p>阶乘结果中出现的零其实来源于对结果的一次乘10，将阶乘的式子展开，然后分解质因子可以发现，只有2与5相乘可以得到10，而2的个数显然是要多于5的。因此只要计算出分解质因子之后的式子里5的个数即可。每当有一个5就意味着会有一个10。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;=<span class="number">5</span>)&#123;</span><br><span class="line">            count += n/<span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-169-Excel表列序号</title>
    <url>/2020/05/08/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-169-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</url>
    <content><![CDATA[<p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<p>例如，</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
...
</code></pre><a id="more"></a>
<hr>
<p>做法与二十六进制转十进制类似，但要注意每一位要将其偏移一位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;s.size();i++,res++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = s[i] - <span class="number">65</span>;</span><br><span class="line">            res*=<span class="number">26</span>;</span><br><span class="line">            res+=val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-169-多数元素</title>
    <url>/2020/05/07/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<a id="more"></a>
<hr>
<p>一种容易想到的方法是利用哈希表来记录每个元素出现的次数，选出那个大于二分之n的元素即可。但为了减小空间复杂度，可以采用摩尔投票法来求解。由于多数元素的个数是大于二分之n的。那么如果用每一个非多数元素与一个多数元素进行抵消，那么最后肯定会剩下的是多数元素。在遍历的过程中，如果计数器为0，说明之前的元素可以看作无多数元素，因为全部两两抵消掉了。简单来说，即使前面遇到的元素出现了很多次，但如果它不是多数元素，那么属于它的计数器的值一定会减为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        int count(0),candidate;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate = i;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == candidate)count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-168-Excel表列名称</title>
    <url>/2020/05/06/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p>例如:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...
</code></pre><a id="more"></a>
<hr>
<p>一开始还以为是简单的十进制转化为二十六进制，但却被这道题难住了，到后面亲自打开Excel看一遍排列规则才恍然大悟。但思路还是用原始的进制转换方法，总体从低位计算至高位。最低位的值的ASCII应该是十进制数值-1模26再加上65。因为在这里的26进制是没有对应到十进制的0的，所以为了将整个映射关系对齐，需要对其减1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">char</span> <span class="title">ch</span><span class="params">(<span class="number">65</span>+n%<span class="number">26</span>)</span></span>;</span><br><span class="line">            res = ch + res;</span><br><span class="line">            n/=<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-167-两数之和II-输入有序数组</title>
    <url>/2020/05/05/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p>示例:<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: numbers = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释: <span class="number">2</span> 与 <span class="number">7</span> 之和等于目标数 <span class="number">9</span> 。因此 index1 = <span class="number">1</span>, index2 = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<hr>
<p>如果数组是无序的，那么用哈希表可以达到最短时间，但现在输入是有序的，那么这题其实就可以直接用双指针法来实现了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        int i(0),j(numbers.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(k&gt;target)j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;target)i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> &#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-160-相交链表</title>
    <url>/2020/05/04/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>编写一个程序，找到两个单链表相交的起始节点。</p>
<a id="more"></a>
<p>最初的想法是用哈希表来存储其中一条链表的所有节点，然后遍历另一条链表对比是否有相同节点。但在评论区发现了一种更加优雅的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)</span></span><br><span class="line"><span class="comment">        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="comment">//if(headA|| headB == null) return null;</span></span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="comment">// 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null</span></span><br><span class="line">        <span class="keyword">while</span>(pA != pB) &#123;</span><br><span class="line">            pA = pA ? pA-&gt;next : headB;</span><br><span class="line">            pB = pB ? pB-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看起来比较抽象，但实际上是将这个相交链表构造成了两个长度不等的环，两个指针在内部进行追及。这个方法不好理解，但值得一背。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-148-排序链表</title>
    <url>/2020/05/03/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<a id="more"></a>
<p>单链表版本的迭代归并排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummyHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; length; size &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = dummyHead.next;</span><br><span class="line">            <span class="keyword">auto</span> tail = &amp;dummyHead;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                <span class="keyword">auto</span> left = cur;</span><br><span class="line">                <span class="keyword">auto</span> right = cut(left, size); <span class="comment">// left-&gt;@-&gt;@ right-&gt;@-&gt;@-&gt;@...</span></span><br><span class="line">                cur = cut(right, size); <span class="comment">// left-&gt;@-&gt;@ right-&gt;@-&gt;@  cur-&gt;@-&gt;...</span></span><br><span class="line">                </span><br><span class="line">                tail-&gt;next = merge(left, right);</span><br><span class="line">                <span class="keyword">while</span> (tail-&gt;next) &#123;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">cut</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">while</span> (--n &amp;&amp; p) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> next = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummyHead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> p = &amp;dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l1;</span><br><span class="line">                p = l1;</span><br><span class="line">                l1 = l1-&gt;next;       </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = l2;</span><br><span class="line">                p = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = l1 ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-147-对链表进行插入排序</title>
    <url>/2020/05/02/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>插入排序算法：</p>
<ul>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ul>
<a id="more"></a>
<hr>
<p>用双指针，一个用来指示已排好序的位置，另一个指针从头开始寻找插入位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* H(new ListNode(0)),*p(head);</span><br><span class="line">        H-&gt;next = p;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;p-&gt;next)&#123;</span><br><span class="line">            <span class="function">ListNode* <span class="title">q</span><span class="params">(H)</span></span>;</span><br><span class="line">            <span class="keyword">while</span>(q!=p&amp;&amp;q-&gt;next-&gt;val&lt;p-&gt;next-&gt;val)</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(q!=p)insert(p,q);</span><br><span class="line">            <span class="keyword">else</span> p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> H-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(ListNode* p,ListNode* q)</span></span>&#123;</span><br><span class="line">        <span class="function">ListNode* <span class="title">tmp</span><span class="params">(p-&gt;next)</span></span>;</span><br><span class="line">        p-&gt;next = tmp?tmp-&gt;next:<span class="literal">NULL</span>;</span><br><span class="line">        tmp-&gt;next = q-&gt;next;</span><br><span class="line">        q-&gt;next = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-144-二叉树的前序遍历</title>
    <url>/2020/04/30/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>给定一个二叉树，返回它的 前序 遍历。<br><a id="more"></a></p>
<hr>
<p>用栈来保存所有右节点，当访问完左子树所有节点时，栈顶元素出栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">        <span class="keyword">while</span>(root||!sta.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root)&#123;</span><br><span class="line">                res.push_back(root-&gt;val);</span><br><span class="line">                sta.push(root-&gt;right);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-143-重排链表</title>
    <url>/2020/04/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">示例 :</span><br><span class="line">给定链表 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>, 重新排列为 <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3.</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<hr>
<p>我的思路是先用快慢指针找到单链表的中点，再将后半段的链表逆序，最后依次将后半段链表节点间隔插入到前半段链表中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next||!head-&gt;next-&gt;next)<span class="keyword">return</span>;</span><br><span class="line">        <span class="function">ListNode* <span class="title">mid</span><span class="params">(head)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode *fast(head);fast&amp;&amp;fast-&gt;next;mid=mid-&gt;next,fast=fast-&gt;next-&gt;next);</span><br><span class="line">        <span class="function">ListNode* <span class="title">j</span><span class="params">(mid-&gt;next)</span></span>;</span><br><span class="line">        mid-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        j = reverse(j);</span><br><span class="line">        <span class="keyword">for</span>(ListNode* i(head);j;i=i-&gt;next-&gt;next)&#123;</span><br><span class="line">            <span class="function">ListNode* <span class="title">tmp</span><span class="params">(j-&gt;next)</span></span>;</span><br><span class="line">            j-&gt;next = i-&gt;next;</span><br><span class="line">            i-&gt;next = j;</span><br><span class="line">            j = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* h = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next)&#123;</span><br><span class="line">            ListNode* tmp = head-&gt;next;</span><br><span class="line">            head-&gt;next = tmp-&gt;next;</span><br><span class="line">            tmp-&gt;next = h-&gt;next;</span><br><span class="line">            h-&gt;next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* res = h-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> h;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-142-环形链表II</title>
    <url>/2020/04/28/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。<br>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<br><strong>说明：</strong>不允许修改给定的链表。<br><strong>进阶：</strong>你是否可以不用额外空间解决此题？</p>
<a id="more"></a>
<hr>
<p>这道题要得到的结果不仅仅是判断单链表是否有环，还要找到环的入口位置。不过总体思路还是先用快慢指针找到入口点，依然是快指针每次走两步，慢指针每次走一步。那么我们在成功判断有环之后，可以得到两个指针的相遇位置。</p>
<p>那么可以往下考虑这个追及问题，从起点到环的入口距离设为a，从环的入口到两指针相遇点的距离设为b，从两指针相遇点到环的入口距离设为c。根据快慢指针相遇之前的速度可列出以下方程：</p>
<script type="math/tex; mode=display">
a+b=t\\
a+k(b+c)+b=2t</script><p>其中k为整数，表示快指针比慢指针多走的圈数。t代表两者相遇的时间。将两个方程左右同时相除：</p>
<script type="math/tex; mode=display">
k(b+c)=a+b</script><p>将其变形为</p>
<script type="math/tex; mode=display">
(k-1)b+kc=a</script><p>可以发现，这个式子的物理含义就是一个指针从前文所提的相遇点出发，两一个指针从链表的起点出发，两个指针的速度都为1，当从起点出发的指针到达环的入口(长度a)时，另一指针也正好在环的入口位置。因此，找到了寻找环的入口的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* i(head-&gt;next),*j(i-&gt;next);j;i = i-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-&gt;next)j = j-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode* a(head),*b(i);</span><br><span class="line">                <span class="keyword">for</span>(;a!=b;a = a-&gt;next,b = b-&gt;next);</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-141-环形链表</title>
    <url>/2020/04/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<a id="more"></a>
<hr>
<p>单链表判环，穷举法时间复杂度为$O(n^2)$，空间复杂度$O(1)$。</p>
<p>用哈希表来存储访问过的节点，如果第二次走到走过的节点则判定有环。时间复杂度$O(n)$，空间复杂度$O(n)$。</p>
<p>双指针法的时间复杂度为$O(n)$，空间复杂度$O(1)$。</p>
<p>双指针法即用快慢指针，两个指针就好像两个运动员赛跑，如果存在环路，那么除了起点之外，快的运动员一定能够追上慢的运动员，即第二次相遇。体现在代码上就是每次慢指针走一步，快指针走两步，如果快慢指针指向同一节点那么判定为有环。要是快指针直接走到底，那么就无环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head&amp;&amp;head-&gt;next)</span><br><span class="line">            <span class="keyword">for</span>(ListNode* p(head-&gt;next),*q(head-&gt;next-&gt;next);q&amp;&amp;q-&gt;next;p = p-&gt;next,q = q-&gt;next-&gt;next)</span><br><span class="line">                <span class="keyword">if</span>(p == q)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-139-单词拆分</title>
    <url>/2020/04/26/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 ：<br><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"applepenapple"</span>, <span class="attr">wordDict</span> = [<span class="string">"apple"</span>, <span class="string">"pen"</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: 返回 <span class="literal">true</span> 因为 <span class="string">"applepenapple"</span> 可以被拆分成 <span class="string">"apple pen apple"</span>。</span><br><span class="line">注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<hr>
<p>又是一道很典型的回溯的题，思路是先将字典存到一个易于查找的数据结构里，我选择的是哈希表。然后检查字符串的前缀，如果和字典中的字符串匹配，那么就递归检查字符串剩下的部分。我一开始就是想的这么简单，结果提交之后超时了。我一看检测用例：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">最后执行的输入：</span><br><span class="line"><span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"</span> [<span class="string">"a"</span>,<span class="string">"aa"</span>,<span class="string">"aaa"</span>,<span class="string">"aaaa"</span>,<span class="string">"aaaaa"</span>,<span class="string">"aaaaaa"</span>,<span class="string">"aaaaaaa"</span>,<span class="string">"aaaaaaaa"</span>,<span class="string">"aaaaaaaaa"</span>,<span class="string">"aaaaaaaaaa"</span>]</span><br><span class="line">状态：超出时间限制</span><br></pre></td></tr></table></figure>
<p>很想对检测员说“f**k you”。于是检查了一下递归树，确实发现了许多冗余的递归分支，这个时候就需要剪枝了。由于发生冗余分支的原因是对于很多相同的后缀都分别进行了递归，事实上进行了第一次就能知道这个后缀是否能够成功拆分，因此在原来的回溯法上，额外添加了一个状态数组来记录从某个位置开始的后缀无法拆分，就可以直接返回false了，就省了一个递归树的时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; memo;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;dict = <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;(wordDict.begin(),wordDict.end());</span><br><span class="line">        <span class="keyword">this</span>-&gt;memo = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.size(),<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = s;</span><br><span class="line">        <span class="keyword">return</span> candivied(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">candivied</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == str.size())<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!memo[start])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(start);i&lt;str.size();i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = str.substr(start,i-start+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(dict.find(tmp)!=dict.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(candivied(i+<span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                memo[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-138-复制带随机指针的链表</title>
    <url>/2020/04/25/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。</p>
<p>每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
<li>-10000 &lt;= Node.val &lt;= 10000</li>
<li>Node.random为空（null）或指向链表中的节点。</li>
<li>节点数目不超过 1000 。</li>
</ul>
<a id="more"></a>
<hr>
<p>这道题的核心是找到new出来的节点所对应的random节点。使用键值对的方法可以很方便地找到原节点与新节点之间的关系，从而也很容易找到新节点的random节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;Node*,Node*&gt; dict;</span><br><span class="line">        Node* i = head,*newhead = <span class="keyword">new</span> Node(<span class="number">99999</span>);</span><br><span class="line">        <span class="keyword">for</span>(Node* j = newhead;i;i = i-&gt;next)&#123;</span><br><span class="line">            j-&gt;next = <span class="keyword">new</span> Node(i-&gt;val);</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">            dict.insert(make_pair(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = head;i;i = i-&gt;next)</span><br><span class="line">            <span class="keyword">if</span>(i-&gt;random)</span><br><span class="line">                dict[i]-&gt;random = dict[i-&gt;random];</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-137-只出现一次的数字II</title>
    <url>/2020/04/24/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97II/</url>
    <content><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br><a id="more"></a></p>
<hr>
<p>空间复杂度为$O(n)$的方法是用集合来存储数组中所有的数，集合中所有数的和set_sum与数组中所有数的和vector_sum应该满足如下关系：$vector_sum=3<em>set_sum-2</em>answer$，因此遍历数组一次即可求出只出现过一次的数字。</p>
<p>还有空间复杂度为$O(1)$的方法。回想上一题的条件，在一堆出现了两次的数字中寻找只出现一次的数字，只需要用一个未知数，每一位用来表示该位在数组中出现的次数，因为一共就两种状态，出现一次，然后出现第二次清零，所以用一个未知数就能够记录。那么对于现在这题，一个未知数显然是不够的，它的状态转移图应该是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">x</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
<p>经过运算可以得出代码形式的状态转移方程为：</p>
<script type="math/tex; mode=display">
            b = (b⊕x)\overline{a}\\
            a = (a⊕x)\overline{b}</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            b = (b ^ x) &amp; ~a;</span><br><span class="line">            a = (a ^ x) &amp; ~b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-134-加油站</title>
    <url>/2020/04/23/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    <content><![CDATA[<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。<br>说明: </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。<br>示例 :<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">cost = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从 <span class="number">3</span> 号加油站(索引为 <span class="number">3</span> 处)出发，可获得 <span class="number">4</span> 升汽油。此时油箱有 = <span class="number">0</span> + <span class="number">4</span> = <span class="number">4</span> 升汽油</span><br><span class="line">开往 <span class="number">4</span> 号加油站，此时油箱有 <span class="number">4</span> - <span class="number">1</span> + <span class="number">5</span> = <span class="number">8</span> 升汽油</span><br><span class="line">开往 <span class="number">0</span> 号加油站，此时油箱有 <span class="number">8</span> - <span class="number">2</span> + <span class="number">1</span> = <span class="number">7</span> 升汽油</span><br><span class="line">开往 <span class="number">1</span> 号加油站，此时油箱有 <span class="number">7</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">6</span> 升汽油</span><br><span class="line">开往 <span class="number">2</span> 号加油站，此时油箱有 <span class="number">6</span> - <span class="number">4</span> + <span class="number">3</span> = <span class="number">5</span> 升汽油</span><br><span class="line">开往 <span class="number">3</span> 号加油站，你需要消耗 <span class="number">5</span> 升汽油，正好足够你返回到 <span class="number">3</span> 号加油站。</span><br><span class="line">因此，<span class="number">3</span> 可为起始索引。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<hr>
<p>这道题很容易想到时间复杂度为$O(n^2)$的暴力搜索方法，但其实可以用将其降至$O(n)$。</p>
<ul>
<li>由于所有的耗油量与油量都已经在数组中给出，可以确定的是，如果总油量大于总消耗量，是肯定存在一个起始点能够满足让车跑满一圈的。</li>
<li>再考虑遍历的过程，用sum来记录总油量和总消耗量之间的关系，用cur来记录从定好的起始点开始车内油量与耗油量的关系，需要满足的条件是车内的油量要时刻大于等于0。</li>
<li>当发现车内油量小于0时，可以得出目前定的起始点是不符合条件的，另外也可发现途中的点均不能作为起始点。因为在此前的计算中，途中的cur值始终大于0，而现在刚好小于0，那么从途中任何点出发都是无法到达当前点的。所以可以直接将起始点定为下一点。</li>
<li>遍历结束之后便可以算得总油量与总耗油量之间的差值，如果这个差值小于0就可以返回-1，不存在满足要求的起始点，否则，start就是需要寻找的起始点。</li>
<li>只需从头到尾遍历一遍的原因是，从任何一点希望跑一圈回到自身都可以抽象为跑到另一个点，再跑回来，所以要比较的只是到达另一个点的总油量是否能支持再跑回来而已。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        int sum(0),start(0);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>),cur(<span class="number">0</span>);i&lt;gas.size();i++)&#123;</span><br><span class="line">            cur+=gas[i]-cost[i];</span><br><span class="line">            sum+=gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum&lt;<span class="number">0</span>?<span class="number">-1</span>:start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-131-分割回文串</title>
    <url>/2020/04/21/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。返回 <em>s</em> 所有可能的分割方案。</p>
<p><strong>示例:</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"aab"</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"aa"</span>,<span class="string">"b"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>这道题原本想用动态规划，即首先可以确认将s拆成单个字符会是一个回文串序列，在此基础上，如果一个回文串的两边互为回文串，那么三个回文串可以组成一个新回文串，如果两个回文串相等，那么这两个回文串可以组成一个新的回文串。但感觉这个方法实操起来很麻烦。因此我还是选择了万能的回溯法。</p>
<p>递归树的第一层始终是s的前缀回文串，在此基础上在剩下的部分继续找。还是和普通的回溯方法大同小异的。另外还需要一个函数来判断子串是否为回文串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">2</span>)<span class="keyword">return</span> &#123;&#123;s&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">        dfs(s,tmp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tmp,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=s.size())&#123;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(start);i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> str = s.substr(start,i-start+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(isPlalindrome(str))&#123;</span><br><span class="line">                tmp.push_back(str);</span><br><span class="line">                dfs(s,tmp,i+<span class="number">1</span>);</span><br><span class="line">                tmp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPlalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>),j(s.size()<span class="number">-1</span>);i&lt;=j;)</span><br><span class="line">            <span class="keyword">if</span>(s[i++] != s[j--])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-136-只出现一次的数字</title>
    <url>/2020/04/20/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<a id="more"></a>
<hr>
<p>奇技淫巧(异或运算)：</p>
<script type="math/tex; mode=display">
0⊕N=N;\\
N⊕N=0;\\
A⊕B⊕C=C⊕A⊕B</script><p>基于上述的异或的特性，可将数组中所有元素进行异或运算，由于异或运算满足交换律，所以所有成对的元素会消失，最后结果只剩下落单的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nums)res^=i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-130-被围绕的区域</title>
    <url>/2020/04/19/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。<br>示例:<br><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> O O <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> <span class="meta">X</span> O <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> O <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line">运行你的函数后，矩阵变为：</span><br><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span> <span class="meta">X</span></span><br><span class="line"><span class="meta">X</span> O <span class="meta">X</span> <span class="meta">X</span></span><br></pre></td></tr></table></figure><br>解释:<br>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<br><a id="more"></a></p>
<hr>
<p>根据题意提炼出的条件是，所有与矩阵边界上的’O’连通的’O’都维持原样不变，而其它的所有’O’变为’X’。</p>
<ul>
<li>首先是排除特殊条件，若矩阵的行数或列数小于3，则不存在包围的情况，直接返回。</li>
<li>对矩阵的边界进行遍历，若边界值为’O’，对其进行深度优先搜索，找出所有与其连通的’O’，并将其置为’V’，以便和其它要变’X’的’O’区分。</li>
<li>遍历完边界之后首先将所有的’O’变为’X’，再将所有的’V’变为’O’。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dir&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.size()&lt;<span class="number">3</span>||board[<span class="number">0</span>].size()&lt;<span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>),j(<span class="number">0</span>);;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>)dfs(i,j,board);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>&amp;&amp;j&lt;board[<span class="number">0</span>].size()<span class="number">-1</span>)j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == board.size()<span class="number">-1</span>&amp;&amp;j&gt;<span class="number">0</span>)j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>&amp;&amp;i&gt;<span class="number">0</span>)i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == board[<span class="number">0</span>].size()<span class="number">-1</span>&amp;&amp;i&lt;board.size()<span class="number">-1</span>)i++;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>&amp;&amp;j == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;board.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;board[<span class="number">0</span>].size();j++)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;board.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;board[<span class="number">0</span>].size();j++)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'V'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; mat)</span></span>&#123;</span><br><span class="line">        mat[i][j] = <span class="string">'V'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k(<span class="number">0</span>);k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            int x(i + dir[k][0]),y(j + dir[k][1]);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;mat.size()&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;mat[<span class="number">0</span>].size()&amp;&amp;mat[x][y] == <span class="string">'O'</span>)</span><br><span class="line">                dfs(x,y,mat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-129-求根到叶子节点数字之和</title>
    <url>/2020/04/18/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="number">4</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>   <span class="number">0</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">5</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">1026</span></span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">5</span> 代表数字 <span class="number">495.</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">9</span>-&gt;<span class="number">1</span> 代表数字 <span class="number">491.</span></span><br><span class="line">从根到叶子节点路径 <span class="number">4</span>-&gt;<span class="number">0</span> 代表数字 <span class="number">40.</span></span><br><span class="line">因此，数字总和 = <span class="number">495</span> + <span class="number">491</span> + <span class="number">40</span> = <span class="number">1026.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<p>递归的思想：</p>
<ul>
<li>如果根节点为空，则返回0。</li>
<li>如果根节点非空，左右节点均为空，则返回以往祖先节点组成的数字乘以10再加上自身节点的值。</li>
<li>如果至少有一个子节点非空，则返回以往祖先组成的数字乘以10加上左子树的值，右子树同理。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)<span class="keyword">return</span> <span class="number">10</span>*sum + root-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dfs(root-&gt;left,<span class="number">10</span>*sum + root-&gt;val) + dfs(root-&gt;right,<span class="number">10</span>*sum + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-127-单词接龙</title>
    <url>/2020/04/17/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    <content><![CDATA[<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p>说明:</p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</li>
</ul>
<p>示例 :</p>
<blockquote>
<p>输入:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>输出: 5<br>解释: 一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,返回它的长度 5。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>这是一道比较经典的适用于广度优先搜索的题。首先根据题意，首尾两个单词以及字典中的每个单词可根据它们之间相差一个字母做一个预处理，为了建立起一段路径两端的单词之间的关系。例如，可以用d<em>t来代表dot和dog，意思是如果改变中间的那个字母，有dot和dog这两个单词可以作为下一个单词。因此这种关系可以用一个哈希表来存储，将类似d\</em>t这种通式作为键，值为所有满足这个通式的一个字符串数组。</p>
<p>经过预处理之后将会更便于处理两个节点之间的关系。为了进行广度优先遍历，还需要一个由元组组成的队列，元组来存储单词以及其对应的遍历层数，因为广度优先搜索来寻找最短路径的结果就是匹配成功时的遍历层数。另外还要一个集合来存储字典中每个单词的访问情况，以免多次访问同一个单词。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; dict;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt; visit;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">int</span> len = beginWord.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:wordList)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;len;j++)&#123;</span><br><span class="line">                <span class="built_in">string</span> tmp = i;</span><br><span class="line">                tmp[j] = <span class="string">'*'</span>;</span><br><span class="line">                dict[tmp].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            visit.insert(make_pair(i,<span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        que.push(make_pair(beginWord,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cur = que.front();</span><br><span class="line">            <span class="keyword">if</span>(cur.first == endWord)<span class="keyword">return</span> cur.second;</span><br><span class="line">            que.pop();</span><br><span class="line">            visit[cur.first] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;len;i++)&#123;</span><br><span class="line">                <span class="built_in">string</span> tmp = cur.first;</span><br><span class="line">                tmp[i] = <span class="string">'*'</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:dict[tmp])</span><br><span class="line">                    <span class="keyword">if</span>(!visit[j])</span><br><span class="line">                        que.push(make_pair(j,cur.second+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-120-三角形最小路径和</title>
    <url>/2020/04/16/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p>
<p><strong>说明：</strong></p>
<p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<a id="more"></a>
<hr>
<p>这道题用很显然是动态规划的一类题，如果用自上而下的方法，除了要用一个数组来记录当前行的所有元素作为终点的路径长度，还要有一个数组来保存上一行的结果，因为当前行所有元素的路径长度依赖于上一行。但其实用自下而上的递归方法会更简单，甚至可以在原数组上进行运算，时间复杂度为$O(n^2)$，没有用额外的辅助空间，空间复杂度为$O(1)$。可以直接从倒数第二行开始考虑：</p>
<ul>
<li>对每一行每一个元素，它的下一个元素的选择只有两个，那么将小的那个加到当前元素上，对整行元素做这个操作。之后对所有行做此操作，最后整个数组第一个元素就是路径和最小的元素。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(triangle.size()<span class="number">-2</span>);i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;triangle[i].size();j++)</span><br><span class="line">                triangle[i][j]+=min(triangle[i+<span class="number">1</span>][j],triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实自上而下的动态规划想起来确实有些复杂，所以以后遇到这种情况，不妨换一个方向，也许会豁然开朗。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-117-填充每个节点的下一个右侧节点指针II</title>
    <url>/2020/04/15/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/</url>
    <content><![CDATA[<p>给定一个二叉树:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。</p>
<image src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png">

<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<a id="more"></a>
<hr>
<p>这题没有上一题那么理想，所以如果还是套用上一题的想法会有很多出错的地方。思路如下：</p>
<ul>
<li>如果根节点非空，并且左右子树至少有一个非空，做如下判断：<ol>
<li>如果根节点左右孩子都非空，将右孩子连到左孩子上。</li>
<li>现在确定当前节点需要连向堂兄弟节点的孩子，如果右孩子非空，那么就是右孩子，否则就是左孩子。</li>
<li>然后通过根节点的已经连好的线去寻找兄弟或堂兄弟，直到找到第一个至少左右孩子之一非空的(堂)兄弟。</li>
<li>上述步骤如果找到了符合条件的节点，需要确定被连线的孩子，如果左孩子非空那就是左孩子，否则是右孩子。如果没有找到符合条件的节点，那么被连线的应为空。</li>
<li>确定好了需要连线的孩子和被连线的节点，将它们相连。</li>
<li>再分别对左孩子和右孩子重复上述步骤。</li>
</ol>
</li>
<li>如果根节点为空或者左右子树都为空，则返回根节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root&amp;&amp;(root-&gt;left||root-&gt;right))&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right) root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">            Node *node = root-&gt;right ? root-&gt;right : root-&gt;left;</span><br><span class="line">            Node *head = root-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (head&amp;&amp;!(head-&gt;left||head-&gt;right))</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            node-&gt;next = head ? (head-&gt;left ? head-&gt;left : head-&gt;right) : <span class="literal">NULL</span>;</span><br><span class="line">            connect(root-&gt;right);</span><br><span class="line">            connect(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-116-填充每个节点的下一个右侧节点指针</title>
    <url>/2020/04/15/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。</p>
<p><image src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png"><br><strong>提示：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<a id="more"></a>
</li>
</ul>
<hr>
<p>很容易想到再递归每个父节点的时候需要将其左孩子连向右孩子，但问题是如何将右孩子连向同一层的下一个节点呢。这时候可以利用当前曾已经连好了的路径，可以直接找到当前节点的右兄弟节点，它的左孩子就是我们当前节点右孩子所要找的下一个节点。当然这题不用递归也可以，要用双指针，一个指针用来记录每一层的起始位置，另一个指针用来通过之前连好的堂兄弟将它们的孩子连接。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||!root-&gt;left)<span class="keyword">return</span> root;</span><br><span class="line">        root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;next)</span><br><span class="line">            root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-114-二叉树展开为链表</title>
    <url>/2020/04/14/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给定一个二叉树，原地将它展开为链表。<br><a id="more"></a></p>
<hr>
<p>这题感觉题目不太明确，展开方法那么多。看了几个测试用例，这道题的规则应该是将二叉树的先序遍历序列原地表示为二叉树，所有的子节点均为父节点的右孩子。</p>
<p>规则清晰了之后就好做了。</p>
<ul>
<li>由于要按照先序遍历是顺序，那么任何节点的连接顺序应该是父节点连左孩子，然后左孩子的最右子孙连原父节点的右孩子。</li>
<li>定义两个指针，一个指针沿着右孩子路径依次扫描是否需要将左孩子插入。在需要将左孩子插入的情况下，用另一个指针来查找左孩子的最右子孙，用来连接原父节点的右孩子。</li>
<li>扫描指针扫到底就结束了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TreeNode* p(root);p;p = p-&gt;right)</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">                TreeNode* q(p-&gt;left),*tmp(p-&gt;right);</span><br><span class="line">                <span class="keyword">while</span>(q-&gt;right)</span><br><span class="line">                    q = q-&gt;right;</span><br><span class="line">                p-&gt;right = p-&gt;left;</span><br><span class="line">                p-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                q-&gt;right = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-113-路经总和II</title>
    <url>/2020/04/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-113-%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<a id="more"></a>
<hr>
<p>这是一个很形象的回溯问题，而且树都已经是现成的，而且深度优先一次到底。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        dfs(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">queue</span>.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;sum==root-&gt;val)</span><br><span class="line">            res.push_back(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root-&gt;left, sum-root-&gt;val);</span><br><span class="line">            dfs(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-112-路经总和</title>
    <url>/2020/04/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-112-%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<a id="more"></a>
<hr>
<p>给出判断是否存在和为指定sum的路径：</p>
<ul>
<li>如果根节点为空，那么就不存在。</li>
<li>如果根节点非空，但左右子树都为空，那么就看根节点的值是否等于sum，是就存在，否则不存在。</li>
<li>如果根节点非空，左右子树存在一个或都存在，那么就看左子树或者右子树是否存在和为sum-根节点值的路径。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> !root-&gt;left&amp;&amp;!root-&gt;right?sum==root-&gt;val:hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-111-二叉树的最小深度</title>
    <url>/2020/04/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<a id="more"></a>
<hr>
<p>给出一个二叉树的最小深度的表达式：</p>
<ul>
<li>如果二叉树的根节点为空，则最小深度为0</li>
<li>如果二叉树的根节点非空，左右子树都非空，最小深度为左右子树的最小深度的较小者+1。</li>
<li>如果二叉树的根节点非空，左子树非空右子树为空，最小深度为左子树的最小深度+1。</li>
<li>如果二叉树的根节点非空，左子树为空，最小深度为右子树的最小深度+1。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left&amp;&amp;root-&gt;right)<span class="keyword">return</span> min(minDepth(root-&gt;left),minDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root-&gt;left?minDepth(root-&gt;left)+<span class="number">1</span>:minDepth(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-110-平衡二叉树</title>
    <url>/2020/04/12/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<a id="more"></a>
<hr>
<p>给出一棵树为平衡二叉树的条件：</p>
<ul>
<li>根节点为空</li>
<li>根节点不为空，左右子树高度差小于2，左右子树均为平衡二叉树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root?<span class="built_in">abs</span>(height(root-&gt;left)-height(root-&gt;right))&lt;<span class="number">2</span>&amp;&amp;isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right):<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root?<span class="number">1</span> + max(height(root-&gt;left),height(root-&gt;right)):<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-109-有序链表转换二叉搜索树</title>
    <url>/2020/04/12/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<a id="more"></a>
<hr>
<p>用分治法来解这道题，归根结底就是要寻找中点，然后将链表分割为两部分。那就可以用快慢指针了，每次慢指针走一步，快指针走两步。快指针走到终点的时候慢指针就能走到中点了。还要保存慢指针的前一个节点，便于分割单链表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!head-&gt;next) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">        ListNode *pre(head),*p(pre-&gt;next),*q(p-&gt;next);</span><br><span class="line">        <span class="keyword">while</span>(q &amp;&amp; q-&gt;next)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(p-&gt;val);</span><br><span class="line">        root-&gt;left = sortedListToBST(head);</span><br><span class="line">        root-&gt;right = sortedListToBST(p-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-108-将有序数组转换为二叉搜索树</title>
    <url>/2020/04/11/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<a id="more"></a>
<hr>
<p>采用分治的思想，对于给定的序列首先确定中位数为根节点，接着根节点的左边组成的左子树也应该是一颗二叉搜索树，根节点的右边也应该是一颗二叉搜索树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> rootindex = (start + end)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[rootindex]);</span><br><span class="line">        root-&gt;left = build(start,rootindex<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = build(rootindex+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-107-二叉树的层次遍历II</title>
    <url>/2020/04/11/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86II/</url>
    <content><![CDATA[<p>给定一个二叉树，返回其节点值<strong>自底向上</strong>的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<a id="more"></a>
<p>这里要求返回自底向上的层次，那么这次我采用的是基于深度优先搜索的遍历，遍历顺序实际上是先序，但是按照层次填入相应数组的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="keyword">int</span> <span class="built_in">floor</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;<span class="built_in">floor</span>+<span class="number">1</span>)res.push_back(&#123;root-&gt;val&#125;);</span><br><span class="line">        <span class="keyword">else</span> res[<span class="built_in">floor</span>].push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left,<span class="built_in">floor</span>+<span class="number">1</span>);</span><br><span class="line">        dfs(root-&gt;right,<span class="built_in">floor</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-105-从中序与后序遍历序列构造二叉树</title>
    <url>/2020/04/10/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-105-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<a id="more"></a>
<hr>
<p>在上一题的基础上做了改进，采用哈希表来存储索引，并且在序列中原地操作。效率大大提高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; indict,postdict;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder,postorder;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.size()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;inorder = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(inorder.begin(),inorder.end());</span><br><span class="line">        <span class="keyword">this</span>-&gt;postorder = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(postorder.begin(),postorder.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;inorder.size();i++)&#123;</span><br><span class="line">            indict.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(inorder[i],i));</span><br><span class="line">            postdict.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(postorder[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(<span class="number">0</span>,inorder.size()<span class="number">-1</span>,<span class="number">0</span>,postorder.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="keyword">int</span> instart,<span class="keyword">int</span> inend,<span class="keyword">int</span> poststart,<span class="keyword">int</span> postend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instart==inend)<span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[instart]);</span><br><span class="line">        TreeNode* head = <span class="keyword">new</span> TreeNode(postorder[postend]);</span><br><span class="line">        <span class="keyword">int</span> *inleftend,*postleftend;</span><br><span class="line">        <span class="keyword">int</span> headindex = indict[head-&gt;val];</span><br><span class="line">        <span class="keyword">if</span>(headindex--&gt;instart)&#123;</span><br><span class="line">            inleftend = &amp;headindex;</span><br><span class="line">            postleftend = <span class="keyword">new</span> <span class="keyword">int</span>(poststart + headindex - instart);</span><br><span class="line">            head-&gt;left = build(instart,*inleftend,poststart,*postleftend);</span><br><span class="line">            <span class="keyword">if</span>(++headindex != inend)head-&gt;right = build(headindex+<span class="number">1</span>,inend,*postleftend+<span class="number">1</span>,postend<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> head-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">delete</span> postleftend;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>(++headindex != inend)head-&gt;right = build(instart+<span class="number">1</span>,inend,poststart,postend<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> head-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-105-从前序与中序遍历序列构造二叉树</title>
    <url>/2020/04/09/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<a id="more"></a>
<hr>
<p>原理很简单，由先序序列可以确定根节点的值，并在中序序列中找到根节点之后，前面部分为左子树的中序序列，后面部分为右子树的中序序列，再根据这两个部分在先序序列中找到左子树的先序序列和右子树的先序序列，再将它们分别作为函数参数求得左右子树，并与根节点连接。递归终止条件为参数中的序列长度为0。</p>
<p>不过像我这样分别求左右子树的先序和中序序列的效率是十分低下的，当然可以直接用索引在原序列上操作，得出各个子序列的起始和终止位置，甚至还可以用基于键值对的散列表来存储原始序列，大大缩短查找的时间。但我主要还是想把所有的语句写在给定的函数里，并且这样思路很清晰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leftTree_inorder,rightTree_inorder,leftTree_preorder,rightTree_preorder;</span><br><span class="line">        TreeNode *head = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> *leftend = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;inorder.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]!=preorder[<span class="number">0</span>]&amp;&amp;leftTree_inorder.size()==i)&#123;</span><br><span class="line">                leftTree_inorder.push_back(inorder[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(inorder[i]!=preorder[<span class="number">0</span>]&amp;&amp;leftTree_inorder.size()&lt;i)&#123;</span><br><span class="line">                rightTree_inorder.push_back(inorder[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(inorder[i]==preorder[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)leftend = &amp;inorder[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i&lt;preorder.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftTree_preorder.size()&lt;leftTree_inorder.size())&#123;</span><br><span class="line">                leftTree_preorder.push_back(preorder[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(leftend == <span class="literal">NULL</span> || preorder[i]!=*leftend&amp;&amp;leftTree_preorder.size()==leftTree_inorder.size())&#123;</span><br><span class="line">                rightTree_preorder.push_back(preorder[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;left = buildTree(leftTree_preorder,leftTree_inorder);</span><br><span class="line">        head-&gt;right = buildTree(rightTree_preorder,rightTree_inorder);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-125-验证回文串</title>
    <url>/2020/04/08/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例：</p>
<blockquote>
<p>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>输入: “race a car”<br>输出: false</p>
</blockquote>
<a id="more"></a>
<hr>
<p>双指针一边比较一边往中间靠，顺便了解几个库函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        int i(0),j(s.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[i]))&#123;i++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[j]))&#123;j--;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[i++])!=<span class="built_in">tolower</span>(s[j--]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-103-二叉树的锯齿形层次遍历</title>
    <url>/2020/04/07/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<a id="more"></a>
<hr>
<p>这题在上一题的基础上增加了输出条件，就是每一层的输出顺序要相反。那么在这里就增加了一个odd来记录当前是奇数层还是偶数层，如果当前层号是奇数，那么从队尾取节点作为当前节点，并依次将右节点，左节点插入队首，否则从队首取节点作为当前节点，并以此将左节点，右节点插入队尾。知道队列为空为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode* &gt; <span class="built_in">queue</span>;</span><br><span class="line">        int floor(1),nextfloor(0);</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">odd</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(root)<span class="built_in">queue</span>.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(odd)&#123;</span><br><span class="line">                <span class="function">TreeNode* <span class="title">cur</span><span class="params">(<span class="built_in">queue</span>.front())</span></span>;</span><br><span class="line">                <span class="built_in">queue</span>.pop_front();</span><br><span class="line">                tmp.push_back(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push_back(cur-&gt;left);</span><br><span class="line">                    nextfloor++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push_back(cur-&gt;right);</span><br><span class="line">                    nextfloor++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* cur(<span class="built_in">queue</span>.back());</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">                tmp.push_back(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push_front(cur-&gt;right);</span><br><span class="line">                    nextfloor++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                    <span class="built_in">queue</span>.push_front(cur-&gt;left);</span><br><span class="line">                    nextfloor++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.size()==<span class="built_in">floor</span>)&#123;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">                <span class="built_in">floor</span> = nextfloor;</span><br><span class="line">                nextfloor = <span class="number">0</span>;</span><br><span class="line">                odd = !odd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-102-二叉树的层序遍历</title>
    <url>/2020/04/07/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<a id="more"></a>
<p>二叉树的层序遍历，用队列来完成。如下操作：</p>
<ol>
<li><p>如果根节点非空，将根节点入队</p>
</li>
<li><p>如果队列非空，取出队列头节点，对其访问，再将其左右节点(如果有)入队。</p>
</li>
<li>如果队列为空，则完成遍历。</li>
</ol>
<p>但注意到这道题的返回值为vector<vector\<int\>&gt;类型，意思是说二叉树的每一层之间需要分开存储到每一个向量中。那么就需要对每一层的节点数量进行记录，那么我这里是用floor来记录当前层的节点数，nextfloor来记录下一层的节点数。每一次访问完元素都进行判断当前的向量中的元素数量是否等于floor，若是，则将该向量压入结果，并将向量清空，将nextfloor的值赋给floor，nextfloor清零重新计数。否则继续循环。floor初值为1，nextfloor初值为0，每当向队列中加入一个节点，nextfloor加一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">deque</span>&lt;TreeNode* &gt; <span class="built_in">queue</span>;</span><br><span class="line">        int floor(1),nextfloor(0);</span><br><span class="line">        <span class="keyword">if</span>(root)<span class="built_in">queue</span>.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())&#123;</span><br><span class="line">            <span class="function">TreeNode* <span class="title">cur</span><span class="params">(<span class="built_in">queue</span>.front())</span></span>;</span><br><span class="line">            <span class="built_in">queue</span>.pop_front();</span><br><span class="line">            tmp.push_back(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(cur-&gt;left);</span><br><span class="line">                nextfloor++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(cur-&gt;right);</span><br><span class="line">                nextfloor++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.size()==<span class="built_in">floor</span>)&#123;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">                tmp.clear();</span><br><span class="line">                <span class="built_in">floor</span> = nextfloor;</span><br><span class="line">                nextfloor = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-101-对称二叉树</title>
    <url>/2020/04/06/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><strong>说明:</strong></p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<a id="more"></a>
<hr>
<p>递归的方法还是很简单的，可以把这个问题转化为判断一棵树的左右子树是否“相等”，只不过这里的两棵树相等要求的是对于任意子树左子树根节点的值等于右子树根节点的值。所以就可以直接套用上一题的模板，改变一下判断条件即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isequal(root,root);</span><br><span class="line">        <span class="comment">//return !root||isequal(root-&gt;left,root-&gt;right);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isequal</span><span class="params">(TreeNode* p,TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;!q)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p&amp;&amp;q&amp;&amp;p-&gt;val==q-&gt;val&amp;&amp;isequal(p-&gt;left,q-&gt;right)&amp;&amp;isequal(p-&gt;right,q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代的思想，用到了队列，相当于层序遍历。用两个指针来代表根节点的左右子树的节点，入队顺序为左子树指针的左节点，右子树指针的右节点，左子树指针的右节点，右子树指针的左节点，则如果该树对称，在每次出队两个节点的时候，这两个相邻的节点值必相等，否则就不对称。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;         </span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            TreeNode* t1 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* t2 = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t1 &amp;&amp; !t2)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!t1 || !t2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(t1-&gt;val != t2-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.push(t1-&gt;left);</span><br><span class="line">            q.push(t2-&gt;right);</span><br><span class="line">            q.push(t1-&gt;right);</span><br><span class="line">            q.push(t2-&gt;left);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-100-相同的树</title>
    <url>/2020/04/06/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p>给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<a id="more"></a>
<hr>
<p>用递归的思想。</p>
<ul>
<li>首先如果两树都为空，那么两树相等</li>
<li>否则当且仅当两树都不为空，两树的根节点相等，两树的左子树相等，两树的右子树相等时两树相等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p&amp;&amp;!q)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p&amp;&amp;q&amp;&amp;p-&gt;val==q-&gt;val&amp;&amp;isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-98-验证二叉搜索树</title>
    <url>/2020/04/05/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<a id="more"></a>
<hr>
<p>这里用递归来解，整个框架其实就是中序遍历，然后一边遍历一遍比较前后两位数的大小关系，一旦发现不符合二叉搜索树的规定就终止递归，并返回。最开始我其实用的是一个整型变量来保存中序遍历顺序的上一个值，在递归开始的时候这个值应该是空的，但是当根节点为0的时候，对于上一个值为空的情况会发生异常，因为0的真值和NULL是一样的，所以始终没有去做根节点的比较。所以解决办法是用指针来存上一个数，这样的话就避免了NULL值的歧义性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;left))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (pre&amp;&amp;*pre&gt;=root-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre=&amp;root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!isValidBST(root-&gt;right))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-95-不同的二叉搜索树II</title>
    <url>/2020/04/05/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</url>
    <content><![CDATA[<p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的<strong>二叉搜索树</strong>。</p>
<a id="more"></a>
<hr>
<p>这道题的递归思想很巧妙，遍历整个序列，对每一个元素作为根节点的时候，分别对它的左边序列和右边序列求一次所有节点组成的二叉搜索树，得到两个序列，再遍历这两个序列使得它们中的元素两两组合，分别插入作为根节点的左子树和右子树。终止条件是节点的范围的开始元素大于结束元素的时候。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)<span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> gen(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">gen</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n(start); n&lt;=end; n++) &#123;</span><br><span class="line">            auto left(gen(start, n-1)), right(gen(n+1, end));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:left) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> j:right) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> node = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">                    node-&gt;left = i;</span><br><span class="line">                    node-&gt;right = j;</span><br><span class="line">                    res.push_back(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>卡特兰数的应用</title>
    <url>/2020/04/04/algorithms/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>卡特兰数(Catalan number)是组合数学中一个常出现在各种计数问题的数列，它的前几项为：</p>
<blockquote>
<p>$1,1,2,5,14,42,132,429,1430,4862,16796…$</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>卡特兰数的定义式：</li>
</ul>
<script type="math/tex; mode=display">
Catalan(n)=\begin{cases}1,n=0;\\\\\sum^{n-1}_{i=0}Catalan(i)*Catalan(n-1-i),n>0
\end{cases}</script><ul>
<li>采用数学方法可得其通项解为:</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
Catalan(n)&=C^n_{2n}-C^{n+1}_{2n},将其化简得\\
&=\frac{1}{n+1}C^n_{2n}
\end{align}</script><ul>
<li>由此可推出其递推式：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
Catalan(n+1)&=\frac{1}{n+2}C^{n+1}_{2n+2}\\
&=\frac{1}{n+2}\frac{(2n+2)(2n+1)\cdot\cdot\cdot(n+3)(n+2)}{(n+1)!}\\
&=\frac{(2n+2)(2n+1)\cdot\cdot\cdot(n+3)}{(n+1)n!}\\
&=\frac{(2n+2)(2n+1)}{(n+2)(n+1)}\frac{2n(2n-1)\cdot\cdot\cdot(n+3)(n+2)(n+1)}{(n+1)n!}\\
&=\frac{(2n+2)(2n+1)}{(n+2)(n+1)}Catalan(n)\\
&=\frac{4n+2}{n+2}Catalan(n)
\end{align}</script><hr>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="出栈序列个数问题"><a href="#出栈序列个数问题" class="headerlink" title="出栈序列个数问题"></a>出栈序列个数问题</h2><p>问题：有一个容量足够大的栈，n个元素以一定的顺序入栈，出栈顺序有多少种？</p>
<p>这个问题最开始遇到是在学数据结构栈的时候，要求手动去推导n个元素的出栈序列数。但没想到这会与后来遇到的卡特兰数关系如此紧密。</p>
<h3 id="通项解"><a href="#通项解" class="headerlink" title="通项解"></a>通项解</h3><p>为了找到这个问题的一个通解，可以做以下考虑：</p>
<ul>
<li>对于一个长度为$n$的序列，每个元素的入栈记为$+1$，每个元素的出栈记为$-1$。</li>
<li>那么将所有的$+1-1$进行组合，可以得到组合数$C^n_{2n}$，但难道这就是所谓的出栈序列个数吗，答案当然是否定的。</li>
<li>我们少考虑了栈空却仍然出栈的这种异常操作，根据我们指定的以上规则，在任何时候所有以往$+1-1$的总数不能小于0。因此我们可以在进行枚举的每一个元素出栈序列的时候进行记录，第一次发现此时之前的总数等于$-1$，可以知道当前序列是违规序列，那么将包括当前元素的出栈操作以及之前所有的出栈入栈操作进行取相反数，即$+1$变$-1$，$-1$变$+1$，这样可以得到一个新的序列，并且这个序列对于刚才遇到的违规序列映射是双射的。</li>
<li>换句话说，每个第一次发现总和等于$-1$的序列都能够唯一对应一个具有$n+1$个$+1$，$n-1$个$-1$的新序列，那么将这个序列算组合数就是$C^{n+1}_{2n}$，这个数就是所有违规序列的总数。</li>
<li>所以符合条件的出栈序列数应该是总序列数减违规序列数，即$C^n_{2n}-C^{n+1}_{2n}$。</li>
<li>很容易发现，这个式子就是卡特兰数的通项形式。</li>
</ul>
<h3 id="动态规划解"><a href="#动态规划解" class="headerlink" title="动态规划解"></a>动态规划解</h3><p>对于一个长度为n的入栈序列，我们要求的解是$f(n)$考虑数列中的某一个元素x的一种特定情况，就是它出栈的时候，可以肯定的是，在排在$x$之前的所有元素都已经确保入栈成功了(不一定已经出栈，可能还在栈中)，并且排在这个元素后面的所有元素都已经确保出栈成功了。</p>
<ul>
<li>对于$x$之前的入栈成功的元素，它们的出栈顺序肯定是唯一的，但是它们的入栈顺序可以有多种，这个问题就变成了，已知一段序列一种出栈顺序，求这段序列可能的入栈顺序。这个子问题和父问题构成了反函数的关系，并且是一一对应的，那么当然可以套用解原来问题的方法。假设$x$之前有$x-1$个元素，那么我们想知道$f(x-1)$是多少。</li>
<li>对于$x$之后已经出栈的元素，我们可以知道，它们的入栈肯定是在x及之前的元素之后，出栈肯定是在$x$及之前的元素之前，由此可以发现后面假设是$n-1-x$个元素，它们的出栈的组合完全与之前的元素没有任何关系。那么我们想知道对于后面这些元素$f(n-1-x)$的解。</li>
<li>如果我们同时知道了$f(x-1)$和$f(n-1-x)$，就等于知道了对于$x$的出栈的这种情况，有$f(x-1)*f(n-1-x)$种组合。</li>
<li>$x$作为长度为n序列中的任意一个元素，我们如果知道对于每一个$x$，可以对他们进行求和，由此可以得到$f(n)$的一般解为$\sum^{n-1}_{i=0}f(i)*f(n-i-1)$。</li>
<li>当$n$为0时，它不存在出栈序列，可以理解为它只有一种出栈序列，那就是不存在。当$n$为1时，显然出栈序列只有一种，以此类推，通过一般式可以推$n$为出任一项的解。</li>
<li>这时又能发现，我们解出来的$f(n)$就是卡特兰数的定义式。</li>
</ul>
<p>（…未完待续）</p>
]]></content>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-96-不同的二叉搜索树</title>
    <url>/2020/04/04/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<a id="more"></a>
<hr>
<p>这里给出用动态规划的思想来看这道题。对于1…n这一序列中的每一个元素，在组成的二叉搜索树中都可以作为根节点，那么分别看以这些元素作为根节点的二叉搜索树的数目，再求和，就是1…n序列可以组成的二叉搜索树的数目。例如，对于n个元素序列的二叉搜索树的数目$f(n)$，以第j个元素作为根节点，那么比j小的元素必然在j的左边，组成了j的左子树，j的左子树也是一颗二叉搜索树，它的可能个数是$f(j-1)$，同理，大于j的所有元素组成了j的右子树，这也是一颗二叉排序树，它可能的个数是$f(n-1-j)$。所以得到递推公式：</p>
<script type="math/tex; mode=display">
f(n)=\begin{cases} 0,n=0;\\\\\sum_{i=0}^{n-1} f(i)*f(n-1-i),n>0\end{cases}</script><p>由于这个序列的每一项都与前面所有项都有关，因此需要用一个数组来存每一项。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">2</span>);i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">1</span>);j&lt;=i;j++)</span><br><span class="line">                dp[i] = dp[i] + dp[j<span class="number">-1</span>] * dp[i-j];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实得到递推公式之后，可以发现一个很神奇的事情，这个递推公式其实就是卡特兰数的定义式，那么这个问题就转化成了求卡特兰数的问题了，当然也可以用通项公式来解，并且空间复杂度还降至$O(1)$。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-94-二叉树的中序遍历</title>
    <url>/2020/04/03/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p>
<a id="more"></a>
<hr>
<p>除了递归算法之外，第一种是基于栈的迭代算法，但思想和递归是一样的。中序遍历要求的是左根右的顺序，所以可以做如下判断：</p>
<ul>
<li>如果当前节点为空，那么取并弹出栈顶节点，输出该节点，并遍历此节点的右子树(i = i-&gt;right)。</li>
<li>如果当前节点非空，那么将该节点压入栈中，并遍历当前节点的左子树(i = i-&gt;left)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="function">TreeNode* <span class="title">i</span><span class="params">(root)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(i||!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(i);</span><br><span class="line">                i = i-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = <span class="built_in">stack</span>.top();</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                res.push_back(i-&gt;val);</span><br><span class="line">                i = i-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有就是莫里斯算法，利用线索二叉树，即把所有的空指针指向后继，因此不需要使用栈。将遍历过程中的空间复杂度降至$O(1)$。考虑中序遍历的特性，二叉树中的每一个节点其实都是它的左孩子的最右子孙节点的后继，因此自上而下遍历时首先建立线索，第二次访问线索节点的时候再恢复原来的结构。</p>
<ul>
<li>如果当前节点有左孩子，那么用一个指针去寻找当前节点的前驱节点，即找到当前节点的左子树的最右子孙。<ul>
<li>如果找到的这个左子树的最右子孙的右节点(指向后继的线索)为空，那么说明是第一次访问这个节点，所有将其线索化，让它指向当前节点。之后再让当前节点继续往左孩子方向移动，去建立新的线索。</li>
<li>如果找到的这个左子树的最右子孙的右节点指向的是当前节点，说明现在是第二次到达当前节点了，这时可以将当前节点输出，并将其前驱节点的后继线索删除。也说明当前节点的左侧都已经遍历完成了，这时再去遍历当前节点的右子树(该“右子树”有可能是线索)。</li>
</ul>
</li>
<li>如果当前节点无左孩子，那么直接输出当前节点，并遍历当前节点的右子树(该“右子树”有可能是线索)。</li>
</ul>
<p>可以看出，莫里斯遍历巧妙地将树的线索化融合到遍历的过程当中，避免了栈的使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function">TreeNode* <span class="title">i</span><span class="params">(root)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-&gt;left)&#123;</span><br><span class="line">                <span class="function">TreeNode* <span class="title">pre</span><span class="params">(i-&gt;left)</span></span>;</span><br><span class="line">                <span class="keyword">while</span>(pre-&gt;right&amp;&amp;pre-&gt;right!=i)</span><br><span class="line">                    pre = pre-&gt;right;</span><br><span class="line">                <span class="keyword">if</span>(pre-&gt;right)&#123;</span><br><span class="line">                    res.push_back(i-&gt;val);</span><br><span class="line">                    pre-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                    i = i-&gt;right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre-&gt;right = i;</span><br><span class="line">                    i = i-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(i-&gt;val);</span><br><span class="line">                i = i-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-93-复原ip地址</title>
    <url>/2020/04/02/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>示例：</p>
<blockquote>
<p>输入：”25525511135”<br>输出：[“255.255.11.135”, “255.255.111.35”]<br><a id="more"></a></p>
<hr>
<p>起初看这题，着实是被吓到了，明明知道是一道回溯题，但是就是无从下手。不过也有可能是对处理字符串方面经验不太足，但这题处理好字符串，就解决了一大半的问题。</p>
</blockquote>
<p>回溯题，无非是确定何时回溯，何时输出数据，何时剪枝。那么回来看这题：</p>
<ul>
<li>何时回溯。当发现当前计算网段的长度大于4，但并未搜索完整个原字符串的时候需要剪枝。</li>
<li>何时输出数据。当发现字符串长度等于原字符串长度+4，并且当前的段数符合要求，这时候就可以先弹出末尾一个不需要的小数点，再把现在这个字符串压入答案中。</li>
<li>何时剪枝。由于每一段的数字长度肯定不超过3，因此每一个父节点理论上要有3个子节点，子结点的长度依次为1，2，3。可以用一个循环，每次截取相应长度的字符串，对其进行判断。可以得出如果截取到的字符串首位为‘0’但长度大于1的子树都可以砍掉，因为除了0之外0不能作为其它数字的开头。还有如果当前截取的字符串大小大于255，那么也需要剪枝，因为超过了规定的最大长度。</li>
</ul>
<p>时间复杂度为$O(1)$，因为无论输入的参数如何所得字符串的个数是有上界的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        dfs(s,<span class="number">0</span>,<span class="number">0</span>,tmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span> start,<span class="keyword">int</span> len,<span class="built_in">string</span> tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp.size()==s.size()+<span class="number">4</span>&amp;&amp;len==<span class="number">4</span>)&#123;</span><br><span class="line">            tmp.pop_back();</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len&gt;<span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);start + i&lt;s.size()&amp;&amp;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> sub = s.substr(start,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(sub[<span class="number">0</span>] == <span class="string">'0'</span>&amp;&amp;sub.size()&gt;<span class="number">1</span>||stoi(sub)&gt;<span class="number">255</span>)<span class="keyword">break</span>;</span><br><span class="line">            dfs(s,start + i + <span class="number">1</span>,len + <span class="number">1</span>,tmp + sub + <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-92-反转链表II</title>
    <url>/2020/04/01/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。<br>说明:1 ≤ m ≤ n ≤ 链表长度。<br>示例:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL<br><a id="more"></a></p>
<hr>
<p>只需要使用三个指针，中间指针记录正在遍历的节点，另外两个指针分别指向前驱和后继节点，当遍历到第m个节点的时候，记录下前驱节点和当前节点，当计数器的值大于等于m的时候将中间节点的后继节点设置为前驱，然后三个指针整体后移，循环至计数器的值为n的时候，在完成节点指针后继回指向前驱之后，将m节点的前驱的后继设置为现在计数为n的节点，将m节点的后继设置为现在三个指针的最后一个指针指向的节点，这个时候最后一个指针有可能为空，所以只要每次最后一个指针后移的时候做判断就可以知道该让其后移还是置空。做完上述操作即可退出循环，因此时间复杂度为$O(n)$，n为链表反转的右边界位置。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode* <span class="title">h</span><span class="params">(<span class="keyword">new</span> ListNode(<span class="number">-1</span>))</span></span>;</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line">        ListNode* front(nullptr),*behind(nullptr),*i(h),*j(head),*k(head-&gt;next);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> count(<span class="number">1</span>);;i=j,j=k,k=k-&gt;next?k-&gt;next:<span class="literal">nullptr</span>,count++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==m)&#123;</span><br><span class="line">                front = i;</span><br><span class="line">                behind = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;=m)&#123;</span><br><span class="line">                j-&gt;next = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">                front-&gt;next = j;</span><br><span class="line">                behind-&gt;next = k?k:<span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-91-解码方法</title>
    <url>/2020/03/31/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<blockquote>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p>
</blockquote>
<p>给定一个只包含数字的非空字符串，请计算解码方法的总数。<br>示例：</p>
<blockquote>
<p>输入: “226”<br>输出: 3<br>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br><a id="more"></a></p>
<hr>
<p>这道题也算是动态规划的经典题，算是上楼梯的升级版，但还是让我想了很久才想通。总的来说，当前的状态是被前两种状态唯一确定的。首先可以用一个数组来存给定编码的每一位之前所对应的可能编码数。重要的情况是当编码位为0的时候，因为0不能单独编码。</p>
</blockquote>
<p>来分析一下状态方程：</p>
<ol>
<li>当s[i]=0的时候，由于0是不能单独编码的，必须借助前一位是1或者是2的情况来编码。<ul>
<li>如果前一位是1或2，这个时候s[i-1]被s[i]捆绑到了一起，使得s[i-1]也不能单独编码，由于s[i]和s[i-1]的捆绑是唯一的，所以dp[i]位的可能编码数由dp[i-2]来确定。即dp[i]=dp[i-2]。</li>
<li>如果前一位不是1且不是2，那么这个编码是错误的，所以直接返回0。</li>
</ul>
</li>
<li>当s[i]!=0的时候。<ul>
<li>如果s[i-1]能够与s[i]组成合法的两位数，即s[i-1]s[i]在1到26的闭区间内，那么dp[i]的数目由两种编码方式所确定。一种是s[i]与s[i-1]分开编码，这种方式编码的可能性为dp[i-1]种；另一种是s[i]与s[i-1]一起编码，这种编码方式的可能性为dp[i-2]种，道理和上文所说的与0捆绑的情况是一样的。所以将两种情况汇总，就是dp[i]=dp[i-1]+dp[i-2]种。</li>
<li>如果s[i-1]与s[i]无法捆绑成合法两位数，那么由于s[i]单独编码，相比前一项的可能情况数没有额外增加，所以dp[i]=dp[i-1]。</li>
</ul>
</li>
</ol>
<p>以上便是所有需要考虑的情况，再设置初始条件dp数组前两位为1,dp[1]才开始对应着s[0]，原因是，可以将dp[0]理解为字符串为空时可能的编码数，把它规定为1，就是唯一对应编码也为空的情况。另外，再排除掉特殊情况，字符串第一位为0的时候就可以直接认定不合法返回0。</p>
<p>综上的时间复杂度为$O(n)$，空间复杂度为$O(n)$，n为字符串的长度。但我们可以知道，dp数组的每一位都是由前两位唯一确定的，因此我们只需要用两个变量保留当前位的前两位数值即可，而不用存下整个数组。因此经过优化可以将空间复杂度降为$O(1)$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'0'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int last2(1),last1(1),tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i&lt;s.size();i++)&#123;</span><br><span class="line">            tmp = last1;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>)</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]!=<span class="string">'1'</span>&amp;&amp;s[i<span class="number">-1</span>]!=<span class="string">'2'</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> last1 = last2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||(s[i<span class="number">-1</span>]==<span class="string">'2'</span>&amp;&amp;s[i]&lt;<span class="string">'7'</span>))</span><br><span class="line">                last1 += last2;</span><br><span class="line">            last2 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-90-子集II</title>
    <url>/2020/03/31/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-90-%E5%AD%90%E9%9B%86II/</url>
    <content><![CDATA[<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。<br>示例：</p>
<blockquote>
<p>输入: [1,2,2]<br>输出:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]<br><a id="more"></a></p>
<hr>
<p>这题的难点在于去重，对于回溯法来说，如何去重应该去分析递归树。经过分析发现，为了满足题目条件，我们需要保证递归树中相同层的元素只能出现一次，而不同层级是可以存在相同元素的。再看代码中，对于同一层级元素的遍历处于递归函数那个for循环中，因此现在要做的是，只让同一层的相同元素出现一次，对于这一点，在一个排好序的数组中，之接用当前项去和前一项比较就可以很容易得出答案了，所以如果存在重复，就直接跳到下一步循环。综上，对于和递归有关的算法，为了研究去重问题，递归树是一个非常重要的参考。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        recall(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        ans.push_back(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;begin&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">queue</span>.push_back(nums[i]);</span><br><span class="line">            recall(nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">queue</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-89-格雷编码</title>
    <url>/2020/03/31/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。<br><a id="more"></a></p>
<hr>
<p>该题是为了输出给定位数的格雷码，那么根据格雷码的计算法则，第n位的格雷码，从n的最右侧开始，每一位与它的左边一位做异或运算，得到当前位的格雷码的数值，以此类推，最左边那一位与0异或。将这个方法简化，就是将n与n右移一位的数按位异或，就得到了从0开始的第n个格雷码。</p>
<p>当然这题作为中等题，大概要追求一下类似动态规划的方法，由递推关系得出格雷码，因此这样算出的格雷码不一定和标准算法中的一样，以后有时间可以尝试一下。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;<span class="number">1</span>&lt;&lt;n;i++)</span><br><span class="line">            ans.push_back(i^i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-86-分隔链表</title>
    <url>/2020/03/30/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。<br>示例：</p>
<blockquote>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br><a id="more"></a></p>
<hr>
<p>这道题主要思想是另开两条链表，遍历原链表，大于等于目标值的放在一条链表中，小于目标值的放在另一条链表中，最后将两条链表拼接就达到了题目的要求。要注意的是大于等于的链表的末尾需要置空，不然可能导致该链表的最后一位还指向了小于的那条链表中的节点。因为没审好题，漏看了大于等于的那个等于，花了很长时间调试。下次一定要审题！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode* less(new ListNode(-1)),*more(new ListNode(-1)),*les(less),*mor(more);</span><br><span class="line">        <span class="keyword">for</span>(ListNode* i(head);i;i = i-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-&gt;val&lt;x)&#123;</span><br><span class="line">                les-&gt;next = i;</span><br><span class="line">                les = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                mor-&gt;next = i;</span><br><span class="line">                mor = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mor-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        les-&gt;next = more-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> less-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-82-删除链表中的重复元素II</title>
    <url>/2020/03/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-82-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    <content><![CDATA[<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中没有重复出现的数字。</p>
<p>示例：</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br><a id="more"></a></p>
<hr>
<p>用双指针，加入表头节点，慢指针初始指向表头节点，慢指针始终指向快指针，当快指针发现当前的值与后继节点的值不同时，用循环来找到这个重复链的终点，然后再将快慢指针连上。中间这些删除的节点还要想办法释放空间。有一点要注意，就是如果链表原来的第一个节点被删除了的话，直接返回原来的第一个节点会报空指针异常，因此只需要返回新建的那个头节点的下一个节点就好了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode* <span class="title">h</span><span class="params">(<span class="keyword">new</span> ListNode(<span class="number">-1</span>))</span></span>;</span><br><span class="line">        h-&gt;next = head;</span><br><span class="line">        ListNode* i(h),*j(head);</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;j-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-&gt;next-&gt;val == j-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(j-&gt;next&amp;&amp;j-&gt;next-&gt;val==j-&gt;val)</span><br><span class="line">                    j = j-&gt;next;</span><br><span class="line">                j = j-&gt;next;</span><br><span class="line">                <span class="function">ListNode* <span class="title">del</span><span class="params">(i-&gt;next)</span></span>;</span><br><span class="line">                <span class="keyword">while</span>(del-&gt;next!=j)&#123;</span><br><span class="line">                    ListNode* t = del;</span><br><span class="line">                    del = del-&gt;next;</span><br><span class="line">                    <span class="keyword">delete</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">delete</span> del;</span><br><span class="line">                i-&gt;next = j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = i-&gt;next;</span><br><span class="line">                j = j-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-83-删除链表中的重复元素</title>
    <url>/2020/03/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-83-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例：</p>
<blockquote>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3<br><a id="more"></a></p>
<hr>
<p>考察链表的基础删除操作，由于已经排好序了，只需要遍历一次比较前后的元素。要记得清理野指针。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode* <span class="title">i</span><span class="params">(head)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (i&amp;&amp;i-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-&gt;next-&gt;val==i-&gt;val)&#123;</span><br><span class="line">                <span class="function">ListNode* <span class="title">j</span><span class="params">(i-&gt;next)</span></span>;</span><br><span class="line">                i-&gt;next = j-&gt;next?j-&gt;next:<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">delete</span> j;</span><br><span class="line">            &#125;<span class="keyword">else</span> i = i-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-81-搜索旋转排序数组II</title>
    <url>/2020/03/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p>进阶:</p>
<ul>
<li>这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。</li>
<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？<a id="more"></a>
</li>
</ul>
<hr>
<p>相比此前的搜索旋转数组，在这里多了重复元素，首先导致了如果首位与最后一位元素相等，则无法判断是k的前段有序还是后段有序，因为将k指向的元素与首位作比较就是为了确定一种情况，现在这种情况模棱两可，当然是会出错的，解决的办法是在开始循环之前将如果首尾相同，就让首位后移直到不相同为止。其次，在循环逻辑判断的时候，细节方面需要考虑k指向的值与开头相等的情况，但思想不变。</p>
<p>至于题目改动对时间复杂度的影响，情况最好时，即头元素与尾元素一开始就不等，那么就是$O(logn)$。情况最坏时，即所有元素都一样，那么在循环体之前对头尾的处理将会耗费过多时间，所以时间复杂度为$O(n)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        int i(0),j(nums.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(nums[i] == nums[j]&amp;&amp;i&lt;j)i++;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">tag</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target||nums[j]==target)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i+j)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&lt;nums[tag])j=k<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[tag])j=k<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> i=k+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[k]&lt;target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&gt;=nums[tag])i=k+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[tag])j=k<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> i=k+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-80-删除排序数组中的重复项II</title>
    <url>/2020/03/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II/</url>
    <content><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>示例:</p>
<blockquote>
<p>给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。<br><a id="more"></a></p>
<hr>
<p>你不需要考虑数组中超出新长度后面的元素。<br>这道题似曾相识，用覆盖的思想来解这类删除重复项的题是非常巧妙的。用快慢指针的思想，慢指针指向的位置始终满足此前的序列中的重复项不超过2，用快指针与慢指针的前一位比较，根据有序数组的特性，如果两者相等的话，慢指针夹在中间也必定相等，那么这时就有3个重复项了，为了解决这个问题，让i不动，守住满足条件的最后一个位置，让j继续往前遍历，直到找到一个地方试两个值不等，这时候就可以让i后移一位，把j指向的值给i，继续循环上述操作，当j遍历完数组的时候，i作为结果序列的最后一位，i+1就是结果序列的长度。</p>
</blockquote>
<p>这一类题都巧妙利用了有序这个特性，通过这个确定可以确定慢指针的位置可以每次都准确地指向满足条件序列的结束位置。所以这个方法也可以由结果序列中元素最多重复一次推广成结果序列中的元素最多重复n次。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>)<span class="keyword">return</span> nums.size();</span><br><span class="line">        int i(1),j(2);</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.size();j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i<span class="number">-1</span>])</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-79-单词搜索</title>
    <url>/2020/03/28/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<br>示例：</p>
<blockquote>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]<br>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false<br><a id="more"></a></p>
<hr>
<p>这道题依然是用回溯法的套路去做，但思路要清晰，尽量把所有判断做完之后再去递归，不然的话会特别费时间。由于在每一个点都有4个遍历的方向，用4个条件判断来对四个方向分别深度优先搜索，还要有一个和原数组一样规模的状态数组，代表对应每一个元素是否已经访问过。但目前我这个方法的效率有点低，还是得多学习如何优化回溯法，使得递归的消耗尽量小。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">stat</span><span class="params">(board.size(),<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;board.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;board[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == word[<span class="number">0</span>]&amp;&amp;recall(board,word,stat,i,j,<span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; stat,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == word.size()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stat[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;!stat[i<span class="number">-1</span>][j]&amp;&amp;board[i<span class="number">-1</span>][j]==word[k+<span class="number">1</span>]&amp;&amp;recall(board,word,stat,i<span class="number">-1</span>,j,k+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;board.size()<span class="number">-1</span>&amp;&amp;!stat[i+<span class="number">1</span>][j]&amp;&amp;board[i+<span class="number">1</span>][j]==word[k+<span class="number">1</span>]&amp;&amp;recall(board,word,stat,i+<span class="number">1</span>,j,k+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span>&amp;&amp;!stat[i][j<span class="number">-1</span>]&amp;&amp;board[i][j<span class="number">-1</span>]==word[k+<span class="number">1</span>]&amp;&amp;recall(board,word,stat,i,j<span class="number">-1</span>,k+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;board[<span class="number">0</span>].size()<span class="number">-1</span>&amp;&amp;!stat[i][j+<span class="number">1</span>]&amp;&amp;board[i][j+<span class="number">1</span>]==word[k+<span class="number">1</span>]&amp;&amp;recall(board,word,stat,i,j+<span class="number">1</span>,k+<span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stat[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-78-子集</title>
    <url>/2020/03/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-78-%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。<br>示例:</p>
<blockquote>
<p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]<br><a id="more"></a></p>
<hr>
<p>这道题个人认为也非常有代表性，首先这属于排列问题，回溯法肯定使用，只不过要使回溯终点的距离动态变化，用一个循环可以实现。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        recall(ans,nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        ans.push_back(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(start);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="built_in">queue</span>.push_back(nums[i]);</span><br><span class="line">            recall(ans,nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">queue</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另外，可以用动态规划的思想，在已知的子集中依次从序列中添加新的元素，组成新的子集，但要注意每一轮添加时的遍历长度，其不能随着子集序列的长度变化变化。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans&#123;&#123;&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = ans.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;len;j++)&#123;</span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(ans[j])</span></span>;</span><br><span class="line">                t.push_back(nums[i]);</span><br><span class="line">                ans.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>还有一种更巧妙的算法，那就是位运算。这个思想特别巧妙，将求子集个数的公式与二进制数的特性联系了起来。由于一个长度为n的序列，它的子集个数为2的n次方，那么将其写成二进制形式可以清晰地发现从0开始到2的n次方减1的每一个二进制数可以唯一对应一个子集，那么只需要从0遍历到2的n次方减一，分别通过二进制数来找出子集并插入就可以了。</p>
</blockquote>
<p>二进制数与子集的对应关系可以理解为，该位为1代表该位对应为序列下标的值属于该子集中的元素。那么将这个二进制数进行右移操作，每一次比较末尾那一位是否为1。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>),stat(<span class="built_in">pow</span>(<span class="number">2</span>,nums.size()));i&lt;stat;i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(i),count(<span class="number">0</span>);j&gt;<span class="number">0</span>;j&gt;&gt;=<span class="number">1</span>,count++)</span><br><span class="line">                <span class="keyword">if</span>(j&amp;<span class="number">1</span>)t.push_back(nums[count]);</span><br><span class="line">            ans.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>三种方法的时间复杂度都为$o(n2^n)$。很惭愧，我开始只想到了最好想到的回溯法。但这题值得铭记。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-77-组合</title>
    <url>/2020/03/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-77-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。<br>示例:</p>
<blockquote>
<p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br><a id="more"></a></p>
<hr>
<p>这道题就是一道全排列题的变体，就是把排列的个数n换成了k，依然是用深度优先搜索策略，然后层数满足k时就回溯。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        recall(ans,<span class="number">1</span>,n,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="keyword">int</span> start,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>.size()==k)&#123;</span><br><span class="line">            ans.push_back(<span class="built_in">queue</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(start);i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">queue</span>.push_back(i);</span><br><span class="line">            recall(ans,i+<span class="number">1</span>,n,k);</span><br><span class="line">            <span class="built_in">queue</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-75-颜色分类</title>
    <url>/2020/03/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。<br>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>
<blockquote>
<p>示例:<br>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p>
</blockquote>
<p>进阶：</p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？<a id="more"></a>
</li>
</ul>
<hr>
<p>这题的原型是荷兰国旗问题，对应红白蓝三色。那么翻译一下其实就是要将一个只包含三个不同的元素的序列排序。众所周知，用常规的排序算法时间复杂度不会低于$O(nlogn)$，为了达到一趟扫描肯定需要利用到不同元素只有三个这个条件。</p>
<p>整体来看，0，1，2这三个元素在排好序的序列当中应该是所有0在最左边，所有2在最右边，中间是1。换句话说，我们只需要将1和2的位置放好，剩下1的位置是不需要管的。当然如果选择排好0和1的位置也可以，原理是一样的。</p>
<p>因此设立三个指针，<code>zero</code>用来指示排好序的0序列的后一位置，<code>two</code>用来指示排好序的2序列的前一位置，<code>i</code>用来遍历这个序列并作比较。</p>
<ul>
<li>如果i的值小于<code>zero</code>，说明在满足条件的区间内是已经排好序的，所以直接将i右移。</li>
<li><p>如果i的值在<code>zero</code>和<code>two</code>之间，那么将<code>num[i]</code>分别与<code>num[zero]</code>和<code>num[two]</code>作比较：</p>
<ol>
<li>如果<code>num[i]</code>等于0，将<code>num[i]</code>与<code>num[zero]</code>值交换，并将<code>zero</code>后移一位。</li>
<li>如果<code>num[i]</code>等于2，将<code>num[i]</code>与<code>num[two]</code>值交换，并将<code>two</code>前移一位。</li>
<li>如果<code>num[i]</code>等于1，将<code>i</code>后移一位。</li>
</ol>
</li>
</ul>
<p>这样便可以在一次遍历结束之后完成对序列的排序。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        int zero(0),two(nums.size()-1),i(0);</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=two)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=zero&amp;&amp;nums[i]==<span class="number">0</span>)swap(nums[i],nums[zero++]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=zero&amp;&amp;nums[i]==<span class="number">2</span>)swap(nums[i],nums[two--]);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-74-搜索二维矩阵</title>
    <url>/2020/03/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。 </li>
<li>每行的第一个整数大于前一行的最后一个整数。<a id="more"></a>
</li>
</ul>
<hr>
<p>二分查找，可以用两种方式，一种是把二维数组看成一维数组，再进行二分查找，时间复杂度是$O(log(mn))$。还有一种是先对行首进行二分查找，再对选定行进行二分查找，时间复杂度为$O(logm + logn)$。两个方法的效率是一样的，我使用的是后者。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>||matrix[<span class="number">0</span>].size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        int i(0),j(matrix.size()-1),J;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() &gt; <span class="number">1</span>)<span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i+j)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[k][<span class="number">0</span>]&gt;target)j = k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[k][<span class="number">0</span>]&lt;target)i = k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)<span class="keyword">for</span>(i = <span class="number">0</span>,J = matrix[<span class="number">0</span>].size()<span class="number">-1</span>;i&lt;=J;)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i+J)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k]&gt;target)J = k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[j][k]&lt;target)i = k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-73-矩阵置零</title>
    <url>/2020/03/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
    <content><![CDATA[<p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。<br>示例：</p>
<blockquote>
<p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]<br><a id="more"></a></p>
<hr>
<p>题目要求原地算法，就是空间复杂度要是常数级。可以用两次遍历矩阵中元素来完成。第一遍每检查到一个为零的元素，将该行和该列的所有元素置成一个不相关的数，这个数看情况可以取一个大数。第二遍遍历再将矩阵中所有值为这个大数的地方置零。这个大数可以看作一个需要置零的标记。不能直接置零的原因是按照规则，如果直接置零，整个矩阵将会全为零。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> UNCONCERNED = <span class="number">8848</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i&lt;matrix.size();i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>); j&lt;matrix[<span class="number">0</span>].size();j++)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    matrix[i][j] = UNCONCERNED;</span><br><span class="line">                    setRowColumn(matrix,i,j,UNCONCERNED);</span><br><span class="line">                &#125;   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : matrix)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;j : i)</span><br><span class="line">                <span class="keyword">if</span>(j==UNCONCERNED)</span><br><span class="line">                    j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRowColumn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="keyword">int</span> row,<span class="keyword">int</span> column,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : matrix[row])</span><br><span class="line">            i = i == <span class="number">0</span>? i :num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : matrix)&#123;</span><br><span class="line">            i[column] = i[column] == <span class="number">0</span>? i[column] :num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-71-简化路径</title>
    <url>/2020/03/26/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-71-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。<br><a id="more"></a></p>
<blockquote>
<p>示例 1：<br>输入：”/home/“<br>输出：”/home”<br> 解释：注意，最后一个目录名后面没有斜杠。 </p>
<p>示例 2：<br>输入：”/../“<br>输出：”/“<br>解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。</p>
<p>示例 3：<br>输入：”/home//foo/“ 输出：”/home/foo” 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</p>
<p>示例 4：<br>输入：”/a/./b/../../c/“ 输出：”/c” </p>
<p>示例 5：<br>输入：”/a/../../b/../c//.//“ 输出：”/c” </p>
<p>示例 6：<br>输入：”/a//b////c/d//././/..” 输出：”/a/b/c”</p>
<hr>
<p>此题是面像示例编程，对着示例一个一个看符不符合。但主要还是要想到用字符串流来处理字符串，getline函数有一种重载形式可以根据分隔符来读取流中的字符串，之后再配合栈的使用，便可以很好的格式化题目给的路径。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        string format(""), tmp = ("");</span><br><span class="line">        <span class="keyword">while</span>(getline(ss, tmp, <span class="string">'/'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="string">""</span> || tmp == <span class="string">"."</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="string">".."</span> &amp;&amp; !strs.empty())strs.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp != <span class="string">".."</span>)strs.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str:strs) format +=  <span class="string">"/"</span> + str;</span><br><span class="line">        <span class="keyword">return</span> format.empty()?<span class="string">"/"</span>:format;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-70-爬楼梯</title>
    <url>/2020/03/26/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。<br><a id="more"></a><br>题目给出的递推关系让人很容易想到动态规划，就是用一个数组，从前两层已知的台阶开始往后累加推算，可以得到到达最后一层台阶的走法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">2</span>);i&lt;=n;i++)</span><br><span class="line">            dp[i] += (dp[i<span class="number">-2</span>] + dp[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里时间复杂度为$O(n)$，但写完之后我看着下下来的代码，眼里飘过一层似曾相识的景象，这不就是算第n+1项的斐波那契数嘛，那就只好在搬出尘封已久的快速幂算法了(时间复杂度$O(logn)$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; m&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n+<span class="number">1</span>,m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m)</span></span>&#123;</span><br><span class="line">	    n-=<span class="number">2</span>;</span><br><span class="line">	    <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; sum&#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">		    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)matrix_Multiplication(sum, m, <span class="number">2</span>);</span><br><span class="line">		    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		    matrix_Multiplication(m, m, <span class="number">2</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> sum[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">matrix_Multiplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m1, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">long</span>* ans = <span class="keyword">new</span> <span class="keyword">long</span>[n*n];</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; n;i++) &#123;</span><br><span class="line">		    <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>); j &lt; n; j++)&#123;</span><br><span class="line">			    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">			    <span class="keyword">for</span> (<span class="keyword">int</span> k(<span class="number">0</span>);k &lt; n;k++) &#123;</span><br><span class="line">				    sum += m1[i+k*n] * m2[k+j*n];</span><br><span class="line">			    &#125;</span><br><span class="line">			    ans[i+j*n] = sum;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    m1.clear();</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; n * n;i++)m1.push_back(ans[i]);</span><br><span class="line">	    <span class="keyword">delete</span>[] ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-69-x的平方根</title>
    <url>/2020/03/26/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<p>实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br><a id="more"></a></p>
<hr>
<p>因为正整数的算数平方根必然存在于0和这个数之间，并且只需要求整数部分，那么问题就转化为了有序序列中的查找问题，自然想到二分查找法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">1</span>)<span class="keyword">return</span> x;</span><br><span class="line">        int i(0),j(x);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i+j)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(x/k&lt;k)j = k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x/k&gt;k)i = k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除去二分法之外，这题还可以用牛顿迭代法。牛顿迭代法非常适合用来求解方程的根，而问题可以转化成解$ x - n^2 = 0$这个方程，同时也就是x已知，寻找 $f(n) = x - n^2 $这个函数的零点 。牛顿迭代法的思想是这样，首先在定义域上任取一点 i 作为函数零点的初始近似值，函数在这一点的切线将会于x轴交于一个距离真正零点更近的点，之后用这个点来代替 i，并用现在的 i 去找下一个 i，直到满足需要的精度为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">i</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">abs</span>(i/<span class="number">2</span>-x/(<span class="number">2</span>*i))&gt;=<span class="number">1</span>)</span><br><span class="line">            i=i/<span class="number">2</span>+x/(<span class="number">2</span>*i);</span><br><span class="line">        <span class="keyword">return</span> i/<span class="number">2</span>+x/(<span class="number">2</span>*i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虽然二分法和牛顿迭代法的时间复杂度都是$O(logn)$，但经测试，牛顿迭代法的性能还是要好上不少。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-67-二进制求和</title>
    <url>/2020/03/26/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p>给定两个二进制字符串，返回他们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。<br>示例：</p>
<blockquote>
<p>输入: a = “1010”, b = “1011”<br>输出: “10101”<br><a id="more"></a></p>
<hr>
<p>这道题顺道用来复习一下算术逻辑单元里面的串行加法器原理。就是直接套每一位的和表达式和进位表达式。</p>
<ul>
<li>和表达式：$N = A ⊕ B ⊕ CARRY$</li>
<li>进位表达式：$CARRY = AB + (A ⊕ B)CARRY$</li>
</ul>
</blockquote>
<p>但其实调bug调了很久，犯了一些低级错误，尤其是以后再也不敢把( + )看作按位或了( | )。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="string">"0"</span>&amp;&amp;b==<span class="string">"0"</span>)<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(a.size()&gt;b.size()?a:b)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">carry</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(a.size()<span class="number">-1</span>),j(b.size()<span class="number">-1</span>),k(ans.size()<span class="number">-1</span>);k&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            int A(i&lt;0?0:a[i]-48), B(j&lt;0?0:b[j]-48);</span><br><span class="line">            ans[k--] = (A^B^carry) + <span class="number">48</span>;yihuo</span><br><span class="line">            carry = A &amp; B | (A ^ B) &amp; carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> carry&gt;<span class="number">0</span>?<span class="string">'1'</span>+ans:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-63-最小路径和</title>
    <url>/2020/03/25/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。<br>示例：</p>
<blockquote>
<p>输入:<br>[[1,3,1],<br>[1,5,1],<br>[4,2,1]]<br>输出: 7<br>解释: 因为路径 1→3→1→1→1的总和最小。<br><a id="more"></a></p>
<hr>
<p>一开始看到这种求最小路径的差点就陷入贪心的坑里了，还好看到示例就是个反驳贪心法的很好的例子。那么剩下就只有动态规划了，由于只能往右或往下，所以要求到当下的格子的最短路径长度，只需要算出当下格子上方格子的最短路径长度和左方格子的最短路径长度，再加上当下格子的权重即可，因为路径要么从上方来要么从左方来。当然第一行和第一列只需要分别累加它们的左方和上方即可，这样遍历一次二维数组就可以算得到左上角到最右下角的最短路径长度。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;grid.size();i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;grid[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>)grid[i][j] += grid[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)grid[i][j] += grid[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;j&gt;<span class="number">0</span>)grid[i][j] += min(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.size()<span class="number">-1</span>][grid[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-63-不同路径II</title>
    <url>/2020/03/25/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_62_1.png?raw=true"><br><a id="more"></a></p>
<hr>
<p>这道题比上一题稍微复杂一些，在一些格子增加了障碍，因此也不能用简单的组合数来算。还得要动态规划，但也就是在上一题的基础上，增加了对格子和将要走的下一个格子一个障碍判断。不过给的测试数据挺恶心的，要排除掉在第一个格子放障碍的情况，另外算出来的数字会越界，所以为了能存尽量大的整数我就用了一个64位的无符号整型。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        int height(obstacleGrid.size()),width(obstacleGrid[0].size());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt;&gt; <span class="title">dp</span><span class="params">(height,<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt;(width,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]!=<span class="number">1</span>)</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;height;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;width;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;width<span class="number">-1</span>&amp;&amp;obstacleGrid[i][j+<span class="number">1</span>]!=<span class="number">1</span>)dp[i][j+<span class="number">1</span>]+=dp[i][j];</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;height<span class="number">-1</span>&amp;&amp;obstacleGrid[i+<span class="number">1</span>][j]!=<span class="number">1</span>)dp[i+<span class="number">1</span>][j]+=dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[height<span class="number">-1</span>][width<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-62-不同路径</title>
    <url>/2020/03/25/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p>
<p><image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_62_1.png?raw=true"><br><a id="more"></a></p>
<hr>
<p>这是一道典型的动态规划的题目，从起始点开始到方格中的每一个点的方法数都能够通过之前的点递推出来。比如说在当前的位置，如果能够往右走，那么右边那个点的方法数就是在原来的基础上加上到当前位置的方法数，如果能够往下走，道理也是一样的。一开始起始位初始化为1（起始位到起始位的方法数当然是1），其他位置由于还没有计算初始化为0。遍历所有位置一遍可以计算出最右下角的位置的数字。动态规划的时间复杂度为$o(mn)$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m)dp[i+<span class="number">1</span>][j]+=dp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n)dp[i][j+<span class="number">1</span>]+=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>除此之外，这还是一道排列组合问题，由于可以走的方向只有右和下，那么从起点到终点的长度则固定为 m + n - 2，问题就可以变成从长度为m + n - 2的路径中求向下的m - 1条路径与向右的n - 1条路径有多少种组合。为了计算效率只要取两者中的小者带入公式即可。公式为：$C^{min(m,n)}_{m+n-2)}$。另外用循环来算组合数的时候，首先为了避免整数溢出，一定要一边乘一边除，另外为了避免除法丢失精度，乘除法应当从1和max(m,n)开始。该算法时间复杂度为$O(min(m,n))$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        int len(min(m,n)),j(max(m,n)),i(1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=len<span class="number">-1</span>)res = res*j++/i++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开与逆展开</title>
    <url>/2020/03/24/algorithms/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E4%B8%8E%E9%80%86%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<p>在刷题的时候遇到了一个全排列的问题，就是求给定全排列字典序中的第k个。用回溯法做显然耗时太长，毕竟只是想获得一个排列而已，去遍历其它的可能是没有必要的。那么只有想到用数学方法来解决了，于是自学了一些康托展开的原理，不得不说这很奇妙，在全排列的字典序中求任何一项都可以用公式来完成。<br><a id="more"></a></p>
<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p>
<p>公式为：</p>
<script type="math/tex; mode=display">
X=a_1(n-1)!+a_{n-1}(n-2)!+...+a_1*0!，a_i\in Z,0\le a_i<i,1\le i\le n</script><hr>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>康托展开的原理很简单，因为要求一个排列是多少项，那么也就是要求排在它的前面有多少项。在公式里面，an表示的是除去当前已经确定排好位的数字之外，比当前所计算的数字小的数字有多少个。当然这样会很拗口，那么就结合一个实例来看。比如，要找<code>3，1，4，2</code>在全排列中按照字典序的排位。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>首先先看第一位是3，那么显然第一位是1和第一位是2的情况会排在它之前，那么这些情况总共将会有<script type="math/tex">2*3！</script>种，所以<script type="math/tex">num=num+2*3!</script> 。</p>
<p>再看第二位是1，而1已经是最小的情况了，所以比1还要小的情况数是0，假设要算的话应该是<script type="math/tex">0*2!</script>，因此按照算法来说就是<script type="math/tex">num = num + 0 * 2!</script> 。</p>
<p>再看第三位是4，在已经排好3，1的情况下，比第三位是4还要小的情况就只有2了，所以<script type="math/tex">num = num + 1*1!</script>。</p>
<p>最后一位其实是可以不用排的，因为前面已经都排好，最后一位是固定的。当然公式里面写上去了也无伤大雅。</p>
<p>经过上述的步骤，算出$num=13$，所以可以知道在<code>3，1，4，2</code>之前有13个排列比它小，那么如果编号从0开始，它的编号就是13，如果从1开始，它的编号就是$13 + 1 = 14$ 。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)res*=n--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; permutation)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(permutation.size())</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">order</span><span class="params">(permutation.begin(),permutation.end())</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">stat</span><span class="params">(length,<span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; length<span class="number">-1</span>; i++)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>);j &lt; length; j++)</span><br><span class="line">			<span class="keyword">if</span>(!stat[j]&amp;&amp;permutation[j]&lt;permutation[i])count++;</span><br><span class="line">		ans+=count*factorial(length-i<span class="number">-1</span>);</span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(order[count]!=permutation[i])count++;</span><br><span class="line">		stat[count] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="康托逆展开"><a href="#康托逆展开" class="headerlink" title="康托逆展开"></a>康托逆展开</h1><p>知道了给定排列求编号的方法之后，那么给定编号求排列就能够反推回去了，以下假设编号从0开始。</p>
<h2 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>假设已知参加排列的所有元素，现在计算在长度为4的排列中，编号从0开始的第13个排列。</p>
<p>用 $13/3! = 2余1$，得出比首位小的数有2个，所以首位为3，</p>
<p>用 $1/2! = 0余1$，得出在剩下的数中比第二位小的数有0个，所以第二位为1，</p>
<p>用 $1/1! = 1余0$，得出在剩下的数中比第三位小的数有1个，所以第三位为4，</p>
<p>那么算到这里只剩下一位，所以第四位也就是最后一位就算2了。</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)res*=n--;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getPermutation</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; original,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(original.size())</span></span>;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">stat</span><span class="params">(length,<span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res,order(original.begin(),original.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i&lt;length;i++)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(factorial(length-i))</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">quotient</span><span class="params">(k/factor)</span></span>;</span><br><span class="line">		k %= factor;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>),count(<span class="number">0</span>);j&lt;length;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!stat[j])count++;</span><br><span class="line">			<span class="keyword">if</span>(count==quotient+<span class="number">1</span>)&#123;</span><br><span class="line">				stat[j] = <span class="literal">true</span>;</span><br><span class="line">				res.push_back(order[j]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;length;i++)</span><br><span class="line">		<span class="keyword">if</span>(!stat[i])</span><br><span class="line">			res.push_back(order[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>康托展开为寻找全排列中的某一项节省了大量本该去回溯的时间与空间，在某些时候不失为一种好的思路。实际上康托展开常用于哈希表构建的空间压缩上，其次，n位数字全排列之后，其康托展开唯一，且最大有 $n! $种排列，因此可以由更小的空间来存储这些排列。</p>
]]></content>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-60-第k个排列</title>
    <url>/2020/03/24/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
<p>给定 n 和 k，返回第 k 个排列。<br>说明：给定 n 的范围是 [1, 9]。给定 k 的范围是[1,  n!]。<br><a id="more"></a></p>
<hr>
<p>该题的意思其实是寻找按字典序排的全排列的第k项。起初我是用的普通求全排列的回溯法，即使是找到第k项就终止查找我的程序还是超时了。那么只好去寻找数学方法了。</p>
<p>通过这道题，确实让我了解了一个新知识：康托展开，即给定一串数字，通过</p>
<script type="math/tex; mode=display">
X=a_1(n-1)!+a_{n-1}(n-2)!+...+a_1*0!，a_i\in Z,0\le a_i<i,1\le i\le n</script><p>这个展开式可以将其定位在其全排列的字典中，得到它的次序。由于康托展开是一个全排列到自然数之间的双射，那么自然是可逆的。那么这道题就是要求逆康托展开了，已知字典序，求其对应的排列。时间复杂度只有o(n^2)。康托展开的研究记在另一篇博客。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">bool</span> stat[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;n;i++)stat[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">1</span>);i&lt;n;i++)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(factorial(n-i))</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">quotient</span><span class="params">(k/factor)</span></span>;</span><br><span class="line">            k %= factor;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>),count(<span class="number">0</span>);j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stat[j])count++;</span><br><span class="line">                <span class="keyword">if</span>(count==quotient+<span class="number">1</span>)&#123;</span><br><span class="line">                    stat[j] = <span class="literal">true</span>;</span><br><span class="line">                    res.push_back(j+<span class="number">49</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;n;i++)<span class="keyword">if</span>(!stat[i])res.push_back(i+<span class="number">49</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)res*=n--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-59-螺旋矩阵</title>
    <url>/2020/03/23/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
    <content><![CDATA[<p>给定一个正整数 n，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。<br>示例:</p>
<blockquote>
<p>输入: 3<br>输出:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]<br><a id="more"></a></p>
<hr>
<p>此题比第一道螺旋矩阵还稍微简单一些，因为矩阵中的元素是确定的且全部都大于0。那么这将会给予判断上的遍历。</p>
</blockquote>
<p>在二维数组初始化的时候将所有位置填为0，依次将数字填入矩阵中。因此循环的判断条件便可设为当前的位置是否已经被填过。而四种状态来辨别填数字的行进方向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> &#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        int stat(0),value(1),i(0),j(0),k(1);</span><br><span class="line">        <span class="keyword">while</span>(ans[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            ans[i][j]=k++;</span><br><span class="line">            <span class="keyword">if</span>(stat==<span class="number">0</span>)&#123;<span class="keyword">if</span>(++j==n<span class="number">-1</span>||ans[i][j+<span class="number">1</span>]!=<span class="number">0</span>)stat++;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stat==<span class="number">1</span>)&#123;<span class="keyword">if</span>(++i==n<span class="number">-1</span>||ans[i+<span class="number">1</span>][j]!=<span class="number">0</span>)stat++;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stat==<span class="number">2</span>)&#123;<span class="keyword">if</span>(--j==<span class="number">0</span>||ans[i][j<span class="number">-1</span>]!=<span class="number">0</span>)stat++;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(--i==<span class="number">0</span>||ans[i<span class="number">-1</span>][j]!=<span class="number">0</span>)stat=<span class="number">0</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>vector容器浅析</title>
    <url>/2020/03/22/c++/vector%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="什么是vector？"><a href="#什么是vector？" class="headerlink" title="什么是vector？"></a>什么是vector？</h1><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。<br><a id="more"></a></p>
<hr>
<h1 id="容器特性"><a href="#容器特性" class="headerlink" title="容器特性"></a>容器特性</h1><ol>
<li>顺序序列<br>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</li>
<li>动态数组<br>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</li>
<li>能够感知内存分配器的（Allocator-aware）<br>容器使用一个内存分配器对象来动态地处理它的存储需求。</li>
</ol>
<hr>
<h1 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote>
<ul>
<li>vector(): 创建一个空vector</li>
<li>vector(int nSize): 创建一个vector,元素个数为nSize</li>
<li>vector(int nSize,const t&amp; t): 创建一个vector，元素个数为nSize,且值均为t</li>
<li>vector(const vector&amp;): 复制构造函数</li>
<li>vector(begin,end): 复制[begin,end)区间内另一个数组的元素到vector中</li>
</ul>
</blockquote>
<h2 id="增加函数"><a href="#增加函数" class="headerlink" title="增加函数"></a>增加函数</h2><blockquote>
<ul>
<li>void push_back(const T&amp; x): 向量尾部增加一个元素X</li>
<li>iterator insert(iterator it,const T&amp; x): 向量中迭代器指向元素前增加一个元素x</li>
<li>iterator insert(iterator it,int n,const T&amp; x): 向量中迭代器指向元素前增加n个相同的元素x</li>
<li>iterator insert(iterator it,const_iterator first,const_iterator last): 向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li>
</ul>
</blockquote>
<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><blockquote>
<ul>
<li>iterator erase(iterator it): 删除向量中迭代器指向元素</li>
<li>iterator erase(iterator first,iterator last): 删除向量中[first,last)中元素</li>
<li>void pop_back(): 删除向量中最后一个元素</li>
<li>void clear(): 清空向量中所有元素</li>
</ul>
</blockquote>
<h2 id="遍历函数"><a href="#遍历函数" class="headerlink" title="遍历函数"></a>遍历函数</h2><blockquote>
<ul>
<li>reference at(int pos): 返回pos位置元素的引用</li>
<li>reference front(): 返回首元素的引用</li>
<li>reference back(): 返回尾元素的引用</li>
<li>iterator begin(): 返回向量头指针，指向第一个元素</li>
<li>iterator end(): 返回向量尾指针，指向向量最后一个元素的下一个位置</li>
<li>reverse_iterator rbegin(): 反向迭代器，指向最后一个元素</li>
<li>reverse_iterator rend(): 反向迭代器，指向第一个元素之前的位置</li>
</ul>
</blockquote>
<h2 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h2><blockquote>
<ul>
<li>bool empty() const: 判断向量是否为空，若为空，则向量中无元素</li>
</ul>
</blockquote>
<h2 id="大小函数"><a href="#大小函数" class="headerlink" title="大小函数"></a>大小函数</h2><blockquote>
<ul>
<li>int size() const: 返回向量中元素的个数</li>
<li>int capacity() const: 返回当前向量所能容纳的最大元素值</li>
<li>int max_size() const: 返回最大可允许的vector元素数量值</li>
</ul>
</blockquote>
<h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><blockquote>
<ul>
<li>void swap(vector&amp;): 交换两个同类型向量的数据</li>
<li>void assign(int n,const T&amp; x): 设置向量中第n个元素的值为x</li>
<li>void assign(const_iterator first,const_iterator last): 向量中[first,last)中元素设置成当前向量元素</li>
</ul>
</blockquote>
<h2 id="通俗来讲"><a href="#通俗来讲" class="headerlink" title="通俗来讲"></a>通俗来讲</h2><blockquote>
<ol>
<li>push_back 在数组的最后添加一个数据</li>
<li>pop_back 去掉数组的最后一个数据</li>
<li>at 得到编号位置的数据</li>
<li>begin 得到数组头的指针</li>
<li>end 得到数组的最后一个单元+1的指针</li>
<li>front 得到数组头的引用</li>
<li>back 得到数组的最后一个单元的引用</li>
<li>max_size 得到vector最大可以是多大</li>
<li>capacity 当前vector分配的大小</li>
<li>size 当前使用数据的大小</li>
<li>resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</li>
<li>reserve 改变当前vecotr所分配空间的大小</li>
<li>erase 删除指针指向的数据项</li>
<li>clear 清空当前的vector</li>
<li>rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</li>
<li>rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</li>
<li>empty 判断vector是否为空</li>
<li>swap 与另一个vector交换数据</li>
</ol>
</blockquote>
<hr>
<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><blockquote>
<ol>
<li>vector&lt;类型&gt; 标识符</li>
<li>vector&lt;类型&gt; 标识符(最大容量)</li>
<li>vector&lt;类型&gt; 标识符(最大容量,初始所有值)</li>
<li>Int i[5] = {1,2,3,4,5}</li>
<li>vector&lt;类型&gt; vi(I,i+2);//得到i索引值为3以后的值</li>
<li>vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</li>
</ol>
</blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据"><a href="#1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据" class="headerlink" title="1. pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据"></a>1. pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;obj;<span class="comment">//创建一个向量存储容器 int</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="comment">// push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.push_back(i);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;obj[i]&lt;&lt;<span class="string">","</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//去掉数组最后一个数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.size();i++)<span class="comment">//size()容器中实际数据个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;obj[i]&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,</span><br></pre></td></tr></table></figure>
<h3 id="2-clear-清除容器中所有数据"><a href="#2-clear-清除容器中所有数据" class="headerlink" title="2. clear()清除容器中所有数据"></a>2. clear()清除容器中所有数据</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.push_back(i);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;obj[i]&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    obj.clear();<span class="comment">//清除容器中所以数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;obj[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</span><br></pre></td></tr></table></figure>
<h3 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line"> </span><br><span class="line">    obj.push_back(<span class="number">1</span>);</span><br><span class="line">    obj.push_back(<span class="number">3</span>);</span><br><span class="line">    obj.push_back(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    sort(obj.begin(),obj.end());<span class="comment">//从小到大</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"从小到大:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;obj[i]&lt;&lt;<span class="string">","</span>;  </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"从大到小:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    reverse(obj.begin(),obj.end());<span class="comment">//从大到小 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;obj[i]&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">从小到大:</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,</span><br><span class="line">从大到小:</span><br><span class="line"><span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br></pre></td></tr></table></figure>
<ol>
<li>注意 sort 需要头文件 <code>#include&lt;algorithm&gt;</code></li>
<li>如果想 sort 来降序，可重写 sort</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a&lt; b; <span class="comment">//升序排列，如果改为return a&gt;b，则为降序 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">76</span>,<span class="number">0</span>,<span class="number">43</span>,<span class="number">24</span>,<span class="number">65</span>&#125;,i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a[i]&lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">sort(a,a+<span class="number">20</span>,compare);</span><br></pre></td></tr></table></figure>
<h3 id="4-访问（直接数组访问-amp-迭代器访问）"><a href="#4-访问（直接数组访问-amp-迭代器访问）" class="headerlink" title="4.访问（直接数组访问&amp;迭代器访问）"></a>4.访问（直接数组访问&amp;迭代器访问）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//顺序访问</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        obj.push_back(i);   </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"直接利用数组："</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//方法一 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;obj[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"利用迭代器："</span> ;</span><br><span class="line">    <span class="comment">//方法二，使用迭代器将容器中数据输出 </span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span></span><br><span class="line">    <span class="keyword">for</span>(it=obj.begin();it!=obj.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">直接利用数组：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">利用迭代器：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h3 id="5-二维数组两种定义方法（结果一样）"><a href="#5-二维数组两种定义方法（结果一样）" class="headerlink" title="5.二维数组两种定义方法（结果一样）"></a>5.二维数组两种定义方法（结果一样）</h3><ul>
<li>方法一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">obj</span><span class="params">(N)</span></span>; <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; obj.size(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">    &#123; </span><br><span class="line">        obj[i].resize(M); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.size(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;obj[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法二</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">obj</span><span class="params">(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M))</span></span>; <span class="comment">//定义二维动态数组5行6列 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.size(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;obj[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>原文地址：<a href="http://blog.csdn.net/w_linux/article/details/71600574" target="_blank" rel="noopener">http://blog.csdn.net/w_linux/article/details/71600574</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-56-合并区间</title>
    <url>/2020/03/22/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>给出一个区间的集合，请合并所有重叠的区间。<br>示例：</p>
<blockquote>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
</blockquote>
<a id="more"></a>
<hr>
<p>最初的想法是先将原数组排序之后，用两个相邻的迭代器，迭代顺序从左往右，判断两者是否能够合并，如果可以那么就删除右迭代器指向的元素，右迭代器指向被删除的元素的后一个元素。如果不能合并，那么就两个迭代器都后移一位，当然，这两个迭代器也可以用一个来实现，因为他们总是相邻的。当信心满满地提交时，结果让人震惊，竟然在运行时间上只击败了5%的人，c++跑了两千多毫秒，但我还觉得当前这个算法已经还不错了。</p>
<p>于是我仔细检查代码中很耗时间的部分。一个应该是sort的排序，另一个是erase的删除元素的部分。但排序在算法中是有必要的，而删除元素主要是慢在vector中删除任意元素的时间复杂度是线性的，即在顺序存储中删除中间元素会将后面所有元素前移一位。那么也没有办法在不删除原数组元素的情况下对合并之后的元素进行筛选呢。很容易想到时间换空间，那么算法也需要进行微调。</p>
<p>先声明一个存储空间来存合并之后或无需合并的元素，再排序。还是用两个迭代器，但在这里就必须是两个了，而不能用一个来代替。可看作快慢指针，慢指针指向第一个元素，快指针指向第二个元素，如果两者能够合并，合并的结果给慢指针，快指针后移一位，如果两者无法合并，这时候才将慢指针元素压入存储空间中，然后慢指针直接跳到快指针的位置，快指针再后移。在结束迭代之后，还要记得将慢指针的元素再往存储空间压入一次。之后返回这个存储空间。</p>
<p>提交完之后，运行时间终于降到了20ms，击败了95%的人。如果还想再优化，就应该在排序上下功夫了。时间复杂度大概是$O(nlogn)$，主要还是排序费时间。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size()&lt;<span class="number">2</span>)<span class="keyword">return</span> intervals;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;::iterator j(intervals.begin()),i(j+1);</span><br><span class="line">        <span class="keyword">for</span> (;i != intervals.end();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j-&gt;at(<span class="number">1</span>) &gt;= i-&gt;at(<span class="number">0</span>)) j-&gt;at(<span class="number">1</span>) = max(j-&gt;at(<span class="number">1</span>), i-&gt;at(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(*j);</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push_back(*j);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-49-字母异位词分组</title>
    <url>/2020/03/21/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。<br>示例:</p>
<blockquote>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[[“ate”,”eat”,”tea”],[“nat”,”tan”],[“bat”]]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>为了区别出这些字符串具有相同数量字母的一类，可以将所有字符串排序来比较它们是否相等，作为哈希表的关键字，每个关键字将映射到一个向量，这个向量由这个关键字在原向量中所有对应的关键字组成。最后再将这个哈希表输出为一个向量即可。</p>
<p>由于unordered_map在查找的时候若无法找到相应的关键字，会自动将其插入到表中，因此我们无需再做多余的判断，通过对原向量的一次迭代便可以将所有的字符串在哈希表中分好类。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> str=i;</span><br><span class="line">            sort(str.begin(),str.end());</span><br><span class="line">            hash[str].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:hash)ans.push_back(i.second);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-50-Pow</title>
    <url>/2020/03/20/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-50-Pow/</url>
    <content><![CDATA[<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。<br>说明:</p>
<blockquote>
<ul>
<li>-100.0 &lt; x &lt; 100.0 </li>
<li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。<a id="more"></a>
</li>
</ul>
<hr>
<p>快速幂算法将传统的循环乘法的时间复杂度降至$O(logn)$。详情见之前研究斐波那契数列的快速幂解法。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">N</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(N&lt;<span class="number">0</span>)N=-N;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(N&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(N&amp;<span class="number">1</span>)sum*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            N&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1</span>/sum:sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-58-最后一个单词的长度</title>
    <url>/2020/03/19/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。如果不存在最后一个单词，请返回 0 。<br>说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。<br>示例:</p>
<blockquote>
<p>输入: “Hello World”<br>输出: 5<br><a id="more"></a></p>
<hr>
<p>先去除末尾的空格，再开始往回遍历，若遇到空格就计算并返回长度，若遍历到第一位说明只有一个单词，所以计算返回值在原基础上+1。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(s.size()<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i]==<span class="number">32</span>)i--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j(i);j&gt;<span class="number">-1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="number">32</span>)<span class="keyword">return</span> i-j;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)<span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-55-跳跃游戏</title>
    <url>/2020/03/19/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。<br>示例：</p>
<blockquote>
<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。<br><a id="more"></a></p>
<hr>
<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>由于这道题归到了树那一类的题，因此看完题目之后很自然的会往基于递归回溯的方面想。其实就是穷举，基本思想就是如果在当前的位置下，所有能够到达的那些位置是符合条件能够到达最后一个位置的位置，那么当前这个位置也是符合条件的位置，那么由此可以写出基本的穷举解法。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> can(<span class="number">0</span>,nums,stat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> begin,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==nums.size()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin + <span class="number">1</span>);i&lt;=min(begin+nums[begin],(<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);i++)</span><br><span class="line">            <span class="keyword">if</span>(can(i,nums,stat))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个解法的效率是很低下的，这个写出来一跑是肯定超时的。空间复杂度$O(n)$，需要的栈空间大小跟n呈线性关系。时间复杂度$O(2^n)$。证明如下：</p>
</blockquote>
<p>从第一个位置跳到最后一个位置最多有$2^n$种方案，其中n是nums数组的长度，令$T(x)$是从x跳到n可能的所有方法，显然$T(n)=1;T(x)=\sum^n_{i=x+1}T(i)$，因为从x可能跳到之后的所有顶点i，每个顶点又有$T(i)$种方案，注意到这是最坏情况。</p>
<script type="math/tex; mode=display">
\begin{align}
T(x)&=\sum^n_{i=x+1}T(i)\\
&=T(x+1)+\sum^n_{i=x+2}T(i)\\
&=T(x+1)+T(x+1)\\
&=2*T(x+1)
\end{align}</script><p>现在通过归纳，假设$T(x)=2^{n-x}$并证明$T(x-1)=2^{n-(x-1)},$</p>
<script type="math/tex; mode=display">
\begin{align}
T(x-1)&=2*T(x)\\
&=2*2^{n-x}\\
&=2^{n-x+1}\\
&=2^{n-(x-1)}\\
\end{align}</script><p>这样我们就得到从位置1开始，$T(1)=2^{n-1}$,最终的复杂度是$O(2^n-1)=O(2^n)$。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="自顶而下"><a href="#自顶而下" class="headerlink" title="自顶而下"></a>自顶而下</h2><p>事实上，回溯法的弊端就在于重复得计算了大量已经知道结果的位置。那么对于回溯法的一种优化方式就是将已经得到结果的位置记录下来，如果递归进行到该位置那么可以直接使用该位置的结果进行回溯，而不需要再把这个位置继续递归计算一遍。那么为了记录每一个位置对于最后位置的到达情况，可以用一个辅助数组来记录。辅助数组长度与原数组长度相同，下标一一对应。用三个状态来表示当前位置对最后的位置可达的情况，比如-1代表情况未知，0代表不可达，1代表可达。因此将辅助数组初始化为最后一位为1，因为最后一位到最后一位当然是可达的，其余位设为-1，都还未知。那么在回溯的过程中每成功判断一个位置的情况之后都需要记录在辅助数组上，所以往下递归只针对那么没有计算到的位置。所以递归的终止条件，也就是回溯的开始条件就是当该位的状态已知，要么0要么1的时候。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stat</span><span class="params">(nums.size()<span class="number">-1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stat.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> can(<span class="number">0</span>,nums,stat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> begin,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stat[begin]!=<span class="number">-1</span>)<span class="keyword">return</span> stat[begin]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin + <span class="number">1</span>);i&lt;=min(begin+nums[begin],(<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);i++)</span><br><span class="line">            <span class="keyword">if</span>(can(i,nums,stat))&#123;</span><br><span class="line">                stat[begin]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        stat[begin]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个解法利用空间换时间，节省了大量重复的计算，空间复杂度为$O(2n)=O(n)$，但在leetcode上跑的时候超内存了，它给的测试用例太恶心了，一屏幕的数字。时间复杂度$O(n^2)$，即对于每个位置的元素都要将该元素后面的元素遍历一遍。</p>
<h2 id="自底而上"><a href="#自底而上" class="headerlink" title="自底而上"></a>自底而上</h2><p>为了消除递归需要的栈空间，我们可以从尾部开始计算辅助数组中的值，为了知道该位置是否对最后的位置可达，只需要将该位置往后所能到达的位置扫描一遍，因为这些位置的状态都是已知的，那么如果有一个可达的位置，那么就得出一个新的可达的位置，将这两重循环进行下去，将会将所有的位置计算一遍，最后再看辅助数组的首位，就能知道首位是否可达了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stat</span><span class="params">(nums.size()<span class="number">-1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stat.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(nums.size()<span class="number">-2</span>);i&gt;<span class="number">-1</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(i+<span class="number">1</span>);j&lt;=min(i+nums[i],(<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(stat[j]==<span class="number">1</span>)stat[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> stat[<span class="number">0</span>]==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于消去了递归所用的占空间，该算法所需的额外空间消耗只有辅助数组的$O(n)$，这个算法在leetcode中总算是没超时或超内存，但一看效率依然很低。时间复杂度两重循环可简单看出是$O(n^2)$。</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>动态规划事实上是一种相当费脑的方法，我认为遇到任何一个问题首先可以考虑贪心法，毕竟相比动态规划要考虑的全局，贪心法只考虑当下就好了。</p>
<p>其实可以把问题先简化为，我从这个位置能否跳到目标位置，如果能到的话，我就可以把目标位置替换成当前位置，那么在当前位置之前的位置如果能到当前位置，也就相当于能够到达目标位置。因此先定义一个目标位置，根据题意，目标位置先定为最后一个位置，再开始从最后一个位置开始一次往回遍历，如果发现有任何一个位置能够到达目标位置，便可以将目标位置换为当前位置。直至遍历结束，容易判断出，第一个位置能够到达最后一个位置的条件就是第一个位置是否能成为上文提到的目标位置。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(nums.size()<span class="number">-1</span>);i&gt;<span class="number">-1</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + i&gt;=index)</span><br><span class="line">                index = i;</span><br><span class="line">        <span class="keyword">return</span> index==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当然还可以从头开始贪婪，这个想法更加简单(贪心)，从第一位开始遍历，用一个变量来记录当前可达的最远位置，直到这个最远位置为最后一个位置。如果当前的位置竟然超过了最大可达位置，那么就可直接得出结论第一位是不可达的。但值得注意的是，并不是发现一个位置的最远位置之后，就可以直接跳到那个最远位置，因为在跳过的这些位置中可能存在着挑更远的位置，所以数组的每一位都要访问到才行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">maxdistance</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;maxdistance)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            maxdistance = max(i+nums[i],maxdistance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结：贪心算法真香！</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-47-全排列II</title>
    <url>/2020/03/18/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-47-%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<blockquote>
<p>输入: <code>[1,1,2]</code><br>输出: [[1,1,2],[1,2,1],[2,1,1]]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>诚然，用集合容器对向量容器去重效率感人，但十分的方便。该题与上一题的区别就是要去重。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">stat</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recall(nums,stat,res,<span class="built_in">queue</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(res.begin(),res.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; stat,<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stat[i])&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(nums[i]);</span><br><span class="line">                stat[i] = <span class="literal">true</span>;</span><br><span class="line">                recall(nums,stat,ans,<span class="built_in">queue</span>);</span><br><span class="line">                stat[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>.size()==nums.size())ans.insert(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-46-全排列</title>
    <url>/2020/03/18/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。<br>示例：</p>
<blockquote>
<p>输入: <code>[1,2,3]</code><br>输出:<br>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br><a id="more"></a></p>
<hr>
<p>就喜欢做这类题意容易理解的题，全排列的思路万变不离其宗，还是要基于深度优先策略。在这里特别的是要用一个状态辅助数组来表示在当前路径中该节点已经被访问过。访问过的节点保存入栈，当栈顶高度与给定数组相同时被认为已经访问到了最深处，于是开始回溯，每回溯一步将状态数组的相应位的状态复原。</p>
</blockquote>
<p>简单来说，在递归树中，状态数组中的元素代表了该树当前节点需要访问的孩子节点。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">stat</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        recall(nums,ans,stat,<span class="built_in">queue</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; stat,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stat[i])&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(nums[i]);</span><br><span class="line">                stat[i] = <span class="literal">true</span>;</span><br><span class="line">                recall(nums,ans,stat,<span class="built_in">queue</span>);</span><br><span class="line">                stat[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>.size()==nums.size())ans.push_back(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-43-字符串相乘</title>
    <url>/2020/03/17/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br>说明：</p>
<ul>
<li>num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 </li>
<li>num1 和 num2 均不以零开头，除非是数字0 本身。</li>
<li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。<a id="more"></a>
</li>
</ul>
<hr>
<p> 按照题目要求，那就是要按照乘法竖式的规则来进行两个字符串的运算，但如果像我们平常手算那样，先将每一位乘以每一位，再将其错位累加，在算法设计上不好实现。但其实竖式里是能够边乘边加的，实质上就是将两个数按位分解。例如</p>
<script type="math/tex; mode=display">
15428=(100+50+4)(20+8)</script><p>因此有以下过程：<br> <image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_43_1.png?raw=true"><br> 先将结果串初始化，其长度不会超过乘数与被乘数之积。外层循环从乘数串的尾部开始往回遍历，内层循环从被乘数的尾部开始往回遍历。将两者相乘之后的个位数应该放在结果串的(i+j+1)位置处（从上图中标红处可以看出i+j+1的位置），并且将高位加到(i+j)处，最后将结果串前面的所有0删除就可以了。逻辑其实就是这么简单，但要将其理清楚还是挺费时间的。做这种逻辑题的时候一定要在纸上画，才能容易找到将其抽象化成代码的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(num1.size()+num2.size(),<span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(num2.size()<span class="number">-1</span>);i&gt;<span class="number">-1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(num1.size()<span class="number">-1</span>);j&gt;<span class="number">-1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=(res[i+j+<span class="number">1</span>]-<span class="string">'0'</span>)+(num1[j]-<span class="string">'0'</span>)*(num2[i]-<span class="string">'0'</span>);</span><br><span class="line">                res[i+j+<span class="number">1</span>]=temp%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">                res[i+j]+=temp/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;num1.size()+num2.size();i++)<span class="keyword">if</span>(res[i]!=<span class="string">'0'</span>)<span class="keyword">return</span> res.substr(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-104-二叉树的最大深度</title>
    <url>/2020/03/16/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。<br><a id="more"></a></p>
<hr>
<p>一道二叉树的很基础的题，核心就是。当前树的高度为左子树和右子树中的大者+1。不得不说，用c++写出这么精简的代码还是很有快感的，也就差不多递归能做到了。时间复杂度与二叉树节点的个数呈线性关系。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root?max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-40-组数总和II</title>
    <url>/2020/03/16/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-40-%E7%BB%84%E6%95%B0%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。<br>说明：</p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<blockquote>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[   [1, 7],  [1, 2, 5],   [2, 6],   [1, 1, 6] ]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>与上一题不同的是，这里候选序列中的元素可能有相同的元素，但每个元素只能用一次。因此在递归的时候应该带入的循环初值为当前层的循环次数。这题比较讨厌的地方在于递归的时候难以处理候选序列有相同的元素的情况，因为这些相同的元素各只能用一次。遍历的时候去重实在是一件很麻烦的事情。所以我只好先用一个集合来存结果，再把结果存成向量。</p>
<p>一定要好好掌握STL的一些容器和算法，这样也好在一筹莫展的时候取取巧。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        recall(candidates,target,<span class="built_in">queue</span>,<span class="number">0</span>,res);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(res.begin(),res.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>,<span class="keyword">int</span> begin,<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin);i&lt;candidates.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                recall(candidates,target - candidates[i],<span class="built_in">queue</span>,i+<span class="number">1</span>,ans);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target - candidates[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                ans.insert(<span class="built_in">queue</span>);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-36-有效的数独</title>
    <url>/2020/03/15/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。 </li>
<li>数字 1-9 在每一列只能出现一次。 </li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3宫内只能出现一次。<br><image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_36_1.png?raw=true"><br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。<br>说明：</li>
</ol>
<blockquote>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 1-9 和字符 ‘.’ 。</li>
<li>给定数独永远是 9x9 形式的。<a id="more"></a>
</li>
</ul>
<hr>
<p>采用三个二维数组来存储每一行每一列每一个九宫格对应数字的个数，遍历一遍进行计数，一旦发现有个数大于2的数字便返回数独无效的信号。常数级时间复杂度。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;,column[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;,box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>); j &lt; <span class="number">9</span>; j++)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)</span><br><span class="line">                   <span class="keyword">if</span>(( ++row[board[i][j]-<span class="string">'1'</span>][i] &gt; <span class="number">1</span>) </span><br><span class="line">                   ||(++column[board[i][j]-<span class="string">'1'</span>][j] &gt;<span class="number">1</span>) </span><br><span class="line">                   ||(++box[board[i][j]-<span class="string">'1'</span>][(i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span>] &gt;<span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-122-买卖股票的最佳时机II</title>
    <url>/2020/03/14/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>示例：</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>这题比上一题还要更贪，也是贪心的思想。由于题目说了必须是买了卖卖了买这样的顺序。那么为了获得更多的钱，一旦发现今天的价格比昨天高就立马卖出去。不然的话就不卖，这样至少可以算出来理论上赚最多是多少钱。实质上就是每一位增量之和。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                max += (prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-121-买卖股票的最佳时机</title>
    <url>/2020/03/14/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。<br>示例：</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>就靠卖股票赚钱这几个字眼都能想到用贪心的思想。由于要的只是那个能赚到的最多的前，那就只考虑当下最好情况就好了。遍历的时候把之前遇到的最低谷记住，将之前的最低谷与当前价格的差值与之前计算得到的最大值比较，若更大就更新，遍历完之后返回最大值即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>],max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            low = Math.min(prices[i],low);</span><br><span class="line">            max = Math.max(prices[i] - low, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-28-实现strStr</title>
    <url>/2020/03/14/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br>示例：</p>
<blockquote>
<p>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>
</blockquote>
<p>说明：<br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。<br><a id="more"></a></p>
<hr>
<p>这道题是一道简单题，所以应该是要求用朴素模式匹配就好了吧。但在明知有KMP算法的情况下就没有必要用朴素算法了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle==<span class="string">""</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    int i(0), j(0);</span><br><span class="line">        <span class="keyword">int</span> *next = getNext(needle);</span><br><span class="line">        <span class="keyword">int</span> *nextval = getNextVal(needle,next);</span><br><span class="line">        <span class="keyword">delete</span>[] next;</span><br><span class="line">	    <span class="keyword">while</span> (i &lt; haystack.size())&#123;</span><br><span class="line">		    <span class="keyword">if</span> (j == <span class="number">-1</span>||haystack[i] == needle[j])&#123;i++;j++;&#125;</span><br><span class="line">		    <span class="keyword">else</span> j = nextval[j];</span><br><span class="line">            <span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">                <span class="keyword">delete</span> []nextval;</span><br><span class="line">                <span class="keyword">return</span> (i - j);</span><br><span class="line">            &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	    int i(0),j(-1);</span><br><span class="line">	    <span class="keyword">while</span> (i &lt; s.size()) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == s[j])next[++i] = ++j;</span><br><span class="line">		    <span class="keyword">else</span> j = next[j];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getNextVal</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span>* next)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">int</span>* nextval = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	    nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt; s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		    <span class="keyword">if</span> (s[next[i]] == s[i]) &#123;</span><br><span class="line">			    nextval[i] = nextval[next[i]];</span><br><span class="line">		    &#125;<span class="keyword">else</span> nextval[i] = next[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> nextval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-119-杨辉三角II</title>
    <url>/2020/03/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
    <content><![CDATA[<p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p><image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_118_1.gif?raw=true"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br><a id="more"></a></p>
<hr>
<p>这题同第118题，还是简化版。当然还有个$O(1)$的方法供参考（狗头）。<br>正常方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; trans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            ans.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i - <span class="number">1</span>;j++)&#123;</span><br><span class="line">                ans.add(trans.get(j)+trans.get(j + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>)ans.add(<span class="number">1</span>);</span><br><span class="line">            trans.clear();</span><br><span class="line">            trans.addAll(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高效法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">pre33</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Integer[][] list = <span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">21</span>,<span class="number">35</span>,<span class="number">35</span>,<span class="number">21</span>,<span class="number">7</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">28</span>,<span class="number">56</span>,<span class="number">70</span>,<span class="number">56</span>,<span class="number">28</span>,<span class="number">8</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">36</span>,<span class="number">84</span>,<span class="number">126</span>,<span class="number">126</span>,<span class="number">84</span>,<span class="number">36</span>,<span class="number">9</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">120</span>,<span class="number">210</span>,<span class="number">252</span>,<span class="number">210</span>,<span class="number">120</span>,<span class="number">45</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">55</span>,<span class="number">165</span>,<span class="number">330</span>,<span class="number">462</span>,<span class="number">462</span>,<span class="number">330</span>,<span class="number">165</span>,<span class="number">55</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">66</span>,<span class="number">220</span>,<span class="number">495</span>,<span class="number">792</span>,<span class="number">924</span>,<span class="number">792</span>,<span class="number">495</span>,<span class="number">220</span>,<span class="number">66</span>,<span class="number">12</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">13</span>,<span class="number">78</span>,<span class="number">286</span>,<span class="number">715</span>,<span class="number">1287</span>,<span class="number">1716</span>,<span class="number">1716</span>,<span class="number">1287</span>,<span class="number">715</span>,<span class="number">286</span>,<span class="number">78</span>,<span class="number">13</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">14</span>,<span class="number">91</span>,<span class="number">364</span>,<span class="number">1001</span>,<span class="number">2002</span>,<span class="number">3003</span>,<span class="number">3432</span>,<span class="number">3003</span>,<span class="number">2002</span>,<span class="number">1001</span>,<span class="number">364</span>,<span class="number">91</span>,<span class="number">14</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">105</span>,<span class="number">455</span>,<span class="number">1365</span>,<span class="number">3003</span>,<span class="number">5005</span>,<span class="number">6435</span>,<span class="number">6435</span>,<span class="number">5005</span>,<span class="number">3003</span>,<span class="number">1365</span>,<span class="number">455</span>,<span class="number">105</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">16</span>,<span class="number">120</span>,<span class="number">560</span>,<span class="number">1820</span>,<span class="number">4368</span>,<span class="number">8008</span>,<span class="number">11440</span>,<span class="number">12870</span>,<span class="number">11440</span>,<span class="number">8008</span>,<span class="number">4368</span>,<span class="number">1820</span>,<span class="number">560</span>,<span class="number">120</span>,<span class="number">16</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">17</span>,<span class="number">136</span>,<span class="number">680</span>,<span class="number">2380</span>,<span class="number">6188</span>,<span class="number">12376</span>,<span class="number">19448</span>,<span class="number">24310</span>,<span class="number">24310</span>,<span class="number">19448</span>,<span class="number">12376</span>,<span class="number">6188</span>,<span class="number">2380</span>,<span class="number">680</span>,<span class="number">136</span>,<span class="number">17</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">18</span>,<span class="number">153</span>,<span class="number">816</span>,<span class="number">3060</span>,<span class="number">8568</span>,<span class="number">18564</span>,<span class="number">31824</span>,<span class="number">43758</span>,<span class="number">48620</span>,<span class="number">43758</span>,<span class="number">31824</span>,<span class="number">18564</span>,<span class="number">8568</span>,<span class="number">3060</span>,<span class="number">816</span>,<span class="number">153</span>,<span class="number">18</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">19</span>,<span class="number">171</span>,<span class="number">969</span>,<span class="number">3876</span>,<span class="number">11628</span>,<span class="number">27132</span>,<span class="number">50388</span>,<span class="number">75582</span>,<span class="number">92378</span>,<span class="number">92378</span>,<span class="number">75582</span>,<span class="number">50388</span>,<span class="number">27132</span>,<span class="number">11628</span>,<span class="number">3876</span>,<span class="number">969</span>,<span class="number">171</span>,<span class="number">19</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">190</span>,<span class="number">1140</span>,<span class="number">4845</span>,<span class="number">15504</span>,<span class="number">38760</span>,<span class="number">77520</span>,<span class="number">125970</span>,<span class="number">167960</span>,<span class="number">184756</span>,<span class="number">167960</span>,<span class="number">125970</span>,<span class="number">77520</span>,<span class="number">38760</span>,<span class="number">15504</span>,<span class="number">4845</span>,<span class="number">1140</span>,<span class="number">190</span>,<span class="number">20</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">21</span>,<span class="number">210</span>,<span class="number">1330</span>,<span class="number">5985</span>,<span class="number">20349</span>,<span class="number">54264</span>,<span class="number">116280</span>,<span class="number">203490</span>,<span class="number">293930</span>,<span class="number">352716</span>,<span class="number">352716</span>,<span class="number">293930</span>,<span class="number">203490</span>,<span class="number">116280</span>,<span class="number">54264</span>,<span class="number">20349</span>,<span class="number">5985</span>,<span class="number">1330</span>,<span class="number">210</span>,<span class="number">21</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">231</span>,<span class="number">1540</span>,<span class="number">7315</span>,<span class="number">26334</span>,<span class="number">74613</span>,<span class="number">170544</span>,<span class="number">319770</span>,<span class="number">497420</span>,<span class="number">646646</span>,<span class="number">705432</span>,<span class="number">646646</span>,<span class="number">497420</span>,<span class="number">319770</span>,<span class="number">170544</span>,<span class="number">74613</span>,<span class="number">26334</span>,<span class="number">7315</span>,<span class="number">1540</span>,<span class="number">231</span>,<span class="number">22</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">253</span>,<span class="number">1771</span>,<span class="number">8855</span>,<span class="number">33649</span>,<span class="number">100947</span>,<span class="number">245157</span>,<span class="number">490314</span>,<span class="number">817190</span>,<span class="number">1144066</span>,<span class="number">1352078</span>,<span class="number">1352078</span>,<span class="number">1144066</span>,<span class="number">817190</span>,<span class="number">490314</span>,<span class="number">245157</span>,<span class="number">100947</span>,<span class="number">33649</span>,<span class="number">8855</span>,<span class="number">1771</span>,<span class="number">253</span>,<span class="number">23</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">24</span>,<span class="number">276</span>,<span class="number">2024</span>,<span class="number">10626</span>,<span class="number">42504</span>,<span class="number">134596</span>,<span class="number">346104</span>,<span class="number">735471</span>,<span class="number">1307504</span>,<span class="number">1961256</span>,<span class="number">2496144</span>,<span class="number">2704156</span>,<span class="number">2496144</span>,<span class="number">1961256</span>,<span class="number">1307504</span>,<span class="number">735471</span>,<span class="number">346104</span>,<span class="number">134596</span>,<span class="number">42504</span>,<span class="number">10626</span>,<span class="number">2024</span>,<span class="number">276</span>,<span class="number">24</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">25</span>,<span class="number">300</span>,<span class="number">2300</span>,<span class="number">12650</span>,<span class="number">53130</span>,<span class="number">177100</span>,<span class="number">480700</span>,<span class="number">1081575</span>,<span class="number">2042975</span>,<span class="number">3268760</span>,<span class="number">4457400</span>,<span class="number">5200300</span>,<span class="number">5200300</span>,<span class="number">4457400</span>,<span class="number">3268760</span>,<span class="number">2042975</span>,<span class="number">1081575</span>,<span class="number">480700</span>,<span class="number">177100</span>,<span class="number">53130</span>,<span class="number">12650</span>,<span class="number">2300</span>,<span class="number">300</span>,<span class="number">25</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">26</span>,<span class="number">325</span>,<span class="number">2600</span>,<span class="number">14950</span>,<span class="number">65780</span>,<span class="number">230230</span>,<span class="number">657800</span>,<span class="number">1562275</span>,<span class="number">3124550</span>,<span class="number">5311735</span>,<span class="number">7726160</span>,<span class="number">9657700</span>,<span class="number">10400600</span>,<span class="number">9657700</span>,<span class="number">7726160</span>,<span class="number">5311735</span>,<span class="number">3124550</span>,<span class="number">1562275</span>,<span class="number">657800</span>,<span class="number">230230</span>,<span class="number">65780</span>,<span class="number">14950</span>,<span class="number">2600</span>,<span class="number">325</span>,<span class="number">26</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">27</span>,<span class="number">351</span>,<span class="number">2925</span>,<span class="number">17550</span>,<span class="number">80730</span>,<span class="number">296010</span>,<span class="number">888030</span>,<span class="number">2220075</span>,<span class="number">4686825</span>,<span class="number">8436285</span>,<span class="number">13037895</span>,<span class="number">17383860</span>,<span class="number">20058300</span>,<span class="number">20058300</span>,<span class="number">17383860</span>,<span class="number">13037895</span>,<span class="number">8436285</span>,<span class="number">4686825</span>,<span class="number">2220075</span>,<span class="number">888030</span>,<span class="number">296010</span>,<span class="number">80730</span>,<span class="number">17550</span>,<span class="number">2925</span>,<span class="number">351</span>,<span class="number">27</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">28</span>,<span class="number">378</span>,<span class="number">3276</span>,<span class="number">20475</span>,<span class="number">98280</span>,<span class="number">376740</span>,<span class="number">1184040</span>,<span class="number">3108105</span>,<span class="number">6906900</span>,<span class="number">13123110</span>,<span class="number">21474180</span>,<span class="number">30421755</span>,<span class="number">37442160</span>,<span class="number">40116600</span>,<span class="number">37442160</span>,<span class="number">30421755</span>,<span class="number">21474180</span>,<span class="number">13123110</span>,<span class="number">6906900</span>,<span class="number">3108105</span>,<span class="number">1184040</span>,<span class="number">376740</span>,<span class="number">98280</span>,<span class="number">20475</span>,<span class="number">3276</span>,<span class="number">378</span>,<span class="number">28</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">29</span>,<span class="number">406</span>,<span class="number">3654</span>,<span class="number">23751</span>,<span class="number">118755</span>,<span class="number">475020</span>,<span class="number">1560780</span>,<span class="number">4292145</span>,<span class="number">10015005</span>,<span class="number">20030010</span>,<span class="number">34597290</span>,<span class="number">51895935</span>,<span class="number">67863915</span>,<span class="number">77558760</span>,<span class="number">77558760</span>,<span class="number">67863915</span>,<span class="number">51895935</span>,<span class="number">34597290</span>,<span class="number">20030010</span>,<span class="number">10015005</span>,<span class="number">4292145</span>,<span class="number">1560780</span>,<span class="number">475020</span>,<span class="number">118755</span>,<span class="number">23751</span>,<span class="number">3654</span>,<span class="number">406</span>,<span class="number">29</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">30</span>,<span class="number">435</span>,<span class="number">4060</span>,<span class="number">27405</span>,<span class="number">142506</span>,<span class="number">593775</span>,<span class="number">2035800</span>,<span class="number">5852925</span>,<span class="number">14307150</span>,<span class="number">30045015</span>,<span class="number">54627300</span>,<span class="number">86493225</span>,<span class="number">119759850</span>,<span class="number">145422675</span>,<span class="number">155117520</span>,<span class="number">145422675</span>,<span class="number">119759850</span>,<span class="number">86493225</span>,<span class="number">54627300</span>,<span class="number">30045015</span>,<span class="number">14307150</span>,<span class="number">5852925</span>,<span class="number">2035800</span>,<span class="number">593775</span>,<span class="number">142506</span>,<span class="number">27405</span>,<span class="number">4060</span>,<span class="number">435</span>,<span class="number">30</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">31</span>,<span class="number">465</span>,<span class="number">4495</span>,<span class="number">31465</span>,<span class="number">169911</span>,<span class="number">736281</span>,<span class="number">2629575</span>,<span class="number">7888725</span>,<span class="number">20160075</span>,<span class="number">44352165</span>,<span class="number">84672315</span>,<span class="number">141120525</span>,<span class="number">206253075</span>,<span class="number">265182525</span>,<span class="number">300540195</span>,<span class="number">300540195</span>,<span class="number">265182525</span>,<span class="number">206253075</span>,<span class="number">141120525</span>,<span class="number">84672315</span>,<span class="number">44352165</span>,<span class="number">20160075</span>,<span class="number">7888725</span>,<span class="number">2629575</span>,<span class="number">736281</span>,<span class="number">169911</span>,<span class="number">31465</span>,<span class="number">4495</span>,<span class="number">465</span>,<span class="number">31</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">32</span>,<span class="number">496</span>,<span class="number">4960</span>,<span class="number">35960</span>,<span class="number">201376</span>,<span class="number">906192</span>,<span class="number">3365856</span>,<span class="number">10518300</span>,<span class="number">28048800</span>,<span class="number">64512240</span>,<span class="number">129024480</span>,<span class="number">225792840</span>,<span class="number">347373600</span>,<span class="number">471435600</span>,<span class="number">565722720</span>,<span class="number">601080390</span>,<span class="number">565722720</span>,<span class="number">471435600</span>,<span class="number">347373600</span>,<span class="number">225792840</span>,<span class="number">129024480</span>,<span class="number">64512240</span>,<span class="number">28048800</span>,<span class="number">10518300</span>,<span class="number">3365856</span>,<span class="number">906192</span>,<span class="number">201376</span>,<span class="number">35960</span>,<span class="number">4960</span>,<span class="number">496</span>,<span class="number">32</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">33</span>,<span class="number">528</span>,<span class="number">5456</span>,<span class="number">40920</span>,<span class="number">237336</span>,<span class="number">1107568</span>,<span class="number">4272048</span>,<span class="number">13884156</span>,<span class="number">38567100</span>,<span class="number">92561040</span>,<span class="number">193536720</span>,<span class="number">354817320</span>,<span class="number">573166440</span>,<span class="number">818809200</span>,<span class="number">1037158320</span>,<span class="number">1166803110</span>,<span class="number">1166803110</span>,<span class="number">1037158320</span>,<span class="number">818809200</span>,<span class="number">573166440</span>,<span class="number">354817320</span>,<span class="number">193536720</span>,<span class="number">92561040</span>,<span class="number">38567100</span>,<span class="number">13884156</span>,<span class="number">4272048</span>,<span class="number">1107568</span>,<span class="number">237336</span>,<span class="number">40920</span>,<span class="number">5456</span>,<span class="number">528</span>,<span class="number">33</span>,<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(pre33.list[rowIndex]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-118-杨辉三角</title>
    <url>/2020/03/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p><image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_118_1.gif?raw=true"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。<br><a id="more"></a></p>
<hr>
<p>很基础的一道和递推关系有关的题，但比斐波那契数列稍微麻烦的是，杨辉三角是由前一行推出后一行，因此除了参与运算的一个序列之外，还要有一个序列用来保存结果。两个序列交替往下，直到满足条件。每一次循环将结果更新一次。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; trans1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; trans2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numRows; i++)&#123;</span><br><span class="line">            trans1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            trans1.add(<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i - <span class="number">2</span> ; j++)</span><br><span class="line">            	trans1.add(trans2.get(j) + trans2.get(j + <span class="number">1</span>));</span><br><span class="line">            trans2.clear();</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>)trans1.add(<span class="number">1</span>);</span><br><span class="line">            trans2.addAll(trans1);</span><br><span class="line">            ans.add(trans1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-17-电话号码的字母组合</title>
    <url>/2020/03/13/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_17_1.png?raw=true"><br>示例：</p>
<blockquote>
<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<p>说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。<br><a id="more"></a></p>
<hr>
<p>这类要求得到可能的所有情况的题，是肯定需要穷举一遍的。因此思路很快就出来了，但由于可能给出的数字个数不确定，因此循环难以达到效果，所以想到递归。那么这题就转化为树的深度优先遍历了，并要用一个序列来存储每一条路径。用一个循环去访问树的同一层的节点。树的层数由候选序列的长度决定，因此递归传入的候选序列长度每次都要减一，直到候选序列变为零意味着递归需要终止。</p>
<p>这题对现在的我来说依然是一道思路五分钟，调bug两小时的题，看来还是要锻炼清晰的思路才行。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; keyboard&#123; <span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">queue</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(digits!=<span class="string">""</span>)recall(digits, <span class="built_in">queue</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">string</span> digits, <span class="built_in">string</span>&amp; <span class="built_in">queue</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!digits.size()) &#123;ans.push_back(<span class="built_in">queue</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>);j &lt; keyboard[digits[<span class="number">0</span>]<span class="number">-50</span>].size();j++) &#123;</span><br><span class="line">            <span class="built_in">queue</span> += keyboard[digits[<span class="number">0</span>]<span class="number">-50</span>][j];</span><br><span class="line">            recall(digits.substr(<span class="number">1</span>, digits.size() <span class="number">-1</span>), <span class="built_in">queue</span>, ans);</span><br><span class="line">            <span class="built_in">queue</span> = <span class="built_in">queue</span>.substr(<span class="number">0</span>, <span class="built_in">queue</span>.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-88-合并两个有序数组</title>
    <url>/2020/03/12/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。<br>说明:</p>
<blockquote>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 </li>
<li>你可以假设 nums1 有足够的空间(空间大小大于或等于m+n)来保存 nums2 中的元素。</li>
</ul>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>由于给定的数组nums1的尾部是有足够空间的，因此应该考虑新有序数组从nums1的后方开始填入，那么可以分别从后往前比较两个数组的元素大小，大的可填入空位并指针前移，直到一个数组为空，将该数组完全填入新数组前部即可。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)nums1=nums2;</span><br><span class="line">        int k(m + n - 1),i(m-1),j(n-1);</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)nums1[k--] =( i &gt;= <span class="number">0</span>&amp;&amp;nums1[i] &gt; nums2[j] )? nums1[i--] : nums2[j--];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-13-罗马数字转整数</title>
    <url>/2020/03/12/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<blockquote>
<p> 字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值<br>I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50<br>C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100<br>D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500<br>M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000</p>
</blockquote>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<blockquote>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li><p>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<a id="more"></a>
</li>
</ul>
<hr>
<p> 这题就是对整数转罗马数字的求逆，对于多分支结构果真还是switch舒服一些，算是遍历串的很基础的内容。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'M'</span>:ans+=<span class="number">1000</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'D'</span>:ans+=<span class="number">500</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'C'</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'D'</span>)&#123;ans+=<span class="number">400</span>;i++;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'M'</span>)&#123;ans+=<span class="number">900</span>;i++;&#125;<span class="keyword">else</span> ans+=<span class="number">100</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'L'</span>:ans+=<span class="number">50</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'X'</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'L'</span>)&#123;ans+=<span class="number">40</span>;i++;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'C'</span>)&#123;ans+=<span class="number">90</span>;i++;&#125;<span class="keyword">else</span> ans+=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'V'</span>:ans+=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'I'</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'V'</span>)&#123;ans+=<span class="number">4</span>;i++;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'X'</span>)&#123;ans+=<span class="number">9</span>;i++;&#125;<span class="keyword">else</span> ans+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-39-组数总和</title>
    <url>/2020/03/11/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-39-%E7%BB%84%E6%95%B0%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。<br>说明：</p>
<blockquote>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>这题乍一看有点像之前的寻找两数和三数和四数和的类型，但是显然情况会多很多，因为允许相加的元素使用多次。那就只好建立一个树，然后采用深度优先搜索算法进行遍历。</p>
<p>首先将候选序列进行排序，排序有两个好处，一是能够去重，二是可以减少搜索时间。用一个栈类型的序列来存储可能满足条件的序列，达到满足条件的时候将该序列追加至结果序列。树的每一层的循环递归搜索应当避免从头开始，由于已经排好序，可以每次递归传入一个参数来确定当前层开始遍历的索引。采用传引用的递归方式可以无需返回值，大大简化了搜索逻辑。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        recall(ans,candidates,<span class="number">0</span>,<span class="built_in">queue</span>,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> begin,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin);i&lt;candidates.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target-candidates[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                recall(ans,candidates,i,<span class="built_in">queue</span>,target - candidates[i]);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                ans.push_back(<span class="built_in">queue</span>);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-12-整数转罗马数字</title>
    <url>/2020/03/11/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<blockquote>
<p>字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值<br>I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50<br>C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100<br>D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500<br>M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000</p>
</blockquote>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<blockquote>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。<br><a id="more"></a></p>
<hr>
<p>这个问题其实很简单，就是把这个限定范围的数字拆解之后用给定规则的字母表达出来，时间复杂度必然是$o(1)$，因为变换规则始终是有限的，数字如果还要增大就需要加入新的规则。</p>
</blockquote>
<p>看了其他那些大佬的题解之后，我承认自己的想法挺弱智，毕竟他们想到了贪心算法。但下图已经让我很满足：</p>
<p><image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_12_1.png?raw=true"><br>贪心算法实质上是对于当前状态的数字，寻找能够拆分成的最大字母，然后两者相减得到新的数字，也就是把我的条件判断整合成循环而已。当然，以后贪心算法还是要好好研究的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(num/<span class="number">1000</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"M"</span>;</span><br><span class="line">            num %=<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">900</span>)&#123;</span><br><span class="line">            ans+=<span class="string">"CM"</span>;</span><br><span class="line">            num -=<span class="number">900</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">500</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">500</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"D"</span>;</span><br><span class="line">            num %=<span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">400</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"CD"</span>;</span><br><span class="line">			num -=<span class="number">400</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"C"</span>;</span><br><span class="line">            num %=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">90</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"XC"</span>;</span><br><span class="line">			num-=<span class="number">90</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">50</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">50</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"L"</span>;</span><br><span class="line">            num %=<span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">40</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"XL"</span>;</span><br><span class="line">			num-=<span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"X"</span>;</span><br><span class="line">            num %=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">9</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"IX"</span>;</span><br><span class="line">			num-=<span class="number">9</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"V"</span>;</span><br><span class="line">            num %=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">4</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"IV"</span>;</span><br><span class="line">			num-=<span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(num)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"I"</span>;</span><br><span class="line">            num-=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-66-加一</title>
    <url>/2020/03/10/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<br>示例：</p>
<blockquote>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br><a id="more"></a></p>
<hr>
<p>将一个数字加一，大多数情况其实就是把它的个位数加一，但还有一种特殊情况，就是要进位的时候。那就直接模拟加法竖式的进位，由于是加一，还是简化版。</p>
</blockquote>
<p>判断出最低位为9，那么需要进位，进位的同时该位置0，看上一位，如果非9，那么直接加一，否则重复上述步骤。一直到所有位都为9的时候，也就是从后往前已经遍历到第一位的时候，这时候表明所有位已经都是0了。那么为了在开头插入一个1，有个巧妙的方法就是数组第一位置1，最后一位插入一个0。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = digits.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i]==<span class="number">9</span>)&#123;</span><br><span class="line">                digits[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    digits[i] = <span class="number">1</span>;</span><br><span class="line">                    digits.push_back(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> digits;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-53-最大子序和</title>
    <url>/2020/03/09/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:</p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<p>进阶:<br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。<br><a id="more"></a></p>
<hr>
<p>时间复杂度为$O(n)$的算法：<br>这个算法其实就是贪心算法，总是考虑加上现在遍历到的这个数是否会比现在大，会的话就算上，不会的话之前的序列就不要了，从现在这个元素开始看有没有新的序列比较大。由于有一个变量用来实时保存最大序列和，所以遍历整个序列之后，总能得到一个最大的子序和。时间复杂度$O(n)$，空间复杂度$O(1)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        int n(1),sum(nums[0]),ans(nums[0]);</span><br><span class="line">        <span class="keyword">while</span>(n&lt;nums.size())&#123;</span><br><span class="line">            sum = max(nums[n] + sum,nums[n]);</span><br><span class="line">            ans = max(sum,ans);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然还有一种形式上差不了太多，就是多一个指针，用滑动窗口的方法也能做出来，算是动态规划。至于题目里面说到的那个“更为精妙的分治法”，这个问题貌似确实能用分治法，但更为精妙就…没感受出来。<br>以下是leetcode官方题解中的分治法，时间复杂度$O(nlogn)$，空间复杂度$O(logn)$</p>
<blockquote>
<p>当最大子数组有 n 个数字时：<br>若 n==1，返回此元素。<br>left_sum 为最大子数组前 n/2 个元素，在索引为 (left + right) / 2 的元素属于左子数组。<br>right_sum 为最大子数组的右子数组，为最后 n/2 的元素。<br>cross_sum 是包含左右子数组且含索引 (left + right) / 2 的最大值。</p>
<p><image src="https://pic.leetcode-cn.com/3aa2128a7ddcf1123454a6e5364792490c5edff62674f3cfd9c81cb7b5e8e522-file_1576478143567"><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftSubsum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> currSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p; i &gt; left - <span class="number">1</span>; --i) &#123;</span><br><span class="line">      currSum += nums[i];</span><br><span class="line">      leftSubsum = Math.max(leftSubsum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightSubsum = Integer.MIN_VALUE;</span><br><span class="line">    currSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; right + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      currSum += nums[i];</span><br><span class="line">      rightSubsum = Math.max(rightSubsum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftSubsum + rightSubsum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftSum = helper(nums, left, p);</span><br><span class="line">    <span class="keyword">int</span> rightSum = helper(nums, p + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> crossSum = crossSum(nums, left, right, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), crossSum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-22-括号生成</title>
    <url>/2020/03/09/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<blockquote>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]<br><a id="more"></a></p>
<hr>
<p>这道题一开始看到的时候，直觉告诉我要要遍历一棵树才能得到这样一个穷举的序列，但实在是太麻烦了。</p>
</blockquote>
<p>后面想到动态规划的思想，可以把从1个括号的组合开始，到n个括号的组合这样的一个个序列看成一个个状态。细心可以发现，第n个状态是可以用第n-1个状态推出来的。即，第n个状态就是在第n-1的所有状况的基础上多出来一对括号，现在就只需要讨论这多出来的一对括号如何摆放。</p>
<p>假设将要加入的那一对括号固定，假设前一个状态被分为两个子序列p，q，并且p，q也同样是满足题意的两个状态，这样才能保证组合成的状态n是有效的。之后也就是反过来将已有的序列插入两个括号中四个位置中的两个位置。由于p的长度为0到n-1，对于每一个p都有q = n-1-p，因此可以有以下两种插法：</p>
<blockquote>
<p>“(“ + p + “)” + q<br>p + “(“ + q + “)”</p>
</blockquote>
<p>可以发现两种插法其实是等效的，所以只需要取一种就可以保证不重复。那么直观一些可以用递归的方法。对每一个p求对应的q，由于p和q都分别是所对应状态的一组序列，所以要将他们递归求出之后再分别遍历并两两组合，将组合的结果放入答案序列中。</p>
<p>递归的方法很简洁直观，但递归树呈二叉树的形态发展，时间空间复杂度惊人。非递归化的方法就是在外面套一层循环，将迭代算出的结果放入定义好的数据结构中，再用已有的数据去算下一个状态。</p>
<p>实质上这题就是要发现状态n与状态n-1之间的关系，这样会很好做。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)ans.push_back(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> p:generateParenthesis(i))</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> q:generateParenthesis(n<span class="number">-1</span>-i))</span><br><span class="line">                    ans.push_back(<span class="string">"("</span>+p+<span class="string">")"</span>+q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-48-旋转图像</title>
    <url>/2020/03/08/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。<br>说明：<br>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。<br>示例：</p>
<blockquote>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br><a id="more"></a></p>
<hr>
<p>这题乍一看很复杂，实质上就是将矩阵逆置一次，再左右翻转一次。整个的时间复杂度是$O(n^2)$，n是方阵阶数。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[j][i];</span><br><span class="line">                matrix[j][i] = matrix[i][j]^matrix[j][i];</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;matrix.length/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[i][matrix.length-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][matrix.length-j-<span class="number">1</span>] = matrix[i][j]^matrix[i][matrix.length-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[i][matrix.length-j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-38-外观数列</title>
    <url>/2020/03/08/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<blockquote>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>
</ol>
</blockquote>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。<br>注意：整数序列中的每一项将表示为一个字符串。</p>
<a id="more"></a>
<hr>
<p>虽然是简单题，但读题都花了好长时间。弄懂了什么意思之后，还找了很久是不是第n个字符串和n之间有什么关系。目前是，没有。</p>
<p>只好按照递推关系做，显然这种递推关系既可以用循环也可以用递归。虽然递归会有$O(n)$的空间消耗，但毕竟写起来舒服，对于n-1的字符串的扫描操作，递归和循环是一样的。循环只不过是在不用调用自身的基础上，在外面又套了一层循环而已。下面是耗费空间打败5%用户的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        <span class="built_in">string</span> str = countAndSay(n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">string</span> strnext = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;str.size();i++)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">counter</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">while</span>(str[i]==str[i+<span class="number">1</span>])&#123;</span><br><span class="line">                counter++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            strnext=strnext + (<span class="keyword">char</span>)(counter+<span class="number">48</span>)+str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-35-搜索插入位置</title>
    <url>/2020/03/07/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。<br>示例：</p>
<blockquote>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
</blockquote>
<a id="more"></a>
<hr>
<p>既然这种题都能出出来，摆明了不能用暴力解法。除此之外就是二分查找了，由于我二分查找喜欢让左右边界紧挨就停止循环，这样就不需要在每次缩小范围的时候进行边界判断，而只需要在结束状态做判断就行了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        int i(0),j(nums.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i+j)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&lt;target)i=k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[k]&gt;target)j=k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>当然还有作弊解法。。而且原理就是二分查找：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-61-旋转链表</title>
    <url>/2020/03/07/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
</blockquote>
<a id="more"></a>
<hr>
<p>这题里说的旋转，实质上就是找到倒数第k个节点，将其断开，再将前半段尾接到后半段上，就完成了所谓的旋转。</p>
<p>需要注意的是，k的值是有可能大于整个链表长度的，所以应该用链表长度对k取模，这样才是需要断开节点的位置。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p(head),*q(head);</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)&#123;p = p-&gt;next;size++;&#125;</span><br><span class="line">        k %=size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;k;i++)q = q-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(p = head;q-&gt;next;q=q-&gt;next,p=p-&gt;next);</span><br><span class="line">        q-&gt;next = head;</span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-34-在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/03/06/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。<br>示例：</p>
<blockquote>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>看到这个要求的时间复杂度，那么还是考虑二分查找。当找到目标值时以该值为中心往两边查找边界，有个特殊情况就是当左边界为0或右边界为最后一位的时候两个指针的值不需要改变。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        int i(0),j(nums.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i+j)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&lt;target)i=k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[k]&gt;target)j=k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i=j=k;</span><br><span class="line">                <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==target)i--;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;nums.size()<span class="number">-1</span>&amp;&amp;nums[j]==target)j++;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=target)i++;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]!=target)j--;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-21-合并两个有序链表</title>
    <url>/2020/03/06/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p>
<blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<a id="more"></a>
<hr>
<p>思路十分的简单，确立一个新链表的指针，两个分别指向原有序链表的指针，从头开始比较两个链表指向节点元素的大小，把小的给新链表，小的指针后移。直到短的那个链表遍历完成。最后只要将长的链表剩下的一段全部给新链表就下了。单链表就是方便在成批的复制数据。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = l1,*q = l2,*k = head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;=q-&gt;val)&#123;</span><br><span class="line">                k-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            k = k-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        k-&gt;next = p?p:q;</span><br><span class="line">        ListNode *ans = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-9-回文数</title>
    <url>/2020/03/05/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br><a id="more"></a></p>
<hr>
<p>从题目可以看出，负数不可能是回文数，首先排除。对于整数，若将其反转，回文数的数值大小应该保持不变。因此思路就出来了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> reverse=<span class="number">0</span>,y = x;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(reverse&gt;INT_MAX/<span class="number">10</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            reverse = reverse*<span class="number">10</span> + y%<span class="number">10</span>;</span><br><span class="line">            y/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (reverse==x)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-20-有效的括号</title>
    <url>/2020/03/05/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<a id="more"></a>
<hr>
<p>栈的应用在括号匹配这一方面体现的极为契合。但有一点，栈空的时候不能弹出元素或访问栈顶元素，因此我将一个可辨识的元素压入栈底作为标识。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        brackets.push(<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">'['</span>||s[i]==<span class="string">'&#123;'</span>)brackets.push(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(brackets.top()==<span class="string">'('</span>)brackets.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(brackets.top()==<span class="string">'['</span>)brackets.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(brackets.top()==<span class="string">'&#123;'</span>)brackets.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> brackets.top()==<span class="string">'0'</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列解法</title>
    <url>/2020/03/03/algorithms/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E8%A7%A3%E6%B3%95/</url>
    <content><![CDATA[<p>由于计算时间复杂度是研究数据结构与算法的一项非常重要的工作，现在以经典的求解斐波那契数列的第n项为例，探讨各个算法的时空复杂度。<br><a id="more"></a></p>
<h1 id="斐波那契数列简介"><a href="#斐波那契数列简介" class="headerlink" title="斐波那契数列简介"></a>斐波那契数列简介</h1><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：</p>
<blockquote>
<p>$1、1、2、3、5、8、13、21、34、……$</p>
</blockquote>
<p>在数学上，斐波那契数列以如下被以递推的方法定义：</p>
<script type="math/tex; mode=display">
F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n \ge 3，n \in N^*）</script><p>在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用。</p>
<p>由斐波那契的定义式可看出，这是一个递归定义，由前后递推关系得出的一个数列。</p>
<hr>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><p>直接由定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Fibonacci(<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>递归的时间复杂度计算方式为递归的次数乘以函数体内执行的语句数，而在这里只涉及到递归的次数。每个函数均要调用两次递归，递归的深度为$(n-2)$，那么容易得到这种算法的时间复杂度为$O(2^n)$。</p>
<p>如果要从数值上准确计算执行时间，那么就是将数列的一般公式</p>
<script type="math/tex; mode=display">
F(n)=F(n - 1)+F(n - 2)（n \ge 3，n \in N^*）</script><p>转化为二阶常系数齐次差分方程。</p>
<p>当$F(0)=1，F(1)=1$时，为了求$F(n)$，可以得到特征方程为$x^2-x-1=0$，解得$x=\frac{(1\pm\sqrt5)}2$ ，<br>因此$F(n)$的通解为$F(n)=C1(\frac{(1+\sqrt5)}2)^n + C2(\frac{(1-\sqrt5)}2)^n$，再将$F(0)=1，F(1)=1$作为初值带入解得$C1，C2$。因此其资源消耗是极其恐怖的，假设要求数列的第五项，其所对应的递归树如图所示：</p>
<pre class="mermaid">graph TB
d1("fbi(5)")-->d2("fbi(4)")
d2("fbi(4)")-->d4("fbi(3)")
d4("fbi(3)")-->d8("fbi(2)")
d1("fbi(5)")-->d3("fbi(3)")
d3("fbi(3)")-->d6("fbi(2)")
d2("fbi(4)")-->d5("fbi(2)")
d3("fbi(3)")-->d7("fbi(1)")
d4("fbi(3)")-->d9("fbi(1)")</pre>



<p>可以从图中看到，数列第三项计算了两次，数列第二项计算了三次，数列第一项计算了三次。这个算法慢的本质其实是调用了过多重复计算的项。</p>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>递归算法的空间复杂度等于递归深度乘以每次递归需要的辅助空间，因此应该是$O(n)$。</p>
<hr>
<h1 id="尾递归解法"><a href="#尾递归解法" class="headerlink" title="尾递归解法"></a>尾递归解法</h1><p>由于照抄定义的直接递归解法效率过低，这里就提出了一种优化方案，以减少重复计算数列中项的次数，但代价是要传入两个初值作为参数，换句话说，这样递归的方向就是把普通递归的方向反过来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">3</span>)<span class="keyword">return</span> a + b;</span><br><span class="line">	<span class="keyword">return</span> Fibonacci(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Fibonacci(<span class="number">1</span>,<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>由于尾递归将所有的运算提到递归语句之前因此减少了大量的回调，可直接返回递归最深层的返回值。而从该递归的递推关系可以理解为，要求前两项为1，1的斐波那契数列，那就不断的调用自身的累加计算，结束条件就是加够(n-2)次，因此递归深度就是(n-2)，由此可得时间复杂度为$O(n)$。递归树如下：</p>
<pre class="mermaid">graph LR
d1("fbi(1,1,5)")-->d2("fbi(1,2,4)")
d2("fbi(1,2,4)")-->d3("fbi(2,3,3)")
d3("fbi(2,3,3)")-->d4("fbi(3,5,2)")</pre>



<p>尾递归在改善递效率上有着很好的效果。</p>
<h2 id="空间复杂度分析-1"><a href="#空间复杂度分析-1" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>尾递归依然是递归，在空间的开销上就注定比较大，因为递归深度为(n-2)，因此斐波那契数列的尾递归算法空间复杂度为$O(n)$。</p>
<hr>
<h1 id="循环算法"><a href="#循环算法" class="headerlink" title="循环算法"></a>循环算法</h1><p>这种算法算是抛弃了递归的弊端，直接将递推公式写在了循环里，也可以理解为动态规划的思想，但事实上，循环和递归本身也有许多相似之处，他们对于初值，运算的条件都有限制。这是一种性能尚佳，容易想出的算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int j(1), k(1);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> t = k;</span><br><span class="line">		k = j + t;</span><br><span class="line">		<span class="keyword">if</span> (k &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		j = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j + k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fibonacci(<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>根据循环的条件以及终止条件可以看出，循环体将执行(n-3)次，因此时间复杂度为$O(n)$。</p>
<h2 id="空间复杂度分析-2"><a href="#空间复杂度分析-2" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>由于该算法只使用了常数级的辅助空间，因此原地工作的空间复杂度为$O(1)$。</p>
<hr>
<h1 id="矩阵快速幂解法"><a href="#矩阵快速幂解法" class="headerlink" title="矩阵快速幂解法"></a>矩阵快速幂解法</h1><h2 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h2><p>首先介绍一下快速幂算法，在计算机中，如果要计算$m^n$，通常的朴素算法是在循环中将m乘n次，但是有些时候这种算法的效率较为低下。</p>
<p>不妨设想，假如我要在记事本中将 “ hello world! “ 这句话复制1000份，如果是朴素算法，那就是连按1000下的p。但我们显然有更高效的方法，比如先将一句话复制10遍，再全选，再复制10遍，再全选，再复制10遍。转化为代数式就是：<script type="math/tex">1000=10^3=10^0*10^1*10^2</script></p>
<p>这样做的效率将大大增加，快速幂的思想就是源于此，本质就是通过指数的分解，降低进行乘法的次数，因此该算法重点研究的就是指数的分解。</p>
<p>以上是快速幂在手算中比较直观的体验，但是在计算机中，效率还会更高。因为二进制表示法中，移位可以代替大量的乘除法，并且开销极小。</p>
<p>下面来看计算$3^{13}$，为了将其分解为能够进行移位运算的模式，需要将指数拆分成2的次幂的和，并确保项数最小。那么就可以拆分成：<script type="math/tex">13=1*2^3+1*2^2+0*2^1+1*2^0</script></p>
<p>的形式，而这也正好契合了二进制数的基本形态，13的二进制恰好是1101，因此可以从低位至高位依次扫描每一位。进一步观察，拆分之后的每一项的前者与后者呈平方关系，并且系数由二进制数的对应位所确定。因此算法的基本框架就成型了。很显然，系数为0的项数是不需要算的，并且需要计算的乘法只包括前一项向后一项的平方递推，还有该位系数为1时可以将对应的该项乘入结果。</p>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>但如何将快速幂运算与斐波那契数列的求解结合呢。<br>由斐波那契数列的定义式：</p>
<script type="math/tex; mode=display">
F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n \ge 3，n \in N^*）</script><p>如果将其写成矩阵形式，将会是：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&1\\1&0
\end{bmatrix}\times
\begin{bmatrix}
F(n-1)\\F(n)
\end{bmatrix}=
\begin{bmatrix}
F(n-2)\\F(n-1)
\end{bmatrix}</script><p>那么其与幂运算之间的关系将会一目了然，由于初值为 <script type="math/tex">\begin{bmatrix}1\\1
\end{bmatrix}</script>，</p>
<p>现在要求解斐波那契数列就能转化为求 <script type="math/tex">\begin{bmatrix}1\\1
\end{bmatrix}\times\begin{bmatrix}1&1\\1&0\end{bmatrix}^{n-2}</script>，</p>
<p>其结果的第一行第一行第一列的元素就是我们所要求的斐波那契数列的第n项。根据快速幂运算的原理，只是通过拆分指数的方式就能达到提高效率的目的。因此只需要将对普通数的快速幂运算中的底数换为矩阵，将乘法换为矩阵乘法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrix_Multiplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m1, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span>* ans = <span class="keyword">new</span> <span class="keyword">long</span>[n*n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>); j &lt; n; j++)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k(<span class="number">0</span>);k &lt; n;k++) &#123;</span><br><span class="line">				sum += m1[i+k*n] * m2[k+j*n];</span><br><span class="line">			&#125;</span><br><span class="line">			ans[i+j*n] = sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m1.clear();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; n * n;i++)m1.push_back(ans[i]);</span><br><span class="line">	<span class="keyword">delete</span>[] ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n-=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; sum&#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>)matrix_Multiplication(sum, m, <span class="number">2</span>);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		matrix_Multiplication(m, m, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; m&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	fibonacci(<span class="number">30</span>, m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>由于上述用到的矩阵乘法恒为计算二阶方阵的乘法，因此单次乘法计算运行时间为常数级。由于每一次拆项都将n右移一位，而结束条件是n右移到0的时候。将n右移一位就相当于将n除以2，因此循环体内语句进行的次数应该为$log_2n$，因此时间复杂度为$O(logn)$。</p>
<h2 id="空间复杂度分析-3"><a href="#空间复杂度分析-3" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>由于该算法只用到了常数级的辅助空间，因此空间复杂度为$O(1)$。</p>
<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>个人是对于斐波那契数列的美妙之处十分的赞叹，而光是该数列的求解算法就能直接列出来四种。并且也可以看出，算法的高效与否，在于程序员的倾注程度，比如说如果就按照定义来的递归求解，这根本不费脑子，却有着极低的效率，再看矩阵的幂运算，为了其算法的高效，在主算法之前还要做矩阵相关的铺垫。可以说，为了提高运行效率，写多几行代码是很有必要的，就好像是程序员替愚蠢的CPU想到了很多避免重复计算的情况，所以要写下来告诉CPU。这四个算法也告诉我们，递归一定要慎用。</p>
]]></content>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-8-字符串转换整数</title>
    <url>/2020/03/03/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例：</p>
<blockquote>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br><a id="more"></a></p>
<hr>
<p>本来字符串转整数是一件很简单的事情，但题干却加了很多限制条件，强行增加程序设计时要考虑的范围。可以先用一个循环跳过所有的非正负号和数字字符，由于从高位开始读取数字，因此在累加的时候记得移位。时间复杂度$O(n)$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> bol = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; str.size() &amp;&amp; str[i] == <span class="string">' '</span>)++i;</span><br><span class="line">		<span class="keyword">if</span> (i == str.size())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">'-'</span>) &#123; bol = <span class="number">-1</span>; ++i; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'+'</span>) &#123; bol = <span class="number">1</span>; ++i; &#125;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; str.size() &amp;&amp; str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">			res = res * <span class="number">10</span> + str[i++] - <span class="number">48</span>;</span><br><span class="line">			<span class="keyword">if</span> (res &gt; INT_MAX) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bol == <span class="number">1</span>)<span class="keyword">return</span> INT_MAX;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">return</span> INT_MIN;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res * bol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-14-最长公共前缀</title>
    <url>/2020/03/03/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br>示例：</p>
<blockquote>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br><a id="more"></a></p>
<hr>
<p>在算法储备还不太足的情况下我还是采用了这种按位比较的方法，效率不算慢，而且还很好想。练了一段时间的题，中等难度的题可能会花特别久时间，简单题还算是一看就有思路，很快就写出来了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">1</span>)<span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;=strs[<span class="number">0</span>].size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">1</span>);j&lt;strs.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;strs[j].size())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[j][i]==strs[<span class="number">0</span>][i])</span><br><span class="line">                        &#123;<span class="keyword">if</span>(j==strs.size()<span class="number">-1</span>)ans=strs[<span class="number">0</span>].substr(<span class="number">0</span>,i+<span class="number">1</span>);&#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-7-整数反转</title>
    <url>/2020/03/02/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例：</p>
<blockquote>
<p>输入: 123<br>输出: 321</p>
<p>输入: -123<br>输出: -321</p>
<p>输入: 120<br>输出: 21</p>
</blockquote>
<p>注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<br><a id="more"></a></p>
<hr>
<p>将原数不断除10可以从左往右依次得到每一位，然后累加。需要注意的是每次累加需要将原数*10保证移位。还有在判断是否溢出的时候需要在溢出之前判断，如果想在溢出之后再判断的话就直接报错了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;INT_MAX/<span class="number">10</span>||ans&lt;INT_MIN/<span class="number">10</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans = ans*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-54-螺旋矩阵</title>
    <url>/2020/03/02/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>示例：</p>
<blockquote>
<p>输入:<br>[<br>&nbsp; [ 1, 2, 3 ],<br>&nbsp; [ 4, 5, 6 ],<br>&nbsp; [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]<br><a id="more"></a></p>
<hr>
<p>这道题的意思也就是说需要换一种方式输出这个二维数组，那么就需要我们去为此制定一条规则。</p>
</blockquote>
<p>对于整个数组，指针的移动一共可以有四种方向，因此指定四种状态。在循环中每种不同的状态对应的指针移动策略都不同，并且要有边界判断，当到达这个边界的时候边界要缩小，并且切换下一种状态。而这四种状态是不断地轮流切换的。而循环的终止条件可以设立为答案数组中的元素个数大于等于原矩阵中元素个数的时候。</p>
<p>这个规则还是很容易想的，但卡住人的还是在边界判断上，比如下面表示左或上边界的那个start，我就在那里卡了很久，本来我在第三第四种状态的边界条件成立的时候都把start++了，但事实证明触及左边界或上边界的时候只需要在先触及的那一次加就够了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(ans);</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        bool row(true),column(true);</span><br><span class="line">        int m(matrix.size()),n(matrix[0].size());</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="number">0</span>)</span></span>;    </span><br><span class="line">        int i(0),j(0);</span><br><span class="line">        <span class="keyword">while</span>(ans.size()&lt;matrix.size()*matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">            ans.push_back(matrix[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(row&amp;&amp;column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(++j&gt;=n)&#123;--j;++i;column=!column;--n;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(row&amp;&amp;!column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(++i&gt;=m)&#123;--i;--j;row = !row;--m;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!row&amp;&amp;!column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--j&lt;start)&#123;++j;--i;column = !column;++start;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!row&amp;&amp;column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--i&lt;start)&#123;++i;++j;row = !row;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-29-两数相除</title>
    <url>/2020/03/01/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。<br>示例：</p>
<blockquote>
<p>输入: dividend = 10, divisor = 3<br>输出: 3<br>输入: dividend = 7, divisor = -3<br>输出: -2</p>
</blockquote>
<p>说明：</p>
<blockquote>
<p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>起初看到这道题的时候我以为我二十分钟必AK，但事实还是证明我太小看这道难度中等的题了。一开始很容易想到，将除法转化为减法，每减一次就让答案加一，直到把被除数减得比除数要小，那么就返回。这样确实简单，但这样的话如果遇到大数除小数的情况，时间开销就会非常大。</p>
<p>要想减少时间开销，就得减少用减法的次数，但又不能用乘除法。那就只剩下移位运算了，用移位再加上加减法理论上可以代替任何的乘除法。例如:$10=2^3+2^1$</p>
<p>计算机组成原理里面有提及到计算机内部的除法运算，在这时候就可以用高级语言的移位运算来模拟一遍了。而算法步骤就是由除法运算的竖式得来。在循环体中，先将被除数向右移位，从可移动的最大值开始往小试，直到刚好比除数大，因为在这个时候我们才可以开始往竖式上填入商中一位。之后将得到的这一位加到答案中，这里要注意每一位都差了一个数量级，因此要将答案左移之后再加上去。而竖式的每一步，被除数其实都在减少，那么减少的数应该是商中那一位的数值乘以除数，为了将剩下的位数补齐，所以需要将除数左移至与被除数对齐。之后再用新的被除数来除。</p>
<p>这个算法代码的可读性貌似不怎么好，但也不失为一种好的解题方法，我们从小学开始便学习乘法与除法的竖式解法，但令人惊奇的是到现在才对其中的含义似懂非懂，才开始去认真审视其中的原理。除此之外，在解算法题的过程中如果能想到平时就会手工运用的算法，也不失为一种好的选择。</p>
<p>最后还是吐槽一下这道题，由于对输入输出都有范围限制，导致又在判断程序的边界条件上浪费了很多时间，真的吐血。还有，虽是小学的算法，实现起来也蛮抽象的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == divisor) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = dividend == INT_MIN;</span><br><span class="line">        <span class="keyword">if</span>(flag) dividend += <span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="keyword">bool</span> same = dividend &gt; <span class="number">0</span> ^ divisor &gt; <span class="number">0</span>;</span><br><span class="line">        dividend = <span class="built_in">abs</span>(dividend);</span><br><span class="line">        divisor = <span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dividend &gt;&gt; i;</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) + (temp &gt;= divisor);</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= divisor) dividend -= divisor &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> same ? -res - <span class="number">1</span>  :(res != INT_MAX ? res + <span class="number">1</span> : res);</span><br><span class="line">        <span class="keyword">return</span> same ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-5-最长回文子串</title>
    <url>/2020/02/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度1000。<br>示例 1：</p>
<blockquote>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<a id="more"></a>
<hr>
<p>根据题目中的提示，这样的最长回文子串应该有两种，一种是中心字符有两个相同的，另一种是中心字符只有一个。如果采用中心展开查找的方式的话，就应该分开两种方式查找。</p>
<p>中心展开用双指针的方式，用两个指针位置之差来比较子串长度，最后返回的子串应该是从前指针截断至后指针。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,counter = <span class="number">1</span>,max = <span class="number">0</span>,left,right,start = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//odd</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            counter = <span class="number">1</span>;</span><br><span class="line">            left = i - <span class="number">1</span>;</span><br><span class="line">            right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&gt;-<span class="number">1</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                counter+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(counter&gt;max)&#123;</span><br><span class="line">                start = left + <span class="number">1</span>;</span><br><span class="line">                max = counter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//even</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counter=<span class="number">2</span>;</span><br><span class="line">                left = i-<span class="number">1</span>;</span><br><span class="line">                right = i+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&gt;-<span class="number">1</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">                    left--;</span><br><span class="line">                    right++;</span><br><span class="line">                    counter+=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(counter&gt;max)&#123;</span><br><span class="line">                    start = left + <span class="number">1</span>;</span><br><span class="line">                    max = counter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-24-两两交换链表中的节点</title>
    <url>/2020/02/29/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例：</p>
<blockquote>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.<br><a id="more"></a></p>
<hr>
<p>属于链表的基础操作，最优的方法自然是双指针对链表进行迭代交换了，时间复杂度$O(n)$，空间复杂度$O(1)<br>$，不好的地方就是思考两个节点交换的方式得在纸上画出来才一目了然，用递归的方法可以使代码更简洁也更清晰，步骤仍然是递归三部曲：<br>1、找终止条件，显然递归到链表为空或者只有一个节点的时候无法完成交换操作为止。<br>2、找返回值，每一次递归调用的返回值都是一个已经完成交换的子链表。<br>3、找交换过程，对于目前交换的元素来说，换到后面的那个连接的下一个节点应该是以下一个节点为头节点的子链表，而这个子链表应该也是用这个函数本身求出。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* realhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        realhead-&gt;next = head;</span><br><span class="line">        ListNode* p = realhead;</span><br><span class="line">        ListNode* q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q&amp;&amp;q-&gt;next)&#123;</span><br><span class="line">            p-&gt;next=q-&gt;next;</span><br><span class="line">            q-&gt;next=q-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;next=q;</span><br><span class="line">            p=p-&gt;next-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> realhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//recursion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *temp;</span><br><span class="line">        ListNode *fi=head-&gt;next;</span><br><span class="line">        temp=fi-&gt;next;</span><br><span class="line">        fi-&gt;next=head;</span><br><span class="line">        head-&gt;next=swapPairs(temp);</span><br><span class="line">        <span class="keyword">return</span> fi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-19-删除链表的倒数第N个节点</title>
    <url>/2020/02/28/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p>说明：给定的 n 保证是有效的。<br>进阶：你能尝试使用一趟扫描实现吗？</p>
<a id="more"></a>
<hr>
<p>单向链表无法存储自己的上一个节点的位置，而这道题给出要求删除节点的次序却是倒数的。在尾部次序未知的情况下，我认为是不可能做到成功删除的。那么正常的思路应该是先遍历一遍得到链表的长度，再通过链表长度与给定的n的差值关系确定要删除元素的正序，然后再遍历一遍进行删除。</p>
<p>但是又看到了进阶说明——用一趟扫描，也就是一趟遍历。那么也容易想到，要减少遍历次数，遇事不决双指针嘛。让快指针先移动n步，再让快慢指针一起移动，直到快指针移动到链表尾部。这么看来，确实是遍历了一遍，但本质上跟最原始的办法也没有区别啊，还多用了一个指针。遍历两遍的那个全程只动了一个指针，而这个遍历一遍，却动了两根指针。虽然在同一个循环体内，代码也是依次执行的，所以这两种方式的时间复杂度是同样的线性的。我认为这个遍历一次并没有什么太大意义。</p>
<p>这道题需要注意的地方是，当测试员给出只包含两个节点的链表时，如果没有头节点的帮助，恐怕很难精确地处理这种情况。所以如果给出的链表没有头节点的话，手动加上头节点也是不错的选择。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next)<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="function">struct ListNode <span class="title">realhead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        realhead.next = head;</span><br><span class="line">        ListNode* p = &amp;realhead;</span><br><span class="line">        ListNode* q = &amp;realhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)q=q-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q&amp;&amp;q-&gt;next)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next =q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>( q == head )head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-2-两数相加</title>
    <url>/2020/02/28/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<a id="more"></a>
<hr>
<p>这种题，连数字的在链表中的排序都是按照从低位向高位，那么明摆着就是要将传统的手算加法的规则转化为链表的操作而已。</p>
<p>需要注意的是，两个链表的加法运算，应该以长的链表结束为准来结束运算，而短的链表在缺少的部分理应用0来参与加法运算。</p>
<p>最后还是觉得用java来写跟链表或者地址，指针有关的东西，没内味儿，下次写链表的题还是用cpp吧。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>,x,y;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            x = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            y = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-33-搜索旋转排序数组</title>
    <url>/2020/02/27/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例：</p>
<blockquote>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p>
</blockquote>
<a id="more"></a>
<hr>
<p>看到这个时间复杂度必须是$O(logn)$级别，那么很自然的就想要要用二分法。二分法的精髓在于对一个有序数组，可以通过逐步缩小首位指针的范围，直到范围无法再缩，就能够锁定需要查找的数的位置了。</p>
<p>但这题特殊在，它不是严格的有序数组，而如果对它进行排序，则会打乱我们要找的数的索引，所以不能排序。但即使这样，这个数组也是部分有序的，在二分查找中，只要合理的条件判断，也能够顺利进行下去。</p>
<p>主要说一下如何进行二分：对于中间点与目标点的大小关系的两种情况，再加入与数组首位元素的比较，一共可分为六种情况可确定二分范围缩小的范围，分类如下图。</p>
<image src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_33_1.png?raw=true">

<p>当然，如果想追求代码简洁，可以适当化简逻辑表达式。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        int i(0),j(nums.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)<span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==target)<span class="keyword">return</span> j;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i+j)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&lt;nums[<span class="number">0</span>])j=k<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[<span class="number">0</span>])j=k<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> i=k+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[k]&lt;target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&gt;nums[<span class="number">0</span>])i=k+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[<span class="number">0</span>])j=k<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">else</span> i=k+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP模式匹配算法</title>
    <url>/2020/02/26/algorithms/KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>这几天复习到数据结构的串的模式匹配，看到KMP算法那么寥寥几行的代码，原本觉得这部分内容很简单，直到我开始尝试去理解它，我才发现我跟大佬的差别。</p>
<a id="more"></a>
<p>之后我花了整整一天半的时间研究这个算法，期间除了吃饭睡觉拉屎，去楼下药店帮拿了一点口罩之外，没有干其他任何事，总算是理解的差不多了。总结一下这个算法，对于模式串本身，如果经常出现重复的子串，用KMP算法确实可以比朴素模式匹配算法快上不少，但要是模式串前后几乎没几个一样的字符时，KMP算法就是用来秀操作的，因为我相信绝大多数的模式串都是短小精悍的，关键词什么的。要是自己写的话还容易纠结于下标的控制。虽然好像听说考研只会在选择题里考手工算next数组，但我还是想把这个无聊的算法彻底弄明白。下面谈谈我目前为止对这个算法的思考。</p>
<hr>
<h1 id="KMP算法的基本思路"><a href="#KMP算法的基本思路" class="headerlink" title="KMP算法的基本思路"></a>KMP算法的基本思路</h1><p>KMP算法，是名分别为K、M、P的三个美国大佬发明的，算是对传统的朴素模式匹配算法的改进。我们先规定，讨论模式串下标均从1开始。朴素模式匹配算法就不谈了，这个有脑子就能想出来，但朴素模式匹配算法存在一个弊端——当模式串有较多重复元素存在时，主串指针i其实做了很多没有必要的回溯。</p>
<p>而如果想跳过这些没有必要比较的情况，那么就可以想到，主串指针是没有必要回退的，因为当发生与模式串失配的情况时，可以确定的是，此前成功匹配的若干元素形成的字串，其实就是模式串的一个真字串，那么对于这样的一个字串，它的头部和尾部如果发生了重复，就只需要往回移动模式串指针就好了，但是又不需要往回移到初始位置，因为我们看到他的头部和尾部发生了重复，又由于这个头部重复的部分与现在主串指针前的那个模式串真字串重复，而这部分就是真字串的尾部，所以最有利的做法应该是将模式串指针移动至头部重复字串的后一位，再来与当前的主串指针比较。这样，就避免了主串的回溯，单就这个算法本身，简单来看时间复杂度应该是$O(n)$。</p>
<p>以下是KMP主代码，对于模式串每一个位置发生失配模式串指针所应该回溯的位置，用一个叫next的整型数组来存储，发生失配时直接用里面的数据来对模式串指针进行回溯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPmatch</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(needle==<span class="string">""</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	int i(0), j(0);</span><br><span class="line">	<span class="keyword">int</span> *next = getNext(needle);</span><br><span class="line">	<span class="keyword">int</span> *nextval = getNextVal(needle,next);</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; haystack.size())&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span>||haystack[i] == needle[j])&#123;i++;j++;&#125;</span><br><span class="line">		<span class="keyword">else</span> j = nextval[j];</span><br><span class="line">		<span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] nextval;</span><br><span class="line">			<span class="keyword">return</span> i - j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="确定模式串指针的回溯位置"><a href="#确定模式串指针的回溯位置" class="headerlink" title="确定模式串指针的回溯位置"></a>确定模式串指针的回溯位置</h1><p>但问题来了，如何确定在模式串的不同位置发生失配时模式串指针需要回溯的位置呢？我们可以发现，这些位置的确定，只跟模式串有关，并且对于每一个需要求的位置，只跟从模式串当前位置截断，取前者的这个字串有关。我们如果要来求这个神秘的next数组，就只需要看包含模式串第一位的模式串的各个字串就好。根据上述的推理，这个位置应该是这个字串前后重复的部分+1。到这里，我们可能自以为问题就解决了，以后我们遇到每一个模式串，手动去算一下它的next数组就好了。</p>
<p>可是呢，懒人总是有的，他就是不想去算这个next数组，觉得太麻烦了，怎么办呢，交给计算机算吧，所以又展开了一系列头脑风暴，被认为是KMP算法的核心，next数组的求解以及其原理。</p>
<h1 id="next数组代码实现原理"><a href="#next数组代码实现原理" class="headerlink" title="next数组代码实现原理"></a>next数组代码实现原理</h1><p>为了放松一下，先来看下代码吧：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	int i(0),j(-1);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; s.size()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == s[j])next[++i] = ++j;</span><br><span class="line">		<span class="keyword">else</span> j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>是不是觉得很简单，就是这么简单的代码我研究了一天半。来讲解一下。</p>
<h2 id="传统思维"><a href="#传统思维" class="headerlink" title="传统思维"></a>传统思维</h2><p>在明白了next数组各个元素应该怎么填之后，我们的惯性思维就是将问题转化为，对于一个字符串，求其包含头部元素的每一个真字串的头部和尾部重复的最大部分。对了，为什么要的是最大重复个数，我的理解是，为了跳步骤，有辣么多重复的不跳，干嘛去挑一个短的来跳，对于这一点网上很多博客的说法有点复杂，我这个还挺好理解的。好，话说回来，为了解决这个问题，让我们先往暴力法方向想下，好不好将其代码化。我们人脑的思维是，看着这个串，看开头，看结尾，不重复，这次看长一点，看开头，看结尾，还是不重复，如此下去，直到找到重复的，但还要最长的重复串啊，好吧，那就继续…这个思路要翻译成代码，那就是要定义两个指针，一个用来指向头部，一个用来指向尾部，再定义一个变量，在循环中以这个变量的值不大于原串的长度为基准来循环，再再定义一个变量，用来记录最大重复串长度，每次比较之后选择性更新。这跟刚刚贴出来的代码相比，那真是又臭又长，主要是不怎么优雅。我们虽是懒人，代码的优雅性还是得考虑的，就这么简单的事情要搞两层循环？？我们KMP主函数的复杂度才$O(n)$呢，好吧，要说优化的方法，那肯定是有的。</p>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>有时候觉得学计算机，数学的用处不大，但有时候，数学学的好确实能让你这个麻木的码农变得更加优雅。我的理解是，考虑数学归纳法，用递推关系来求next数组的元素。我们要找的是某个子串的头部与尾部重复的最大长度，那么直接用头部来匹配尾部不就好了，那我们就用尾部作为模式串来匹配头部。既然是归纳法，那就先考虑一般情况，先看中间。假设尾部指针指到了i这个位置，尾部指针指到了j这个位置，而且现在已经知道前面的结果，那么就只剩下两种情况，如果next[i]等于next[j]，考虑到一般情况下（如果指针不越界）next[i-1]=next[j-1]，那么重复的最大子串长度只要在原来的基础上加一，所以next[i]的值应该是数组起始位置到j目前位置的长度，那么就是j-0=j，那么直接将j的值给next[i]好了；另外一种情况，next[i]不等于next[j]，根据KMP算法的规则，不就是找包含模式串第一位一直到i-1位的这个子串的头部与尾部的最大重复长度吗，而且正好，这个值就在next[j]里面，因为next[j]的意思就是如果匹配到i位发生失配，模式串指针应该跳到next[j]这个位置，所以就直接将next[j]赋值给j，让j跳回去重新跟i比较。这样就形成一个循环体，还有一个问题，如果跳回去的过程中一直失配，那不就回不来了，那怎么行，模式串指针可是有一个下限的，那就是0，情况坏也得从0开始比较吧。如果j = -1的时候也需要让i和j都移动一位，那就可以让匹配一直进行下去了。</p>
<p>既然是数学归纳法，考虑完一般情况，还得考虑初值情况。我们说j是子串头部指针，i是子串尾部指针，开始的时候长度起码是2吧，不然的话就不用匹配了，这样的话就令j为-1，i为0，next[0]为-1，也就是说如果第一个位置就失配的话，那就让i无脑后移，然后j也可以到模式串的第一个位置。这样的好处是，由于j为-1，进入循环体之后i就能开始后移，j就算回跳到next[0]，也能够顺利进入让i进入到后移比较的阶段。也可以看出，在next数组里，除了next[0]为-1，后面的元素就都不可能是-1了。还能发现，next[1]肯定是0。整个算法过程如下图(这张图的下标从1开始，原理是一样的)：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS92Mi00N2IyNmRiNjY1OTM3NzQyMGY0MzI2YzMyOTZiYWE5OV9iLndlYnA?x-oss-process=image/format,png" alt="过程图"></p>
<p>这个算法巧妙的利用已知条件递推下一个答案，直到得到所有的答案。可是到了这里，大多数人觉得KMP算法告一段落了，但，还没完。</p>
<h1 id="KMP算法的优化"><a href="#KMP算法的优化" class="headerlink" title="KMP算法的优化"></a>KMP算法的优化</h1><p>目前的next数组令模式串的j指针在失配的回跳，但有的时候会连续回跳，而每一次的回跳都伴随着与主串的比较，如果每次回跳到的那个模式串的值等于目前失配的值的话，那还不如让模式串指针一次性跳到后面目标位置，一样的值就没有必要再次比较了。所以就引出了KMP算法的优化措施，将next数组转化为nextval数组，用来避免模式串j指针回跳之后的值等于目前的值而做的重复的比较。那么将next数组转化为nextval数组的方法也很简单，下标的定义仍然值得注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span>* next)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* nextval = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt; s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[next[i]] == s[i]) &#123;</span><br><span class="line">			nextval[i] = nextval[next[i]];</span><br><span class="line">		&#125;<span class="keyword">else</span> nextval[i] = next[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nextval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>算上求next数组这一部分，整个KMP模式匹配算法的时间复杂度就大致是$O(m+n)$了，m是模式串的长度，n是主串的长度。网上其他的讲解基本会用到前缀后缀的概念，那样可能讲述起来会更严谨，但也不易懂。但总的来说，困扰大部分人的是难以理解如何让自己来匹配自己，但准确来讲，是用自己的尾部去匹配自己的头部，然后就是头部尾部指针的初值设定，搞清楚这两点，那就成功十之八九了。</p>
<p>不过我感觉我上述抽象的地方描述的也不算好，但算法这种东西，就是得花时间去磨，有些部分确实是难以言传的。总之，懂的人自然懂，不懂的人花时间磨，总能磨出来的。最后，向那些脑洞大开想出这种奇葩算法的三人组致敬。</p>
]]></content>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-6-Z字形变换</title>
    <url>/2020/02/24/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<blockquote>
<p>L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R<br>   E&nbsp;&nbsp;T&nbsp;&nbsp;O&nbsp;&nbsp;E&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;G<br>   E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N</p>
</blockquote>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：</p>
<blockquote>
<p>“LCIRETOESIIGEDHN”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：<br><a id="more"></a></p>
<hr>
<p>第一眼看到这道题的时候，愣是没弄懂这题在讲什么，看了半天才知道是到数学题，就是找规律。那就很简单了，直接把字符串中对应每一个字符的位置与新的位置形成映射，遍历一遍，就出来了。</p>
</blockquote>
<p>然而显示很残酷，在计算公式的时候，我抱怨过无数次我的脑子寄存器不够用，根本难以理清关系。后来想到新建一个二维数组，真的以Z字形将字符串存入，再按行遍历，但这方法似乎太笨了些，知道后来看到了一个大佬的想法，才一语惊醒梦中人。</p>
<p>先将图画出来，可以直观的看出各元素的位置结构。先初始化numRows个容器来存储每一行的元素。总体上可以以numRows-1个元素作为一个周期，为什么是numRows-1个，看图看出来的。排除完特殊情况之后，遍历原字符串，计算可得出每一个元素所在的周期数和位序，但是其实周期也分两类，偶数和奇数，可以看出这两类周期的元素对于Z字形的行号的递增方向是不同的，所以用当前周期对二取模可辩别这是奇数还是偶数周期，再分别将字符压入相应的行中。遍历完成之后，将这numRows个容器拼接，就是所求字符串。</p>
<p>了解完这种解法，我只能发出由衷的感叹：妙啊！这就是所谓的数学直觉吗。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">t</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">1</span>||numRows&lt;<span class="number">1</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cycle = i/(numRows<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> order = i%(numRows<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cycle%<span class="number">2</span>==<span class="number">0</span>)t[order].push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> t[numRows-order<span class="number">-1</span>].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)ans+=t[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-3-无重复字符的最长子串</title>
    <url>/2020/02/23/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例：</p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>实质上是以每个字符开始为基准，看它们接下来最长的无重复字符串有多长。</p>
<p>窗口初始指针i=j=0，使用 HashSet 将字符存储在当前窗口 [i, j)中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p>
<p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，通常这种类似于字符串的模式匹配都可以用窗口法来分析。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;<span class="keyword">else</span> set.remove(s.charAt(i++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-31-下一个排列</title>
    <url>/2020/02/22/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<blockquote>
<p><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
</blockquote>
<a id="more"></a>
<hr>
<p>根据题意，要将一个数组表达的数字重排列成一个比原来大，但要尽量小的一个数，如果这样的数不存在则返回重排列成表达最小的数。因此显然要从低位开始比较，也就是从数组的尾部沿着一个升序往回找，直到寻找路径不升反降为止。再考虑替换升序数组的后一位，最后将原来所谓的升序数组反转即可。</p>
<p>具体操作是：令遍历升序数组的指针i位于数组尾部，往回寻找升序数组结束的位置，比如遍历到某一位，发现遍历的上一位的值比目前这一位要大，这时候用指针j记录下这一位的位置，再让指针i往原数组的尾部遍历，找到一位刚好比指针j对应元素大的元素，将这两个元素的位置互换，此时指针j后面部分的元素必然是降序的，因此将它们反转就能得到答案。</p>
<p>这题表明，遍历数组之前要充分搞透原数组向目标数组的变化规律（可以用画图的方法），再用代码实现就显得游刃有余了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = nums.length - <span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                j = i++;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;nums.length&amp;&amp;nums[i]&gt;nums[j])i++;</span><br><span class="line">                swap(nums,j++,i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(i = nums.length - <span class="number">1</span>;j&lt;i;i--,j++)swap(nums,i,j);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>,i = nums.length - <span class="number">1</span>;j&lt;i;i--,j++)swap(nums,i,j);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">        nums[j] ^= nums[i];</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-27-移除元素</title>
    <url>/2020/02/21/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>此题显然应当用双指针，但与删除重复元素那道题不同的是，此题需要删除指定元素，也就是说如果两个指针如果像之前那样，从同一侧出发，快指针赋值给慢指针的方式，势必会出现很多虽然合法，但是冗余的元素。这时候应当要换一种思维方式，让一个指针访问过的元素避免被另一个指针再次访问，但依然是一个指针主要负责检查，另一个指针负责遍历。</p>
<p>排除完特殊情况之后，首先令检查指针位于0处，遍历指针位于nums.length-1处，比较检查指针所对应的元素是否是target, 如果是的话就把遍历指针对应元素的值传入，遍历指针便可以往低位移动一次，否则就直接将检查指针向高位移动一次，继续检查，由于循环体每次要么移动检查指针，要么检查遍历指针，而无论是检查指针自身移动到的等于target的元素，还是遍历指针传入的等于target的元素，都会因为这个等于target的条件，继续被遍历指针的新元素所覆盖。所以到最后检查指针所经过的区域就是去除完所有target的数组，还保证了其他元素的完整性。</p>
<p>双指针的应用一定要根据具体题目快速判断，灵活运用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                nums[i] = nums[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-26-删除排序数组中的重复项</title>
    <url>/2020/02/21/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<a id="more"></a>
<hr>
<p>这题当初想了很久，但最后没想到思路这么简单。原地修改数组，要么比较之后赋值，要么比较之后交换，而这里显然赋值就好，因为后面不需要的部分可以不用管。总体的趋势就是令数组前面的重复元素逐渐被后面不重复的元素取代，到最后如果不存在新的元素，那么就返回前面算得的那一段数组的长度。</p>
<p>首先是去重，当数组长度小于二时，就不存在元素什么重不重复了，直接返回数组长度。</p>
<p>如果长度大于二，就依然是双指针的做法，因为已经排好序了，所以重复的同一个元素一定是紧挨着的。将快指针与慢指针比较，如果发现两者相同，那么就慢指针不动，快指针后移一位，继续发现下一个不同的元素，如果不同，将慢指针后移一位，将快指针的值赋给慢指针。这样即可保证慢指针及其之前的元素都不重复，直到快指针遍历完数组所有的元素，慢指针作为结果数组的最后一位，需要返回的值即是慢指针后面那一位的下标，这才是不重复数组的数组长度。</p>
<p>快慢指针大概也算一个很典型的双指针思想，慢指针用来保存记录已经得到的东西，而用快指针在前面搜寻，与前面比较，时间复杂度$O(n)$。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>)<span class="keyword">return</span> nums.size();</span><br><span class="line">        int i(0),j(1);</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.size();j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=nums[i])</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-18-四数之和</title>
    <url>/2020/02/20/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<blockquote>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  &nbsp;&nbsp;[-1,  0, 0, 1],<br>  &nbsp;&nbsp;[-2, -1, 1, 2],<br>  &nbsp;&nbsp;[-2,  0, 0, 2]<br>]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>我快吐了，两数和，三数和，又来个四数和，难道真的没题出了吗，不如出个n数和好了。四数和的做法我想应该可能会有低于$O(n^3)$时间复杂度的算法，但我是想不出来了（下次一定想）。</p>
<p>还是参考三数和的做法，也就是比三数和多了一个遍历指针，中间多了一层循环，在细节处理上稍复杂一些，还是很考验debug能力的。</p>
<p>废话不多说，上代码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">4</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">            <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; nums.length;)&#123;</span><br><span class="line">                b = a+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(b&lt;nums.length - <span class="number">2</span>)&#123;</span><br><span class="line">                    c = b + <span class="number">1</span>; d = nums.length - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(c&lt;d)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[b] +nums[c] + nums[d]==target - nums[a])&#123;</span><br><span class="line">                            ans.add(Arrays.asList(nums[a],nums[b],nums[c],nums[d]));</span><br><span class="line">                            c++;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c-<span class="number">1</span>])c++;</span><br><span class="line">                            d--; <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d+<span class="number">1</span>])d--;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] &lt;target - nums[a])&#123;</span><br><span class="line">                            c++;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c-<span class="number">1</span>])c++;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            d--;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d+<span class="number">1</span>])d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    b++;<span class="keyword">while</span>(b&lt;nums.length - <span class="number">2</span>&amp;&amp;nums[b]==nums[b-<span class="number">1</span>])b++;</span><br><span class="line">                &#125;</span><br><span class="line">                a++;<span class="keyword">while</span>((a &lt; nums.length)&amp;&amp;(nums[a]==nums[a-<span class="number">1</span>]))a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-16-最接近的三数之和</title>
    <url>/2020/02/19/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：</p>
<blockquote>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<a id="more"></a>
<hr>
<p>此题的遍历方式与之前的寻找三数之和等于0类似，这题简单在只需要返回那个最接近目标数的三数和因此不需要去重，稍微复杂在这个最接近。</p>
<p>首先还是先对数组进行一次排序，以便指针的全面查找。用一个变量ans来存储目前最接近目标数的结果，初值可随意赋三个确定数组元素的和，比如初始ans = nums[0] + nums[1] + nums[2]。</p>
<p>令指针i做最外层循环，j，k做内层循环，始终保持i &lt; j &lt; k。因此对于每一个i，j的初值为i + 1，k的初值均为nums.length - 1, 比较此时算出的和与此前算得的ans，若更接近目标数则替换，k与j同时移动，若算出的和比target小，则移动指针j，若大，则移动k，否则便是相等，可直接返回，因为此时与目标数是最接近为0，且不可能存在更接近的数了。搜寻直到j &gt;= k，再看下一个的i，对应的j，k。</p>
<p>总之，在数组里要同时访问一定数目的元素的指针设定和移动是大同小异的，应当要会融会贯通。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>, k = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[j] + nums[k] + nums[i];</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(target - sum) &lt; Math.abs(target - ans))</span><br><span class="line">                    ans = sum;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-15-三数之和</title>
    <url>/2020/02/18/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br> [<br> &nbsp; &nbsp;[-1, 0, 1],<br> &nbsp; &nbsp;[-1, -1, 2]<br>]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>这道题用暴力法搜寻需要 $O(n^3)$ 的时间复杂度，这里我依然用的是增加搜寻指针的方法，需要两次遍历，将时间复杂度降为$O(n^2)$。</p>
<p>首先是排除特殊情况。</p>
<p>先将数组从小到大排序。定义三个指针i，j，k，开始时i为指向数组第一个位置，j指向数组第二个位置，k指向数组最后一个位置。i的值在最外层增加，j，k，用于对于每一个nums[i]，寻找另外两个符合条件的值。为了保证遍历的有序，必须遵循i&lt;j&lt;k这个基本条件。</p>
<p>先看此时nums[i] + nums[j] +nums[k] 是否为0，如果是，那么就找到了一个符合条件的值，将此三元组放入答案集合中，同时将j和k左移或右移，为什么要同时移动？因为如果只移动其中一个，我们将来要找的对应的剩下那个值其实已经找到了，而数组是已经排好序的，所以搜寻的值只会越来越大或越来越小，现在情况就是nums[i] + nums[j] +nums[k]， 在nums[i]固定的情况下，num[j]如果增大了，nums[k]就必须减小才有可能找到新的三元组。</p>
<p>再看，如果nums[i] + nums[j] +nums[k] 不为0，那么我们就要想办法让指针往有利于让其等于0的方向移动，这里就可以分两种情况，一种是得到的值比0大，我们希望这个减小，按照数组的有序性，必须让k指针左移才能让值减小，之后再作判断，此时如果同时移动两个指针，将可能会少遍历到一些组合。另外一种情况也是以此类推，直到j&gt;=k的时候可以将i指针右移，然后j的初值再赋为i+1，k的初值为数组长度-1，开始寻找对于一个新的nums[i]，符合条件的nums[j]，nums[k]，直到i的位置到了整个数组的倒数第三个。</p>
<p>在每次移动指针的时候要按照题目进行去重处理，方法就是用一个while循环，因为有序数组的话相同的值一定是相邻的，在指针需要移动的时候比较移动前后的值，若相等则继续移动一个单位，注意的是循环条件还需要满足外层循环的条件，否则可能会数组下标越界。i的去重也同理。</p>
<p>这道题同时用到了有序数组的特性和多指针比较法来减少循环次数，不过其实想到一个办法之后能够快速的用代码实现才是更重要的，要是花大量的时间来debug就有点亏了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j, k;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&lt;=<span class="number">0</span>&amp;&amp;i&lt;nums.length -<span class="number">1</span>)&#123;</span><br><span class="line">                j = i+<span class="number">1</span>; k = nums.length -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]==-nums[k])&#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i],nums[j],nums[k]));</span><br><span class="line">                        j++;k--;</span><br><span class="line">                        <span class="keyword">while</span>(nums[j]==nums[j-<span class="number">1</span>]&amp;&amp;j&lt;k)j++;</span><br><span class="line">                        <span class="keyword">while</span>(nums[k]==nums[k+<span class="number">1</span>]&amp;&amp;j&lt;k)k--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span>(nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;i&lt;nums.length-<span class="number">1</span>)i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-11-盛最多水的容器</title>
    <url>/2020/02/17/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p><img src="https://github.com/Delta1181485139/images/blob/master/algorithms/leetcode_11_1.png?raw=true"></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例：</p>
<blockquote>
<p>输入: [1,8,6,2,5,4,8,3,7]</p>
<p>输出: 49</p>
</blockquote>
<a id="more"></a>
<hr>
<p>除了$O(n^2)$的暴力法之外，可以用双指针来完成一次遍历，近用$O(n)$找到这个最大的容积。</p>
<p>一开始，指针i位于数组最左侧，指针j位于数组最右侧，用一个变量maxvolume来存储迄今为止得到的最大容积，每次的移动指针都需要将此时算得的容积与旧值比较，若大则更新，否则继续移动指针。由题意可以得知，我们要求的这个容积的值取决于短的那根垂线，对于两根垂线中短的那一根，如果定住指针不动，移动另一指针，无论以后这一边的高是多少，也不可能再找到一个可以比现在更大的容积了。所以指针移动的策略是，比较height[i]与height[j]的大小，谁小就移动谁，直到i&gt;=j,遍历停止，这样的话，maxvolume的值会按正确方向向答案靠拢。</p>
<p>通过使用双指针的方法，通常可以减少一个数量级的时间复杂度，但是需要着重考虑指针移动的策略，以避开不需要的比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxvolume = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            maxvolume = Math.max(maxvolume, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxvolume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现flybird小游戏</title>
    <url>/2020/02/16/python/python%E5%AE%9E%E7%8E%B0flybird%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>前段时间了解到python里pygame这个库，突发奇想用python来做一些有趣的小东西，随即就想到了读初中时候那个火了好一阵子失传已久的小游戏—flybird。 游戏逻辑很简单，可以用来体验一下pygame这个强大的将游戏开发专注于游戏逻辑本身的模块。</p>
<a id="more"></a>
<hr>
<h1 id="整个小游戏的生命周期"><a href="#整个小游戏的生命周期" class="headerlink" title="整个小游戏的生命周期"></a>整个小游戏的生命周期</h1><h2 id="小游戏预览图"><a href="#小游戏预览图" class="headerlink" title="小游戏预览图"></a>小游戏预览图</h2><p><img src="https://github.com/Delta1181485139/images/blob/master/algorithms/flybird1.png?raw=true"><br><img src="https://github.com/Delta1181485139/images/blob/master/algorithms/flybird2.png?raw=true"><br><img src="https://github.com/Delta1181485139/images/blob/master/algorithms/flybird3.png?raw=true"></p>
<h2 id="pygame的使用"><a href="#pygame的使用" class="headerlink" title="pygame的使用"></a>pygame的使用</h2><p>下载好pygame之后打开pycharm，导入pygame模块，sys中要用到游戏的退出函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame,sys</span><br></pre></td></tr></table></figure>
<p>初始化主窗口：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">size = width, height = <span class="number">600</span>,<span class="number">600</span>    <span class="comment">#窗口大小</span></span><br><span class="line">screen = pygame.display.set_mode(size)</span><br><span class="line">pygame.display.set_caption(<span class="string">"flybird"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="游戏机制"><a href="#游戏机制" class="headerlink" title="游戏机制"></a>游戏机制</h2><p>设计机制是游戏处于一个循环体内，不断刷新窗口内的像素位置，形成动画。以下循环展示了进入游戏的初始界面，首先是第一个<strong>for</strong>循环内的<strong>pygame.event.get()</strong>，所有的监听器处于这个消息队列中，每次循环都对其进行一次遍历。在我们的游戏中一个是要监听游戏关闭事件<strong>pygame.QUIT</strong>，另一个就是鼠标点击事件<strong>pygame.MOUSEBUTTONDOWN</strong>，通过返回鼠标的点击位置来判断是否开始游戏，或是对游戏内小鸟的控制。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">    <span class="keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">        exit()          <span class="comment">#游戏的退出</span></span><br><span class="line">    <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">        <span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:</span><br><span class="line">            loc = pygame.mouse.get_pos()</span><br><span class="line">            <span class="keyword">if</span> (loc[<span class="number">0</span>] &gt; width / <span class="number">2</span> <span class="number">-90</span>) <span class="keyword">and</span> (loc[<span class="number">0</span>] &lt; width / <span class="number">2</span> +<span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &gt; height / <span class="number">2</span> <span class="number">-80</span>) <span class="keyword">and</span> (loc [<span class="number">1</span>] &lt; height / <span class="number">2</span> +<span class="number">80</span>):</span><br><span class="line">                start_fly(screen <span class="comment">#进入start_fly表示进入开始游戏之后的循环体</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>这个项目没有使用任何的图片素材，因此游戏画面内所有的元素由<strong>pygame.draw</strong>模块绘制完成，并且为了达到这种像素风，仅仅使用了<strong>pygame.draw.rect</strong>来完成基本矩形的绘制。以下谈到的像素均为自己定义的像素，而非实际像素。</p>
<h2 id="需要用到的类"><a href="#需要用到的类" class="headerlink" title="需要用到的类"></a>需要用到的类</h2><p>游戏画面采取的是笛卡尔坐标系，以窗口左上角为坐标原点，x轴正方向往屏幕右侧，y轴正方向往屏幕下侧。</p>
<ul>
<li><strong>class Pixel:</strong><br> 像素类，用来对定义的像素点做基本的绘制，移动操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixel</span>:</span></span><br><span class="line">    <span class="string">"""游戏内容均为像素点,实质上为固定大小的矩形"""</span></span><br><span class="line">    scale = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    location = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    color = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment">#构造方法 需要的参数有像素的长宽，起始位置，颜色，均由元组表示。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, scale , location, color)</span>:</span></span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.location = location</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,target)</span>:</span></span><br><span class="line">        self.location = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ncolor</span><span class="params">(self,color)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self,screen)</span>:</span></span><br><span class="line">        pygame.draw.rect(screen,self.color,(self.location,self.scale))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>class element：</strong><br>这个类通过使用<strong>class Pixel:</strong>的实例化对象来绘制获得游戏内容。通过改变成员变量 <strong>shift[ x, y]</strong> 的值来控制图像外接矩形左上角的坐标，改变 <strong>speed[ x, y]</strong> 来控制图像在x轴及y轴上的平移速度。而该类提供了 <strong>move(location)</strong> 和 <strong>setSpeed(speed)</strong> 两个成员方法来改变上述两个量。图片的绘制信息位于 <strong>build_BIRD，build_CLOUD ，build_SWITCH ，build_OBSTACLE， LETTER</strong>几个变量中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pixel <span class="keyword">import</span> Pixel</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    pixelScale = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#此处的长宽代表像素点的个数</span></span><br><span class="line">    scale = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    mes = []</span><br><span class="line">    shifting = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    speed = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">#构造方法，传入欲绘制图像的像素点长宽（元组），整个图像外接矩形的长宽（元组），图片的绘制信息格式为((x,y),color)，以此类元组形成的列表传入构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,pixelScale,scale,mes)</span>:</span></span><br><span class="line">        self.pixelScale = pixelScale</span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.mes = mes</span><br><span class="line"><span class="comment">#将图像绘制到指定的surface对象上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self,screen)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(self.mes)):</span><br><span class="line">            location = [(self.mes[_][<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span>) * self.pixelScale[<span class="number">0</span>] + self.shifting[<span class="number">0</span>], (self.mes[_][<span class="number">0</span>][<span class="number">1</span>]) * self.pixelScale[<span class="number">1</span>] + self.shifting[<span class="number">1</span>]]</span><br><span class="line">            color = self.mes[_][<span class="number">1</span>]</span><br><span class="line">            pixel = Pixel(self.pixelScale,location,color)</span><br><span class="line">            pixel.draw(screen)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,location)</span>:</span></span><br><span class="line">        self.shifting = location</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setSpeed</span><span class="params">(self,speed)</span>:</span></span><br><span class="line">        self.speed = speed</span><br></pre></td></tr></table></figure>
<h2 id="对象的构造"><a href="#对象的构造" class="headerlink" title="对象的构造"></a>对象的构造</h2><ul>
<li><strong>开始按钮</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">switch = Element((<span class="number">10</span>, <span class="number">10</span>),(<span class="number">13</span>, <span class="number">18</span>), build_SWITCH)</span><br><span class="line">switch.move((width / <span class="number">2</span> - <span class="number">90</span>,height / <span class="number">2</span> - <span class="number">80</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>小鸟</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鸟</span></span><br><span class="line">bird = Element((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">11</span>, <span class="number">17</span>), build_BIRD)</span><br><span class="line">bird.move((size[<span class="number">0</span>] / <span class="number">2</span> - <span class="number">60</span>, size[<span class="number">1</span>] / <span class="number">4</span>))</span><br><span class="line">bird.draw(screen)</span><br><span class="line">bird.speed = [<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>云</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cloud_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_1.move((size[<span class="number">0</span>] / <span class="number">6</span>, size[<span class="number">1</span>] / <span class="number">5</span>))</span><br><span class="line">cloud_1.setSpeed((<span class="number">-0.7</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">cloud_2 = Element((<span class="number">7</span>, <span class="number">7</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_2.move((size[<span class="number">0</span>] / <span class="number">1.2</span>, size[<span class="number">1</span>] / <span class="number">3</span>))</span><br><span class="line">cloud_2.setSpeed((<span class="number">-1.5</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">cloud_3 = Element((<span class="number">10</span>, <span class="number">10</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_3.move((size[<span class="number">0</span>] / <span class="number">2</span>, size[<span class="number">1</span>] / <span class="number">1.5</span>))</span><br><span class="line">cloud_3.setSpeed((<span class="number">-2</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>障碍物</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obstacle_1_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_1_1.move((size[<span class="number">0</span>], -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_1_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_1_2.move((size[<span class="number">0</span>], <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_1_2.scale[<span class="number">0</span>]*obstacle_1_2.pixelScale[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">obstacle_2_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_2_1.move((size[<span class="number">0</span>] *<span class="number">1.4</span> , -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_2_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_2_2.move((size[<span class="number">0</span>] *<span class="number">1.4</span>, <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_2_2.scale[<span class="number">0</span>]*obstacle_2_2.pixelScale[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">obstacle_3_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_3_1.move((size[<span class="number">0</span>] *<span class="number">1.7</span> , -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_3_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_3_2.move((size[<span class="number">0</span>] *<span class="number">1.7</span>, <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_3_2.scale[<span class="number">0</span>]*obstacle_3_2.pixelScale[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>分数</strong><br><strong>score</strong> 用来存储当前分数，游戏结束的时候返回游戏分数这个参数至主界面并显示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每过一个障碍物加一分，显示分数</span></span><br><span class="line">        score_ten = Element( (<span class="number">10</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="number">5</span>), LETTER[ int (score / <span class="number">10</span>) ] )</span><br><span class="line">        score_one = Element( (<span class="number">10</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="number">5</span>), LETTER[ score % <span class="number">10</span>] )</span><br><span class="line">        score_ten.move((<span class="number">10</span>,<span class="number">0</span>))</span><br><span class="line">        score_one.move((<span class="number">60</span>,<span class="number">0</span>))</span><br><span class="line">        score_ten.draw(screen)</span><br><span class="line">        score_one.draw(screen)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="游戏元素的动画"><a href="#游戏元素的动画" class="headerlink" title="游戏元素的动画"></a>游戏元素的动画</h1><p>所有的游戏动画均为平移，因此使用 <strong>class Element:</strong> 里的 <strong>move(location)</strong> 和 <strong>setSpeed(speed)</strong> 足以完成所有的动画效果。小鸟处于确定x坐标的竖直区域运动，云和障碍物不断的左移即可。</p>
<h2 id="开始游戏"><a href="#开始游戏" class="headerlink" title="开始游戏"></a>开始游戏</h2><p>在遍历消息队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:</span><br><span class="line">	loc = pygame.mouse.get_pos()</span><br><span class="line">                 <span class="comment">#开始新游戏</span></span><br><span class="line">       <span class="keyword">if</span> (loc[<span class="number">0</span>] &gt; width / <span class="number">2</span> - <span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">0</span>] &lt; width / <span class="number">2</span> + <span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &gt; height / <span class="number">2</span> - <span class="number">80</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &lt; height / <span class="number">2</span> + <span class="number">80</span>):</span><br><span class="line">       	score = start_fly(screen)</span><br></pre></td></tr></table></figure>
<h2 id="云的左移"><a href="#云的左移" class="headerlink" title="云的左移"></a>云的左移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_animation</span><span class="params">(cloud)</span>:</span></span><br><span class="line"><span class="comment">#若云的整体位置已越过窗口左侧，设置云的外接矩形左上角位于窗口最右侧。</span></span><br><span class="line">    <span class="keyword">if</span> cloud.shifting[<span class="number">0</span>] &lt; - (cloud.scale[<span class="number">1</span>] * cloud.pixelScale[<span class="number">1</span>]):</span><br><span class="line">        cloud.move((size[<span class="number">0</span>], cloud.shifting[<span class="number">1</span>]))</span><br><span class="line">    cloud.move(( cloud.shifting[<span class="number">0</span>] + cloud.speed[<span class="number">0</span>], cloud.shifting[<span class="number">1</span>] ))</span><br><span class="line">    cloud.draw(screen)</span><br></pre></td></tr></table></figure>
<h2 id="小鸟的向下匀加速直线运动"><a href="#小鸟的向下匀加速直线运动" class="headerlink" title="小鸟的向下匀加速直线运动"></a>小鸟的向下匀加速直线运动</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bird.move((bird.shifting[<span class="number">0</span>], bird.shifting[<span class="number">1</span>] + bird.speed[<span class="number">1</span>]))</span><br><span class="line">bird.speed[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">bird.draw(screen)</span><br></pre></td></tr></table></figure>
<h2 id="监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果"><a href="#监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果" class="headerlink" title="监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果"></a>监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果</h2><p>在遍历消息队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">        mouse = pygame.mouse.get_pressed()</span><br><span class="line">        <span class="keyword">if</span> mouse[<span class="number">2</span>]:</span><br><span class="line">bird.speed[<span class="number">1</span>] -= <span class="number">25</span></span><br></pre></td></tr></table></figure>
<h2 id="障碍物的移动以及判断小鸟是否与障碍物相撞"><a href="#障碍物的移动以及判断小鸟是否与障碍物相撞" class="headerlink" title="障碍物的移动以及判断小鸟是否与障碍物相撞"></a>障碍物的移动以及判断小鸟是否与障碍物相撞</h2><p>（由于一开始游戏难度过大， 我将障碍物设置为空心，即小鸟不会和障碍物的正下方或正上方相撞，但会和障碍物的侧边相撞）<br>通过传入一定范围内的随机参数ran控制障碍物从最右端开始向左平移的初始位置。在每个障碍物对象经过小鸟的位置令分数+1，便可完成分数的记录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obstacle_animation</span><span class="params">(obstacle,ran,bird_height)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; - (obstacle.scale[<span class="number">1</span>] * obstacle.pixelScale[<span class="number">1</span>]):</span><br><span class="line">        obstacle.move((size[<span class="number">0</span>], obstacle.shifting[<span class="number">1</span>] + ran * (obstacle.scale[<span class="number">1</span>] * obstacle.pixelScale[<span class="number">1</span>]) ))</span><br><span class="line">    obstacle.move(( obstacle.shifting[<span class="number">0</span>] - <span class="number">1</span>, obstacle.shifting[<span class="number">1</span>] ))</span><br><span class="line">    obstacle.draw(screen)</span><br><span class="line">    <span class="keyword">if</span> (obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>) <span class="keyword">and</span> (obstacle.shifting[<span class="number">0</span>] &gt; size[<span class="number">0</span>] / <span class="number">2</span> - <span class="number">60</span>):   <span class="comment">#可能发生碰撞的矩形区域</span></span><br><span class="line">        <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] &lt; <span class="number">0</span>:  <span class="comment">#和上管道相撞的区域</span></span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] + <span class="number">375</span> &gt;= bird_height: <span class="comment">#和上管道右侧相撞的区域</span></span><br><span class="line">                <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] + <span class="number">375</span> &gt;=bird_height:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> obstacle.shifting[<span class="number">1</span>] &lt; bird_height:</span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] &lt; bird_height:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="小游戏的打包"><a href="#小游戏的打包" class="headerlink" title="小游戏的打包"></a>小游戏的打包</h1><p>(已安装<strong>pyinstaller</strong>)<br>在命令行窗口，进入到游戏入口文件的路径下输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyinstaller -w -F 文件名.py 文件名.py...</span><br></pre></td></tr></table></figure>
<p>打包完成之后可执行文件处于<strong>dist</strong>目录下。</p>
<hr>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>pygame确实十分的方便，功能其实远不止这个小游戏所用到的这些，而我的这种自己建类绘制图形其实没有什么必要，直接导入图片资源，pygame就能够构造以这个图片资源为基础的surface对象，并提供了许多方法来操作，远比上述自己创造的类方法要灵活，最主要的是，在设计2D游戏的过程中，完全不需要花大量时间在游戏框架的构造上，一个小游戏一天便可开发完成。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-1-两数之和</title>
    <url>/2020/02/16/leetcode/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</p>
</blockquote>
<a id="more"></a>
<hr>
<p>我本来想通过暴力解法来解这种题，因为逻辑并不复杂。但是后面又想到了一种通过使用HashMap的方法，能够将时间复杂度降为$O(n)$。</p>
<p>我们要想知道数组中和等于target的两个下标，也就是想要知道对于一个数组中的数，如果target减这个数也存在数组中，那么这两个数的下标就是我们要的答案。在对数组的一次遍历中，将遍历到的数的值作为键，下标作为值，以这样一个二元组加入到一个HashMap集合中。因为通过键访问值只需要常数级的时间复杂度。所以在每一次对数组元素的访问中，查看HashMap集合中是否存在一个以target-nums[i]为键的元组，若存在，则返回它的值，它的值就是我们在此前一起传入的下标。我们要的答案就是现在的i,和通过HashMap集合找到对应的值，即原本的下标。</p>
<p>这道题表明使用哈希表来存储需要通过值来访问得到序号的二元组是十分有效的，因为哈希表的键可以存储任意类型的元素，用值来存储整型的下标。需要注意的是，哈希表中一个键只能对应一个值，一个值却可以对应多个键，类似于函数中的单射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数关系</title>
    <url>/2019/12/19/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>要考研了，复习高数不定积分那一块的时候竟然发现有一些三角函数居然都没见过，特此记录一下他们与sin，cos，tan之间的关系，主要是正割余割。至于和差化积那些转换关系，既然考研不要求就不记了。<br><a id="more"></a></p>
<h2 id="倒数关系"><a href="#倒数关系" class="headerlink" title="倒数关系"></a>倒数关系</h2><blockquote>
<p>sin a <em> csc a=1<br>cos a </em> sec a=1<br>tana * cota=1</p>
</blockquote>
<h2 id="商数关系"><a href="#商数关系" class="headerlink" title="商数关系"></a>商数关系</h2><blockquote>
<p>tana=sin a / cos a<br>cota=cos a / sin a</p>
</blockquote>
<h2 id="平方关系"><a href="#平方关系" class="headerlink" title="平方关系"></a>平方关系</h2><blockquote>
<p>(sin a)^2 + (cos a)^2=1<br>1+(tan a)^2 = (sec a)^2<br>1+(cot a)^2 = (csc a)^2</p>
</blockquote>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
</search>
