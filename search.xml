<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode刷题笔记-33-搜索旋转排序数组</title>
    <url>/2020/02/27/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例：</p>
<blockquote>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p>
</blockquote>
<a id="more"></a>

<p>看到这个时间复杂度必须是o(logn)级别，那么很自然的就想要要用二分法。二分法的精髓在于对一个有序数组，可以通过逐步缩小首位指针的范围，直到范围无法再缩，就能够锁定需要查找的数的位置了。</p>
<p>但这题特殊在，它不是严格的有序数组，而如果对它进行排序，则会打乱我们要找的数的索引，所以不能排序。但即使这样，这个数组也是部分有序的，在二分查找中，只要合理的条件判断，也能够顺利进行下去。</p>
<p>由于我设置了两个指针，所以代码可能有点冗杂，但我做这题的时候也为了追求效率，放弃了优雅，也就选了个条理更清晰的方式。</p>
<p>主要说一下如何进行二分：首先首尾放置指针，仍然以最中间的那个数为基准来比较。根据旋转数组的特征，将中间数与目标数以及数组首位元素比较大小，将会得出目标数到底在中间数的左边还是右边，这时候就可以移动左右指针之一来缩小查找范围了。将中间数与目标数比较好理解，那么为什么还要与数组首位元素比较呢，作为旋转数组，可以知道的是首位元素一定比尾部元素大，同时也可以认为大小介于旋转点与后面那一点之间，这将是确定目标数位置的一个重要的参考，然后以旋转点为界，两侧的子数组是有序的。</p>
<p>当然，如果想追求代码简洁，可以适当用异或来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>)<span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:(nums[<span class="number">1</span>]==target?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>, k = nums.length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;i&amp;&amp;j&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]==target)<span class="keyword">return</span> k;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)<span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==target)<span class="keyword">return</span> j;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                        j = k;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i = k; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    i = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&gt;target)&#123;</span><br><span class="line">                    j = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                        j = k;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k = (i + j) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP模式匹配算法</title>
    <url>/2020/02/26/KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>这几天复习到数据结构的串的模式匹配，看到KMP算法那么寥寥几行的代码，原本觉得这部分内容很简单，直到我开始尝试去理解它，我才发现我跟大佬的差别。</p>
<a id="more"></a>
<p>之后我花了整整一天半的时间研究这个算法，期间除了吃饭睡觉拉屎，去楼下药店帮拿了一点口罩之外，没有干其他任何事，总算是理解的差不多了。总结一下这个算法，对于模式串本身，如果经常出现重复的子串，用KMP算法确实可以比朴素模式匹配算法快上不少，但要是模式串前后几乎没几个一样的字符时，KMP算法就是用来秀操作的，因为我相信绝大多数的模式串都是短小精悍的，关键词什么的。要是自己写的话还容易纠结于下标的控制。虽然好像听说考研只会在选择题里考手工算next数组，但我还是想把这个无聊的算法彻底弄明白，里面的求next数组算法的原理，可能会对研究编译原理构造词法分析器的有穷自动机有启发。下面谈谈我目前为止对这个算法的思考。</p>
<h1 id="KMP算法的基本思路"><a href="#KMP算法的基本思路" class="headerlink" title="KMP算法的基本思路"></a>KMP算法的基本思路</h1><p>KMP算法，是名分别为K、M、P的三个美国大佬发明的，算是对传统的朴素模式匹配算法的改进。我们先规定，讨论模式串下标均从1开始。朴素模式匹配算法就不谈了，这个有脑子就能想出来，但朴素模式匹配算法存在一个弊端——当模式串有较多重复元素存在时，主串指针i其实做了很多没有必要的回溯。</p>
<p>而如果想跳过这些没有必要比较的情况，那么就可以想到，主串指针是没有必要回退的，因为当发生与模式串失配的情况时，可以确定的是，此前成功匹配的若干元素形成的字串，其实就是模式串的一个真字串，那么对于这样的一个字串，它的头部和尾部如果发生了重复，就只需要往回移动模式串指针就好了，但是又不需要往回移到初始位置，因为我们看到他的头部和尾部发生了重复，又由于这个头部重复的部分与现在主串指针前的那个模式串真字串重复，而这部分就是真字串的尾部，所以最有利的做法应该是将模式串指针移动至头部重复字串的后一位，再来与当前的主串指针比较。这样，就避免了主串的回溯，单就这个算法本身，简单来看时间复杂度应该是o(n)。</p>
<p>以下是KMP主代码，对于模式串每一个位置发生失配模式串指针所应该回溯的位置，用一个叫next的整型数组来存储，发生失配时直接用里面的数据来对模式串指针进行回溯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPpatternmatch</span><span class="params">(<span class="built_in">string</span> s1,<span class="built_in">string</span> s2,<span class="keyword">int</span>* next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; s1.size())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s1[i] == s2[j]) &#123;i++;j++;&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) i++;</span><br><span class="line">		<span class="keyword">else</span> j = next[j]<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (j == s2.size())<span class="keyword">return</span> (i - s2.size());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="确定模式串指针的回溯位置"><a href="#确定模式串指针的回溯位置" class="headerlink" title="确定模式串指针的回溯位置"></a>确定模式串指针的回溯位置</h1><p>但问题来了，如何确定在模式串的不同位置发生失配时模式串指针需要回溯的位置呢？我们可以发现，这些位置的确定，只跟模式串有关，并且对于每一个需要求的位置，只跟从模式串当前位置截断，取前者的这个字串有关。我们如果要来求这个神秘的next数组，就只需要看包含模式串第一位的模式串的各个字串就好。根据上述的推理，这个位置应该是这个字串前后重复的部分+1。到这里，我们可能自以为问题就解决了，以后我们遇到每一个模式串，手动去算一下它的next数组就好了。</p>
<p>可是呢，懒人总是有的，他就是不想去算这个next数组，觉得太麻烦了，怎么办呢，交给计算机算吧，所以又展开了一系列头脑风暴，被认为是KMP算法的核心，next数组的求解以及其原理。前方高能。</p>
<h1 id="next数组代码实现原理"><a href="#next数组代码实现原理" class="headerlink" title="next数组代码实现原理"></a>next数组代码实现原理</h1><p>为了放松一下，先来看下代码吧：<br>我之所以在那个字符串前随便填充一个元素，是因为规定了模式串的下标由1开始算（被数据结构书束缚了头脑）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	s = <span class="string">"0"</span> + s;</span><br><span class="line">	next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; s.size()+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == s[j])next[++i] = ++j;</span><br><span class="line">		<span class="keyword">else</span> j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是觉得很简单，就是这么简单的代码我研究了一天半。来讲解一下。</p>
<h2 id="传统思维"><a href="#传统思维" class="headerlink" title="传统思维"></a>传统思维</h2><p>在明白了next数组各个元素应该怎么填之后，我们的惯性思维就是将问题转化为，对于一个字符串，求其包含头部元素的每一个真字串的头部和尾部重复的最大部分。对了，为什么要的是最大重复个数，我的理解是，为了跳步骤，有辣么多重复的不跳，干嘛去挑一个短的来跳，对于这一点网上很多博客的说法有点复杂，我这个还挺好理解的。好，话说回来，为了解决这个问题，让我们先往暴力法方向想下，好不好将其代码化。我们人脑的思维是，看着这个串，看开头，看结尾，不重复，这次看长一点，看开头，看结尾，还是不重复，如此下去，直到找到重复的，但还要最长的重复串啊，好吧，那就继续…这个思路要翻译成代码，那就是要定义两个指针，一个用来指向头部，一个用来指向尾部，再定义一个变量，在循环中以这个变量的值不大于原串的长度为基准来循环，再再定义一个变量，用来记录最大重复串长度，每次比较之后选择性更新。这跟刚刚贴出来的代码相比，那真是又臭又长，主要是不怎么优雅。我们虽是懒人，代码的优雅性还是得考虑的，就这么简单的事情要搞两层循环？？我们KMP主函数的复杂度才o(n)呢，好吧，要说优化的方法，那肯定是有的。</p>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>有时候觉得学计算机，数学的用处不大，但有时候，数学学的好确实能让你这个麻木的码农变得更加优雅。我的理解是，考虑数学归纳法，用递推关系来求next数组的元素。我们要找的是某个子串的头部与尾部重复的最大长度，那么直接用头部来匹配尾部不就好了，那我们就用尾部作为模式串来匹配头部。既然是归纳法，那就先考虑一般情况，先看中间。假设尾部指针指到了i这个位置，尾部指针指到了j这个位置，而且现在已经知道前面的结果，那么就只剩下两种情况，如果next[i]等于next[j]，考虑到一般情况下（如果指针不越界）next[i-1]=next[j-1]，那么重复的最大子串长度只要在原来的基础上加一，所以next[i]的值应该是数组起始位置到j目前位置的长度，那么就是j-0=j，那么直接将j的值给next[i]好了；另外一种情况，next[i]不等于next[j]，根据KMP算法的规则，不就是找包含模式串第一位一直到i-1位的这个子串的头部与尾部的最大重复长度吗，而且正好，这个值就在next[j]里面，因为next[j]的意思就是如果匹配到i位发生失配，模式串指针应该跳到next[j]这个位置，所以就直接将next[j]赋值给j，让j跳回去重新跟i比较。这样就形成一个循环体，还有一个问题，如果跳回去的过程中一直失配，那不就回不来了，那怎么行，模式串指针可是有一个下限的，那就是1，情况坏也得从1开始比较吧。如果j=0的时候也需要让i和j都移动一位，那就可以让匹配一直进行下去了。</p>
<p>既然是数学归纳法，考虑完一般情况，还得考虑初值情况。我们说j是子串头部指针，i是子串尾部指针，开始的时候长度起码是2吧，不然的话就不用匹配了，这样的话就令j为0，i为1，next[1]为0，也就是说如果第一个位置就失配的话，那就让i无脑后移，然后j也可以到模式串的第一个位置。这样的好处是，由于j为0，进入循环体之后i就能开始后移，j就算回跳到next[1]，也能够顺利进入让i进入到后移比较的阶段。也可以看出，在next数组里，除了next[1]为0，后面的元素就都不可能是0了。还能发现，next[2]肯定是1。整个算法过程如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS92Mi00N2IyNmRiNjY1OTM3NzQyMGY0MzI2YzMyOTZiYWE5OV9iLndlYnA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>这个算法巧妙的利用已知条件递推下一个答案，直到得到所有的答案。可是到了这里，大多数人觉得KMP算法告一段落了，但，还没完。</p>
<h1 id="KMP算法的优化"><a href="#KMP算法的优化" class="headerlink" title="KMP算法的优化"></a>KMP算法的优化</h1><p>目前的next数组令模式串的j指针在失配的回跳，但有的时候会连续回跳，而每一次的回跳都伴随着与主串的比较，如果每次回跳到的那个模式串的值等于目前失配的值的话，那还不如让模式串指针一次性跳到后面目标位置，一样的值就没有必要再次比较了。所以就引出了KMP算法的优化措施，将next数组转化为nextval数组，用来避免模式串j指针回跳之后的值等于目前的值而做的重复的比较。那么将next数组转化为nextval数组的方法也很简单，下标的定义仍然值得注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span>* next)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* nextval = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.size()+<span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[next[i]] == s[i]) &#123;</span><br><span class="line">			nextval[i] = nextval[next[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			nextval[i] = next[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nextval+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>算上求next数组这一部分，整个KMP模式匹配算法的时间复杂度就大致是o(m+n)了，m是模式串的长度，n是主串的长度。网上其他的讲解基本会用到前缀后缀的概念，那样可能讲述起来会更严谨，但也不易懂。但总的来说，困扰大部分人的是难以理解如何让自己来匹配自己，但准确来讲，是用自己的尾部去匹配自己的头部，然后就是头部尾部指针的初值设定，搞清楚这两点，那就成功十之八九了。</p>
<p>不过我感觉我上述抽象的地方描述的也不算好，但算法这种东西，就是得花时间去磨，有些部分确实是难以言传的。总之，懂的人自然懂，不懂的人花时间磨，总能磨出来的。最后，向那些脑洞大开想出这种奇葩算法的三人组致敬。</p>
]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-6-Z字形变换</title>
    <url>/2020/02/24/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<blockquote>
<p>L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R<br>   E&nbsp;&nbsp;T&nbsp;&nbsp;O&nbsp;&nbsp;E&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;G<br>   E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N</p>
</blockquote>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：</p>
<blockquote>
<p>“LCIRETOESIIGEDHN”。</p>
</blockquote>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<a id="more"></a>
<p>第一眼看到这道题的时候，愣是没弄懂这题在讲什么，看了半天才知道是到数学题，就是找规律。那就很简单了，直接把字符串中对应每一个字符的位置与新的位置形成映射，遍历一遍，就出来了。</p>
<p>然而显示很残酷，在计算公式的时候，我抱怨过无数次我的脑子寄存器不够用，根本难以理清关系。后来想到新建一个二维数组，真的以Z字形将字符串存入，再按行遍历，但这方法似乎太笨了些，知道后来看到了一个大佬的想法，才一语惊醒梦中人。</p>
<p>先将图画出来，可以直观的看出各元素的位置结构。先初始化numRows个容器来存储每一行的元素。总体上可以以numRows-1个元素作为一个周期，为什么是numRows-1个，看图看出来的。排除完特殊情况之后，遍历原字符串，计算可得出每一个元素所在的周期数和位序，但是其实周期也分两类，偶数和奇数，可以看出这两类周期的元素对于Z字形的行号的递增方向是不同的，所以用当前周期对二取模可辩别这是奇数还是偶数周期，再分别将字符压入相应的行中。遍历完成之后，将这numRows个容器拼接，就是所求字符串。</p>
<p>了解完这种解法，我只能发出由衷的感叹：妙啊！这就是所谓的数学直觉吗。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">t</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">1</span>||numRows&lt;<span class="number">1</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cycle = i/(numRows<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> order = i%(numRows<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cycle%<span class="number">2</span>==<span class="number">0</span>)t[order].push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> t[numRows-order<span class="number">-1</span>].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)ans+=t[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-3-无重复字符的最长子串</title>
    <url>/2020/02/23/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例：</p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<a id="more"></a>
<p>实质上是以每个字符开始为基准，看它们接下来最长的无重复字符串有多长。</p>
<p>窗口初始指针i=j=0，使用 HashSet 将字符存储在当前窗口 [i, j)中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p>
<p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，通常这种类似于字符串的模式匹配都可以用窗口法来分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;<span class="keyword">else</span> set.remove(s.charAt(i++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-31-下一个排列</title>
    <url>/2020/02/22/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<blockquote>
<p><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
</blockquote>
<a id="more"></a>

<p>根据题意，要将一个数组表达的数字重排列成一个比原来大，但要尽量小的一个数，如果这样的数不存在则返回重排列成表达最小的数。因此显然要从低位开始比较，也就是从数组的尾部沿着一个升序往回找，直到寻找路径不升反降为止。再考虑替换升序数组的后一位，最后将原来所谓的升序数组反转即可。</p>
<p>具体操作是：令遍历升序数组的指针i位于数组尾部，往回寻找升序数组结束的位置，比如遍历到某一位，发现遍历的上一位的值比目前这一位要大，这时候用指针j记录下这一位的位置，再让指针i往原数组的尾部遍历，找到一位刚好比指针j对应元素大的元素，将这两个元素的位置互换，此时指针j后面部分的元素必然是降序的，因此将它们反转就能得到答案。</p>
<p>这题表明，遍历数组之前要充分搞透原数组向目标数组的变化规律（可以用画图的方法），再用代码实现就显得游刃有余了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = nums.length - <span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                j = i++;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;nums.length&amp;&amp;nums[i]&gt;nums[j])i++;</span><br><span class="line">                swap(nums,j++,i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(i = nums.length - <span class="number">1</span>;j&lt;i;i--,j++)swap(nums,i,j);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>,i = nums.length - <span class="number">1</span>;j&lt;i;i--,j++)swap(nums,i,j);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">        nums[j] ^= nums[i];</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-27-移除元素</title>
    <url>/2020/02/21/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<a id="more"></a>
<p>此题显然应当用双指针，但与删除重复元素那道题不同的是，此题需要删除指定元素，也就是说如果两个指针如果像之前那样，从同一侧出发，快指针赋值给慢指针的方式，势必会出现很多虽然合法，但是冗余的元素。这时候应当要换一种思维方式，让一个指针访问过的元素避免被另一个指针再次访问，但依然是一个指针主要负责检查，另一个指针负责遍历。</p>
<p>排除完特殊情况之后，首先令检查指针位于0处，遍历指针位于nums.length-1处，比较检查指针所对应的元素是否是target, 如果是的话就把遍历指针对应元素的值传入，遍历指针便可以往低位移动一次，否则就直接将检查指针向高位移动一次，继续检查，由于循环体每次要么移动检查指针，要么检查遍历指针，而无论是检查指针自身移动到的等于target的元素，还是遍历指针传入的等于target的元素，都会因为这个等于target的条件，继续被遍历指针的新元素所覆盖。所以到最后检查指针所经过的区域就是去除完所有target的数组，还保证了其他元素的完整性。</p>
<p>双指针的应用一定要根据具体题目快速判断，灵活运用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                nums[i] = nums[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-26-删除排序数组中的重复项</title>
    <url>/2020/02/21/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<a id="more"></a>

<p>这题当初想了很久，但最后没想到思路这么简单。原地修改数组，要么比较之后赋值，要么比较之后交换，而这里显然赋值就好，因为后面不需要的部分可以不用管。总体的趋势就是令数组前面的重复元素逐渐被后面不重复的元素取代，到最后如果不存在新的元素，那么就返回前面算得的那一段数组的长度。</p>
<p>首先是去重，当数组长度小于二时，就不存在元素什么重不重复了，直接返回数组长度。</p>
<p>如果长度大于二，就依然是双指针的做法，因为已经排好序了，所以重复的同一个元素一定是紧挨着的。将快指针与慢指针比较，如果发现两者相同，那么就慢指针不动，快指针后移一位，继续发现下一个不同的元素，如果不同，将慢指针后移一位，将快指针的值赋给慢指针。这样即可保证慢指针及其之前的元素都不重复，直到快指针遍历完数组所有的元素，慢指针作为结果数组的最后一位，需要返回的值即是慢指针后面那一位的下标，这才是不重复数组的数组长度。</p>
<p>快慢指针大概也算一个很典型的双指针思想，慢指针用来保存记录已经得到的东西，而用快指针在前面搜寻，与前面比较，时间复杂度o(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=nums[j])nums[++i] = nums[j];</span><br><span class="line">				<span class="keyword">else</span> j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-18-四数之和</title>
    <url>/2020/02/20/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<blockquote>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  &nbsp;&nbsp;[-1,  0, 0, 1],<br>  &nbsp;&nbsp;[-2, -1, 1, 2],<br>  &nbsp;&nbsp;[-2,  0, 0, 2]<br>]</p>
</blockquote>
<a id="more"></a>

<p>我快吐了，两数和，三数和，又来个四数和，难道真的没题出了吗，不如出个n数和好了。四数和的做法我想应该可能会有低于o(n^3)时间复杂度的算法，但我是想不出来了（下次一定想）。</p>
<p>还是参考三数和的做法，也就是比三数和多了一个遍历指针，中间多了一层循环，在细节处理上稍复杂一些，还是很考验debug能力的。</p>
<p>废话不多说，上代码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">4</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">            <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; nums.length;)&#123;</span><br><span class="line">                b = a+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(b&lt;nums.length - <span class="number">2</span>)&#123;</span><br><span class="line">                    c = b + <span class="number">1</span>; d = nums.length - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(c&lt;d)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[b] +nums[c] + nums[d]==target - nums[a])&#123;</span><br><span class="line">                            ans.add(Arrays.asList(nums[a],nums[b],nums[c],nums[d]));</span><br><span class="line">                            c++;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c-<span class="number">1</span>])c++;</span><br><span class="line">                            d--; <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d+<span class="number">1</span>])d--;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] &lt;target - nums[a])&#123;</span><br><span class="line">                            c++;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c-<span class="number">1</span>])c++;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            d--;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d+<span class="number">1</span>])d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    b++;<span class="keyword">while</span>(b&lt;nums.length - <span class="number">2</span>&amp;&amp;nums[b]==nums[b-<span class="number">1</span>])b++;</span><br><span class="line">                &#125;</span><br><span class="line">                a++;<span class="keyword">while</span>((a &lt; nums.length)&amp;&amp;(nums[a]==nums[a-<span class="number">1</span>]))a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-16-最接近的三数之和</title>
    <url>/2020/02/19/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：</p>
<blockquote>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<a id="more"></a>

<p>此题的遍历方式与之前的<a href="/2020/02/18/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" title="寻找三数之和等于0">寻找三数之和等于0</a>类似，这题简单在只需要返回那个最接近目标数的三数和因此不需要去重，稍微复杂在这个最接近。</p>
<p>首先还是先对数组进行一次排序，以便指针的全面查找。用一个变量ans来存储目前最接近目标数的结果，初值可随意赋三个确定数组元素的和，比如初始ans = nums[0] + nums[1] + nums[2]。</p>
<p>令指针i做最外层循环，j，k做内层循环，始终保持i &lt; j &lt; k。因此对于每一个i，j的初值为i + 1，k的初值均为nums.length - 1, 比较此时算出的和与此前算得的ans，若更接近目标数则替换，k与j同时移动，若算出的和比target小，则移动指针j，若大，则移动k，否则便是相等，可直接返回，因为此时与目标数是最接近为0，且不可能存在更接近的数了。搜寻直到j &gt;= k，再看下一个的i，对应的j，k。</p>
<p>总之，在数组里要同时访问一定数目的元素的指针设定和移动是大同小异的，应当要会融会贯通。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>, k = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[j] + nums[k] + nums[i];</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(target - sum) &lt; Math.abs(target - ans))</span><br><span class="line">                    ans = sum;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-15-三数之和</title>
    <url>/2020/02/18/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br> [<br> &nbsp; &nbsp;[-1, 0, 1],<br> &nbsp; &nbsp;[-1, -1, 2]<br>]</p>
</blockquote>
<a id="more"></a>

<p>这道题用暴力法搜寻需要 o(n^3) 的时间复杂度，这里我依然用的是增加搜寻指针的方法，需要两次遍历，将时间复杂度降为o(n^2)。</p>
<p>首先是排除特殊情况。</p>
<p>先将数组从小到大排序。定义三个指针i，j，k，开始时i为指向数组第一个位置，j指向数组第二个位置，k指向数组最后一个位置。i的值在最外层增加，j，k，用于对于每一个nums[i]，寻找另外两个符合条件的值。为了保证遍历的有序，必须遵循i&lt;j&lt;k这个基本条件。</p>
<p>先看此时nums[i] + nums[j] +nums[k] 是否为0，如果是，那么就找到了一个符合条件的值，将此三元组放入答案集合中，同时将j和k左移或右移，为什么要同时移动？因为如果只移动其中一个，我们将来要找的对应的剩下那个值其实已经找到了，而数组是已经排好序的，所以搜寻的值只会越来越大或越来越小，现在情况就是nums[i] + nums[j] +nums[k]， 在nums[i]固定的情况下，num[j]如果增大了，nums[k]就必须减小才有可能找到新的三元组。</p>
<p>再看，如果nums[i] + nums[j] +nums[k] 不为0，那么我们就要想办法让指针往有利于让其等于0的方向移动，这里就可以分两种情况，一种是得到的值比0大，我们希望这个减小，按照数组的有序性，必须让k指针左移才能让值减小，之后再作判断，此时如果同时移动两个指针，将可能会少遍历到一些组合。另外一种情况也是以此类推，直到j&gt;=k的时候可以将i指针右移，然后j的初值再赋为i+1，k的初值为数组长度-1，开始寻找对于一个新的nums[i]，符合条件的nums[j]，nums[k]，直到i的位置到了整个数组的倒数第三个。</p>
<p>在每次移动指针的时候要按照题目进行去重处理，方法就是用一个while循环，因为有序数组的话相同的值一定是相邻的，在指针需要移动的时候比较移动前后的值，若相等则继续移动一个单位，注意的是循环条件还需要满足外层循环的条件，否则可能会数组下标越界。i的去重也同理。</p>
<p>这道题同时用到了有序数组的特性和多指针比较法来减少循环次数，不过其实想到一个办法之后能够快速的用代码实现才是更重要的，要是花大量的时间来debug就有点亏了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j, k;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&lt;=<span class="number">0</span>&amp;&amp;i&lt;nums.length -<span class="number">1</span>)&#123;</span><br><span class="line">                j = i+<span class="number">1</span>; k = nums.length -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]==-nums[k])&#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i],nums[j],nums[k]));</span><br><span class="line">                        j++;k--;</span><br><span class="line">                        <span class="keyword">while</span>(nums[j]==nums[j-<span class="number">1</span>]&amp;&amp;j&lt;k)j++;</span><br><span class="line">                        <span class="keyword">while</span>(nums[k]==nums[k+<span class="number">1</span>]&amp;&amp;j&lt;k)k--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span>(nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;i&lt;nums.length-<span class="number">1</span>)i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-11-盛最多水的容器</title>
    <url>/2020/02/17/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"  height="200" width="500">

<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例：</p>
<blockquote>
<p>输入: [1,8,6,2,5,4,8,3,7]</p>
<p>输出: 49</p>
</blockquote>
<a id="more"></a>
<p>除了o(n^2)的暴力法之外，可以用双指针来完成一次遍历，近用o(n)找到这个最大的容积。</p>
<p>一开始，指针i位于数组最左侧，指针j位于数组最右侧，用一个变量maxvolume来存储迄今为止得到的最大容积，每次的移动指针都需要将此时算得的容积与旧值比较，若大则更新，否则继续移动指针。由题意可以得知，我们要求的这个容积的值取决于短的那根垂线，对于两根垂线中短的那一根，如果定住指针不动，移动另一指针，无论以后这一边的高是多少，也不可能再找到一个可以比现在更大的容积了。所以指针移动的策略是，比较height[i]与height[j]的大小，谁小就移动谁，直到i&gt;=j,遍历停止，这样的话，maxvolume的值会按正确方向向答案靠拢。</p>
<p>通过使用双指针的方法，通常可以减少一个数量级的时间复杂度，但是需要着重考虑指针移动的策略，以避开不需要的比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxvolume = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            maxvolume = Math.max(maxvolume, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxvolume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现flybird小游戏</title>
    <url>/2020/02/16/python%E5%AE%9E%E7%8E%B0flybird%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>前段时间了解到python里pygame这个库，突发奇想用python来做一些有趣的小东西，随即就想到了读初中时候那个火了好一阵子失传已久的小游戏–flybird。 游戏逻辑很简单，可以用来体验一下pygame这个强大的将游戏开发专注于游戏逻辑本身的模块。</p>
<a id="more"></a>

<h1 id="整个小游戏的生命周期"><a href="#整个小游戏的生命周期" class="headerlink" title="整个小游戏的生命周期"></a>整个小游戏的生命周期</h1><h2 id="小游戏预览图"><a href="#小游戏预览图" class="headerlink" title="小游戏预览图"></a>小游戏预览图</h2><img src="http://r.photo.store.qq.com/psc?/V13qphfI0VLybb/Tiy10*PRF5enyWrLfdcKz7zngK3mwAwC0QJKJWEivDFeWFiyJEKTR.lJTyxSCor3aTZXVkTHaGQXTCxmtG378yt7VyhAP7JxXu7GJWpHyNA!/r"  height="600" width="600">
<img src="http://r.photo.store.qq.com/psc?/V13qphfI0VLybb/Tiy10*PRF5enyWrLfdcKz4cMaHyup.PIxibBAJ7Xl4hZ5tCM9wvt6DyDpoGshGzYTOVgbhon6y5N2dvuum*iZGjsy8ejkuzRBqdsQEODwBI!/r"  height="600" width="600">
<img src="http://m.qpic.cn/psc?/V13qphfI0VLybb/Tiy10*PRF5enyWrLfdcKz0pOcEt8Ong5.lBrWW9v682G.zVkN1hRzgCKDHpi2GrppO4XDJ4hqF31KJ4xBDimLArgZ37A5F.Nuhv4iaZZuc4!/b&bo=8AIPA*ACDwMDCSw!&rf=viewer_4"  height="600" width="600">

<h2 id="pygame的使用"><a href="#pygame的使用" class="headerlink" title="pygame的使用"></a>pygame的使用</h2><p>下载好pygame之后打开pycharm，导入pygame模块，sys中要用到游戏的退出函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame,sys</span><br></pre></td></tr></table></figure>
<p>初始化主窗口：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">size = width, height = <span class="number">600</span>,<span class="number">600</span>    <span class="comment">#窗口大小</span></span><br><span class="line">screen = pygame.display.set_mode(size)</span><br><span class="line">pygame.display.set_caption(<span class="string">"flybird"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="游戏机制"><a href="#游戏机制" class="headerlink" title="游戏机制"></a>游戏机制</h2><p>设计机制是游戏处于一个循环体内，不断刷新窗口内的像素位置，形成动画。以下循环展示了进入游戏的初始界面，首先是第一个<strong>for</strong>循环内的<strong>pygame.event.get()</strong>，所有的监听器处于这个消息队列中，每次循环都对其进行一次遍历。在我们的游戏中一个是要监听游戏关闭事件<strong>pygame.QUIT</strong>，另一个就是鼠标点击事件<strong>pygame.MOUSEBUTTONDOWN</strong>，通过返回鼠标的点击位置来判断是否开始游戏，或是对游戏内小鸟的控制。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">    <span class="keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">        exit()          <span class="comment">#游戏的退出</span></span><br><span class="line">    <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">        <span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:</span><br><span class="line">            loc = pygame.mouse.get_pos()</span><br><span class="line">            <span class="keyword">if</span> (loc[<span class="number">0</span>] &gt; width / <span class="number">2</span> <span class="number">-90</span>) <span class="keyword">and</span> (loc[<span class="number">0</span>] &lt; width / <span class="number">2</span> +<span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &gt; height / <span class="number">2</span> <span class="number">-80</span>) <span class="keyword">and</span> (loc [<span class="number">1</span>] &lt; height / <span class="number">2</span> +<span class="number">80</span>):</span><br><span class="line">                start_fly(screen <span class="comment">#进入start_fly表示进入开始游戏之后的循环体</span></span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>这个项目没有使用任何的图片素材，因此游戏画面内所有的元素由<strong>pygame.draw</strong>模块绘制完成，并且为了达到这种像素风，仅仅使用了<strong>pygame.draw.rect</strong>来完成基本矩形的绘制。以下谈到的像素均为自己定义的像素，而非实际像素。</p>
<h2 id="需要用到的类"><a href="#需要用到的类" class="headerlink" title="需要用到的类"></a>需要用到的类</h2><p>游戏画面采取的是笛卡尔坐标系，以窗口左上角为坐标原点，x轴正方向往屏幕右侧，y轴正方向往屏幕下侧。</p>
<ul>
<li><strong>class Pixel:</strong><br> 像素类，用来对定义的像素点做基本的绘制，移动操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixel</span>:</span></span><br><span class="line">    <span class="string">"""游戏内容均为像素点,实质上为固定大小的矩形"""</span></span><br><span class="line">    scale = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    location = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    color = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment">#构造方法 需要的参数有像素的长宽，起始位置，颜色，均由元组表示。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, scale , location, color)</span>:</span></span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.location = location</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,target)</span>:</span></span><br><span class="line">        self.location = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ncolor</span><span class="params">(self,color)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self,screen)</span>:</span></span><br><span class="line">        pygame.draw.rect(screen,self.color,(self.location,self.scale))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>class element：</strong><br>这个类通过使用<strong>class Pixel:</strong>的实例化对象来绘制获得游戏内容。通过改变成员变量 <strong>shift[ x, y]</strong> 的值来控制图像外接矩形左上角的坐标，改变 <strong>speed[ x, y]</strong> 来控制图像在x轴及y轴上的平移速度。而该类提供了 <strong>move(location)</strong> 和 <strong>setSpeed(speed)</strong> 两个成员方法来改变上述两个量。图片的绘制信息位于 <strong>build_BIRD，build_CLOUD ，build_SWITCH ，build_OBSTACLE， LETTER</strong>几个变量中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pixel <span class="keyword">import</span> Pixel</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    pixelScale = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#此处的长宽代表像素点的个数</span></span><br><span class="line">    scale = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    mes = []</span><br><span class="line">    shifting = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    speed = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">#构造方法，传入欲绘制图像的像素点长宽（元组），整个图像外接矩形的长宽（元组），图片的绘制信息格式为((x,y),color)，以此类元组形成的列表传入构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,pixelScale,scale,mes)</span>:</span></span><br><span class="line">        self.pixelScale = pixelScale</span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.mes = mes</span><br><span class="line"><span class="comment">#将图像绘制到指定的surface对象上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self,screen)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(self.mes)):</span><br><span class="line">            location = [(self.mes[_][<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span>) * self.pixelScale[<span class="number">0</span>] + self.shifting[<span class="number">0</span>], (self.mes[_][<span class="number">0</span>][<span class="number">1</span>]) * self.pixelScale[<span class="number">1</span>] + self.shifting[<span class="number">1</span>]]</span><br><span class="line">            color = self.mes[_][<span class="number">1</span>]</span><br><span class="line">            pixel = Pixel(self.pixelScale,location,color)</span><br><span class="line">            pixel.draw(screen)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,location)</span>:</span></span><br><span class="line">        self.shifting = location</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setSpeed</span><span class="params">(self,speed)</span>:</span></span><br><span class="line">        self.speed = speed</span><br></pre></td></tr></table></figure>

<h2 id="对象的构造"><a href="#对象的构造" class="headerlink" title="对象的构造"></a>对象的构造</h2><ul>
<li><strong>开始按钮</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">switch = Element((<span class="number">10</span>, <span class="number">10</span>),(<span class="number">13</span>, <span class="number">18</span>), build_SWITCH)</span><br><span class="line">switch.move((width / <span class="number">2</span> - <span class="number">90</span>,height / <span class="number">2</span> - <span class="number">80</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小鸟</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鸟</span></span><br><span class="line">bird = Element((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">11</span>, <span class="number">17</span>), build_BIRD)</span><br><span class="line">bird.move((size[<span class="number">0</span>] / <span class="number">2</span> - <span class="number">60</span>, size[<span class="number">1</span>] / <span class="number">4</span>))</span><br><span class="line">bird.draw(screen)</span><br><span class="line">bird.speed = [<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>云</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cloud_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_1.move((size[<span class="number">0</span>] / <span class="number">6</span>, size[<span class="number">1</span>] / <span class="number">5</span>))</span><br><span class="line">cloud_1.setSpeed((<span class="number">-0.7</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">cloud_2 = Element((<span class="number">7</span>, <span class="number">7</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_2.move((size[<span class="number">0</span>] / <span class="number">1.2</span>, size[<span class="number">1</span>] / <span class="number">3</span>))</span><br><span class="line">cloud_2.setSpeed((<span class="number">-1.5</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">cloud_3 = Element((<span class="number">10</span>, <span class="number">10</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_3.move((size[<span class="number">0</span>] / <span class="number">2</span>, size[<span class="number">1</span>] / <span class="number">1.5</span>))</span><br><span class="line">cloud_3.setSpeed((<span class="number">-2</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>障碍物</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obstacle_1_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_1_1.move((size[<span class="number">0</span>], -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_1_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_1_2.move((size[<span class="number">0</span>], <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_1_2.scale[<span class="number">0</span>]*obstacle_1_2.pixelScale[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">obstacle_2_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_2_1.move((size[<span class="number">0</span>] *<span class="number">1.4</span> , -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_2_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_2_2.move((size[<span class="number">0</span>] *<span class="number">1.4</span>, <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_2_2.scale[<span class="number">0</span>]*obstacle_2_2.pixelScale[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">obstacle_3_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_3_1.move((size[<span class="number">0</span>] *<span class="number">1.7</span> , -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_3_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_3_2.move((size[<span class="number">0</span>] *<span class="number">1.7</span>, <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_3_2.scale[<span class="number">0</span>]*obstacle_3_2.pixelScale[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>分数</strong></li>
</ul>
<p><strong>score</strong> 用来存储当前分数，游戏结束的时候返回游戏分数这个参数至主界面并显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每过一个障碍物加一分，显示分数</span></span><br><span class="line">        score_ten = Element( (<span class="number">10</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="number">5</span>), LETTER[ int (score / <span class="number">10</span>) ] )</span><br><span class="line">        score_one = Element( (<span class="number">10</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="number">5</span>), LETTER[ score % <span class="number">10</span>] )</span><br><span class="line">        score_ten.move((<span class="number">10</span>,<span class="number">0</span>))</span><br><span class="line">        score_one.move((<span class="number">60</span>,<span class="number">0</span>))</span><br><span class="line">        score_ten.draw(screen)</span><br><span class="line">        score_one.draw(screen)</span><br></pre></td></tr></table></figure>

<h1 id="游戏元素的动画"><a href="#游戏元素的动画" class="headerlink" title="游戏元素的动画"></a>游戏元素的动画</h1><p>所有的游戏动画均为平移，因此使用 <strong>class Element:</strong> 里的 <strong>move(location)</strong> 和 <strong>setSpeed(speed)</strong> 足以完成所有的动画效果。小鸟处于确定x坐标的竖直区域运动，云和障碍物不断的左移即可。</p>
<h2 id="开始游戏"><a href="#开始游戏" class="headerlink" title="开始游戏"></a>开始游戏</h2><p>在遍历消息队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:</span><br><span class="line">	loc = pygame.mouse.get_pos()</span><br><span class="line">                 <span class="comment">#开始新游戏</span></span><br><span class="line">       <span class="keyword">if</span> (loc[<span class="number">0</span>] &gt; width / <span class="number">2</span> - <span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">0</span>] &lt; width / <span class="number">2</span> + <span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &gt; height / <span class="number">2</span> - <span class="number">80</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &lt; height / <span class="number">2</span> + <span class="number">80</span>):</span><br><span class="line">       	score = start_fly(screen)</span><br></pre></td></tr></table></figure>

<h2 id="云的左移"><a href="#云的左移" class="headerlink" title="云的左移"></a>云的左移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_animation</span><span class="params">(cloud)</span>:</span></span><br><span class="line"><span class="comment">#若云的整体位置已越过窗口左侧，设置云的外接矩形左上角位于窗口最右侧。</span></span><br><span class="line">    <span class="keyword">if</span> cloud.shifting[<span class="number">0</span>] &lt; - (cloud.scale[<span class="number">1</span>] * cloud.pixelScale[<span class="number">1</span>]):</span><br><span class="line">        cloud.move((size[<span class="number">0</span>], cloud.shifting[<span class="number">1</span>]))</span><br><span class="line">    cloud.move(( cloud.shifting[<span class="number">0</span>] + cloud.speed[<span class="number">0</span>], cloud.shifting[<span class="number">1</span>] ))</span><br><span class="line">    cloud.draw(screen)</span><br></pre></td></tr></table></figure>
<h2 id="小鸟的向下匀加速直线运动"><a href="#小鸟的向下匀加速直线运动" class="headerlink" title="小鸟的向下匀加速直线运动"></a>小鸟的向下匀加速直线运动</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bird.move((bird.shifting[<span class="number">0</span>], bird.shifting[<span class="number">1</span>] + bird.speed[<span class="number">1</span>]))</span><br><span class="line">bird.speed[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">bird.draw(screen)</span><br></pre></td></tr></table></figure>
<h2 id="监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果"><a href="#监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果" class="headerlink" title="监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果"></a>监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果</h2><p>在遍历消息队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">        mouse = pygame.mouse.get_pressed()</span><br><span class="line">        <span class="keyword">if</span> mouse[<span class="number">2</span>]:</span><br><span class="line">bird.speed[<span class="number">1</span>] -= <span class="number">25</span></span><br></pre></td></tr></table></figure>
<h2 id="障碍物的移动以及判断小鸟是否与障碍物相撞"><a href="#障碍物的移动以及判断小鸟是否与障碍物相撞" class="headerlink" title="障碍物的移动以及判断小鸟是否与障碍物相撞"></a>障碍物的移动以及判断小鸟是否与障碍物相撞</h2><p>（由于一开始游戏难度过大， 我将障碍物设置为空心，即小鸟不会和障碍物的正下方或正上方相撞，但会和障碍物的侧边相撞）<br>通过传入一定范围内的随机参数ran控制障碍物从最右端开始向左平移的初始位置。在每个障碍物对象经过小鸟的位置令分数+1，便可完成分数的记录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obstacle_animation</span><span class="params">(obstacle,ran,bird_height)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; - (obstacle.scale[<span class="number">1</span>] * obstacle.pixelScale[<span class="number">1</span>]):</span><br><span class="line">        obstacle.move((size[<span class="number">0</span>], obstacle.shifting[<span class="number">1</span>] + ran * (obstacle.scale[<span class="number">1</span>] * obstacle.pixelScale[<span class="number">1</span>]) ))</span><br><span class="line">    obstacle.move(( obstacle.shifting[<span class="number">0</span>] - <span class="number">1</span>, obstacle.shifting[<span class="number">1</span>] ))</span><br><span class="line">    obstacle.draw(screen)</span><br><span class="line">    <span class="keyword">if</span> (obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>) <span class="keyword">and</span> (obstacle.shifting[<span class="number">0</span>] &gt; size[<span class="number">0</span>] / <span class="number">2</span> - <span class="number">60</span>):   <span class="comment">#可能发生碰撞的矩形区域</span></span><br><span class="line">        <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] &lt; <span class="number">0</span>:  <span class="comment">#和上管道相撞的区域</span></span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] + <span class="number">375</span> &gt;= bird_height: <span class="comment">#和上管道右侧相撞的区域</span></span><br><span class="line">                <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] + <span class="number">375</span> &gt;=bird_height:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> obstacle.shifting[<span class="number">1</span>] &lt; bird_height:</span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] &lt; bird_height:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="小游戏的打包"><a href="#小游戏的打包" class="headerlink" title="小游戏的打包"></a>小游戏的打包</h1><p>(已安装<strong>pyinstaller</strong>)<br>在命令行窗口，进入到游戏入口文件的路径下输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyinstaller -w -F 文件名.py 文件名.py...</span><br></pre></td></tr></table></figure>
<p>打包完成之后可执行文件处于<strong>dist</strong>目录下。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>pygame确实十分的方便，功能其实远不止这个小游戏所用到的这些，而我的这种自己建类绘制图形其实没有什么必要，直接导入图片资源，pygame就能够构造以这个图片资源为基础的surface对象，并提供了许多方法来操作，远比上述自己创造的类方法要灵活，最主要的是，在设计2D游戏的过程中，完全不需要花大量时间在游戏框架的构造上，一个小游戏一天便可开发完成。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-1-两数之和</title>
    <url>/2020/02/16/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</p>
</blockquote>
<a id="more"></a>

<p>我本来想通过暴力解法来解这种题，因为逻辑并不复杂。但是后面又想到了一种通过使用HashMap的方法，能够将时间复杂度降为o(n)。</p>
<p>我们要想知道数组中和等于target的两个下标，也就是想要知道对于一个数组中的数，如果target减这个数也存在数组中，那么这两个数的下标就是我们要的答案。在对数组的一次遍历中，将遍历到的数的值作为键，下标作为值，以这样一个二元组加入到一个HashMap集合中。因为通过键访问值只需要常数级的时间复杂度。所以在每一次对数组元素的访问中，查看HashMap集合中是否存在一个以target-nums[i]为键的元组，若存在，则返回它的值，它的值就是我们在此前一起传入的下标。我们要的答案就是现在的i,和通过HashMap集合找到对应的值，即原本的下标。</p>
<p>这道题表明使用哈希表来存储需要通过值来访问得到序号的二元组是十分有效的，因为哈希表的键可以存储任意类型的元素，用值来存储整型的下标。需要注意的是，哈希表中一个键只能对应一个值，一个值却可以对应多个键，类似于函数中的单射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数关系</title>
    <url>/2019/12/19/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>要考研了，复习高数不定积分那一块的时候竟然发现有一些三角函数居然都没见过，特此记录一下他们与sin，cos，tan之间的关系，主要是正割余割。至于和差化积那些转换关系，既然考研不要求就不记了。</p>
<a id="more"></a>
<h2 id="倒数关系"><a href="#倒数关系" class="headerlink" title="倒数关系"></a>倒数关系</h2><blockquote>
<p>sin a * csc a=1<br>cos a * sec a=1<br>tana * cota=1</p>
</blockquote>
<h2 id="商数关系"><a href="#商数关系" class="headerlink" title="商数关系"></a>商数关系</h2><blockquote>
<p>tana=sin a / cos a<br>cota=cos a / sin a</p>
</blockquote>
<h2 id="平方关系"><a href="#平方关系" class="headerlink" title="平方关系"></a>平方关系</h2><blockquote>
<p>(sin a)^2 + (cos a)^2=1<br>1+(tan a)^2 = (sec a)^2<br>1+(cot a)^2 = (csc a)^2</p>
</blockquote>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
</search>
