<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode刷题笔记-55-跳跃游戏</title>
    <url>/2020/03/19/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。<br>示例：</p>
<blockquote>
<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
</blockquote>
<a id="more"></a>
<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>由于这道题归到了树那一类的题，因此看完题目之后很自然的会往基于递归回溯的方面想。其实就是穷举，基本思想就是如果在当前的位置下，所有能够到达的那些位置是符合条件能够到达最后一个位置的位置，那么当前这个位置也是符合条件的位置，那么由此可以写出基本的穷举解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> can(<span class="number">0</span>,nums,stat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> begin,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==nums.size()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin + <span class="number">1</span>);i&lt;=min(begin+nums[begin],(<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);i++)</span><br><span class="line">            <span class="keyword">if</span>(can(i,nums,stat))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个解法的效率是很低下的，这个写出来一跑是肯定超时的。空间复杂度o(n)，需要的栈空间大小跟n呈线性关系。时间复杂度o(2^n)。证明如下：<br><image src="https://lh3.googleusercontent.com/0clchBhT0eT4X_OQJmx-g1SMoZew7X9jWR-cIxgITaLNdAsQ4x8hat7kjJDQ2m3SE90RQpuK_eeJ90UVH-b42i0qMvwbzD8guxzh37g7SiZ1vBTgpNDDKPmKgdd19AS9-MAbnrpvECZp7ypYIfvfH8CCY-tpb-k4KDiP0Zw4Mk7piLGugeYQHucEerHy2FpUHIFwPztiFe7UiEmpTleTctRmzPZ8301vCAEMBZZ3wg5h2nFxzDfG6xbeghLjDuPUJuaK_YWEYoimnZBOXfPI48QHUWKNZWqJIVkhP6wn0ECzX7ZhzQ8nw09RNgcf-2jeFCIezHA9dFreeRetGNdmZM35-VLExcT4dYUZDG95Kaqnnc_p4e1Daw_qBlce3GLe-mTuRaFvoMSGmOcnEDr_Rxaflix5euEhx1gxFMd3Q2nGwOjsdMYYAXMK0NV5hXHtnSTKzDk7Jq76mW5zAeFGsN2-5ddk2MWPU0RKqQblZFLvTGiZ9IFvfveTb2Lpk1A58dBLbFgowOM1aiBY1ovK4e-2-KxgZjJfuWlCiZguHCu2YAesWgQjoLnr0Alzgf0KfeOzk2Yh6hfxwaj-sYlhGXEpen0JmmE5hKFkWBw0wweh9JeXMciYPJOU_ZXlrVr_dQPqyLYMTWN4vEnAqlvohxzeZmLnPpzgMmitm38WVmnRU2Jf1xoSnsVvjGvW=w986-h572-no"></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="自顶而下"><a href="#自顶而下" class="headerlink" title="自顶而下"></a>自顶而下</h2><p>事实上，回溯法的弊端就在于重复得计算了大量已经知道结果的位置。那么对于回溯法的一种优化方式就是将已经得到结果的位置记录下来，如果递归进行到该位置那么可以直接使用该位置的结果进行回溯，而不需要再把这个位置继续递归计算一遍。那么为了记录每一个位置对于最后位置的到达情况，可以用一个辅助数组来记录。辅助数组长度与原数组长度相同，下标一一对应。用三个状态来表示当前位置对最后的位置可达的情况，比如-1代表情况未知，0代表不可达，1代表可达。因此将辅助数组初始化为最后一位为1，因为最后一位到最后一位当然是可达的，其余位设为-1，都还未知。那么在回溯的过程中每成功判断一个位置的情况之后都需要记录在辅助数组上，所以往下递归只针对那么没有计算到的位置。所以递归的终止条件，也就是回溯的开始条件就是当该位的状态已知，要么0要么1的时候。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stat</span><span class="params">(nums.size()<span class="number">-1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stat.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> can(<span class="number">0</span>,nums,stat);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">can</span><span class="params">(<span class="keyword">int</span> begin,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stat[begin]!=<span class="number">-1</span>)<span class="keyword">return</span> stat[begin]==<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin + <span class="number">1</span>);i&lt;=min(begin+nums[begin],(<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);i++)</span><br><span class="line">            <span class="keyword">if</span>(can(i,nums,stat))&#123;</span><br><span class="line">                stat[begin]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        stat[begin]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个解法利用空间换时间，节省了大量重复的计算，空间复杂度为o(2n)=o(n)，但在leetcode上跑的时候超内存了，它给的测试用例太恶心了，一屏幕的数字。时间复杂度o(n^2)，即对于每个位置的元素都要将该元素后面的元素遍历一遍。</p>
<h2 id="自底而上"><a href="#自底而上" class="headerlink" title="自底而上"></a>自底而上</h2><p>为了消除递归需要的栈空间，我们可以从尾部开始计算辅助数组中的值，为了知道该位置是否对最后的位置可达，只需要将该位置往后所能到达的位置扫描一遍，因为这些位置的状态都是已知的，那么如果有一个可达的位置，那么就得出一个新的可达的位置，将这两重循环进行下去，将会将所有的位置计算一遍，最后再看辅助数组的首位，就能知道首位是否可达了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stat</span><span class="params">(nums.size()<span class="number">-1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        stat.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(nums.size()<span class="number">-2</span>);i&gt;<span class="number">-1</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(i+<span class="number">1</span>);j&lt;=min(i+nums[i],(<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);j++)</span><br><span class="line">                <span class="keyword">if</span>(stat[j]==<span class="number">1</span>)stat[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> stat[<span class="number">0</span>]==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于消去了递归所用的占空间，该算法所需的额外空间消耗只有辅助数组的o(n)，这个算法在leetcode中总算是没超时或超内存，但一看效率依然很低。时间复杂度两重循环可简单看出是o(n^2)。</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>动态规划事实上是一种相当费脑的方法，我认为遇到任何一个问题首先可以考虑贪心法，毕竟相比动态规划要考虑的全局，贪心法只考虑当下就好了。</p>
<p>其实可以把问题先简化为，我从这个位置能否跳到目标位置，如果能到的话，我就可以把目标位置替换成当前位置，那么在当前位置之前的位置如果能到当前位置，也就相当于能够到达目标位置。因此先定义一个目标位置，根据题意，目标位置先定为最后一个位置，再开始从最后一个位置开始一次往回遍历，如果发现有任何一个位置能够到达目标位置，便可以将目标位置换为当前位置。直至遍历结束，容易判断出，第一个位置能够到达最后一个位置的条件就是第一个位置是否能成为上文提到的目标位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(nums.size()<span class="number">-1</span>);i&gt;<span class="number">-1</span>;i--)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + i&gt;=index)</span><br><span class="line">                index = i;</span><br><span class="line">        <span class="keyword">return</span> index==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然还可以从头开始贪婪，这个想法更加简单(贪心)，从第一位开始遍历，用一个变量来记录当前可达的最远位置，直到这个最远位置为最后一个位置。如果当前的位置竟然超过了最大可达位置，那么就可直接得出结论第一位是不可达的。但值得注意的是，并不是发现一个位置的最远位置之后，就可以直接跳到那个最远位置，因为在跳过的这些位置中可能存在着挑更远的位置，所以数组的每一位都要访问到才行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">maxdistance</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;maxdistance)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            maxdistance = max(i+nums[i],maxdistance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结：贪心算法真香！</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-47-全排列II</title>
    <url>/2020/03/18/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-47-%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<blockquote>
<p>输入: <code>[1,1,2]</code><br>输出: [[1,1,2],[1,2,1],[2,1,1]]</p>
</blockquote>
<a id="more"></a>
<p>诚然，用集合容器对向量容器去重效率感人，但十分的方便。该题与上一题的区别就是要去重。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">stat</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        recall(nums,stat,res,<span class="built_in">queue</span>);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(res.begin(),res.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; stat,<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stat[i])&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(nums[i]);</span><br><span class="line">                stat[i] = <span class="literal">true</span>;</span><br><span class="line">                recall(nums,stat,ans,<span class="built_in">queue</span>);</span><br><span class="line">                stat[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>.size()==nums.size())ans.insert(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-46-全排列</title>
    <url>/2020/03/18/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。<br>示例：</p>
<blockquote>
<p>输入: <code>[1,2,3]</code><br>输出:<br>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
</blockquote>
<a id="more"></a>
<p>就喜欢做这类题意容易理解的题，全排列的思路万变不离其宗，还是要基于深度优先策略。在这里特别的是要用一个状态辅助数组来表示在当前路径中该节点已经被访问过。访问过的节点保存入栈，当栈顶高度与给定数组相同时被认为已经访问到了最深处，于是开始回溯，每回溯一步将状态数组的相应位的状态复原。</p>
<p>简单来说，在递归树中，状态数组中的元素代表了该树当前节点需要访问的孩子节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">stat</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        recall(nums,ans,stat,<span class="built_in">queue</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; stat,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stat[i])&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(nums[i]);</span><br><span class="line">                stat[i] = <span class="literal">true</span>;</span><br><span class="line">                recall(nums,ans,stat,<span class="built_in">queue</span>);</span><br><span class="line">                stat[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queue</span>.size()==nums.size())ans.push_back(<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-43-字符串相乘</title>
    <url>/2020/03/17/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br>说明：</p>
<ul>
<li>num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 </li>
<li>num1 和 num2 均不以零开头，除非是数字0 本身。</li>
<li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。<a id="more"></a>
按照题目要求，那就是要按照乘法竖式的规则来进行两个字符串的运算，但如果像我们平常手算那样，先将每一位乘以每一位，再将其错位累加，在算法设计上不好实现。但其实竖式里是能够边乘边加的，实质上就是将两个数按位分解。例如(154<em>28)=(100+50+4)</em>(20+8)。因此有以下过程：<image src="https://lh3.googleusercontent.com/pb7TlUvcHR_VBvOu7PjqBEL57SYGzY_EB-sW31G74jDKOpdR0ZigGcCioLqjs3xj_5pBp0xd4kd5cT-NtAjQgJCwqIHie6xASmdnexShlEYgQ-X3CxxOH0F9r3KfjzUa2Mhxqyk_ttFsFNYgOqQakbhZ68e3f627jOVdeljdL86Sj9HP2jxGJaWQwDYWKqxjlwQK7TrJXQQftq9AbMyeJwRvts3ZTKeCStAImzXYwqBc7NFf6OEdWM0DN9nb68TVehVsFUSpOjQSFX4HcObjFDOx3CIHv-akf6xHdlhXAv7v6TV2HASIDWF9mpELCOV4DCkIVY8dJr3xtAWdXsg73tntG9Z6bBdVYHJLqAaBpZ9ZuHeHBzikywK-yeVGFKRD2AiOX5ABw0h80PCX4T0zuZxV5G0PJ-lN2BBcCEj2EGDYl9-ExJgwB5egAMXR7648k3zZ8ZjaRjXGIpRscRFyuYKVSY--MmUoVxXdYoDzvIxKtd-HGgLuqGOoJ4j4shMJIW9HP1pzkhZRwSzx1VRZ7Il4aPJrXQcWONSYF_n4gH92RwH0Ex44sA1OcIBbj5Vko0c2gnr3Uu4HxODrkJgugY5I0PrHYn05FWugROb2fUxohwi9U0rgc-NFWkDceAVEug1V8kfE2eu8kHDaVqzFB8rlt5saQ8CM22M_ajiC8HnwqtS5U-emRSM6prqv=w903-h840-no">
先将结果串初始化，其长度不会超过乘数与被乘数之积。外层循环从乘数串的尾部开始往回遍历，内层循环从被乘数的尾部开始往回遍历。将两者相乘之后的个位数应该放在结果串的(i+j+1)位置处（从上图中标红处可以看出i+j+1的位置），并且将高位加到(i+j)处，最后将结果串前面的所有0删除就可以了。逻辑其实就是这么简单，但要将其理清楚还是挺费时间的。做这种逻辑题的时候一定要在纸上画，才能容易找到将其抽象化成代码的方法。

</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(num1.size()+num2.size(),<span class="string">'0'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(num2.size()<span class="number">-1</span>);i&gt;<span class="number">-1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(num1.size()<span class="number">-1</span>);j&gt;<span class="number">-1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=(res[i+j+<span class="number">1</span>]-<span class="string">'0'</span>)+(num1[j]-<span class="string">'0'</span>)*(num2[i]-<span class="string">'0'</span>);</span><br><span class="line">                res[i+j+<span class="number">1</span>]=temp%<span class="number">10</span>+<span class="string">'0'</span>;</span><br><span class="line">                res[i+j]+=temp/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;num1.size()+num2.size();i++)<span class="keyword">if</span>(res[i]!=<span class="string">'0'</span>)<span class="keyword">return</span> res.substr(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-104-二叉树的最大深度</title>
    <url>/2020/03/16/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。</p>
<a id="more"></a>
<p>一道二叉树的很基础的题，核心就是。当前树的高度为左子树和右子树中的大者+1。不得不说，用c++写出这么精简的代码还是很有快感的，也就差不多递归能做到了。时间复杂度与二叉树节点的个数呈线性关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root?max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-40-组数总和II</title>
    <url>/2020/03/16/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-40-%E7%BB%84%E6%95%B0%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。<br>说明：</p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<blockquote>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[   [1, 7],  [1, 2, 5],   [2, 6],   [1, 1, 6] ]</p>
</blockquote>
<a id="more"></a>
<p>与上一题不同的是，这里候选序列中的元素可能有相同的元素，但每个元素只能用一次。因此在递归的时候应该带入的循环初值为当前层的循环次数。这题比较讨厌的地方在于递归的时候难以处理候选序列有相同的元素的情况，因为这些相同的元素各只能用一次。遍历的时候去重实在是一件很麻烦的事情。所以我只好先用一个集合来存结果，再把结果存成向量。</p>
<p>一定要好好掌握STL的一些容器和算法，这样也好在一筹莫展的时候取取巧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        recall(candidates,target,<span class="built_in">queue</span>,<span class="number">0</span>,res);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">ans</span><span class="params">(res.begin(),res.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>,<span class="keyword">int</span> begin,<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin);i&lt;candidates.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                recall(candidates,target - candidates[i],<span class="built_in">queue</span>,i+<span class="number">1</span>,ans);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target - candidates[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                ans.insert(<span class="built_in">queue</span>);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-36-有效的数独</title>
    <url>/2020/03/15/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。 </li>
<li>数字 1-9 在每一列只能出现一次。 </li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3宫内只能出现一次。<image src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png">
数独部分空格内已填入了数字，空白格用 '.' 表示。
说明：

</li>
</ol>
<blockquote>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 1-9 和字符 ‘.’ 。</li>
<li>给定数独永远是 9x9 形式的。</li>
</ul>
</blockquote>
<a id="more"></a>
<p>采用三个二维数组来存储每一行每一列每一个九宫格对应数字的个数，遍历一遍进行计数，一旦发现有个数大于2的数字便返回数独无效的信号。常数级时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;,column[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;,box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">0</span>); j &lt; <span class="number">9</span>; j++)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)</span><br><span class="line">                   <span class="keyword">if</span>(( ++row[board[i][j]-<span class="string">'1'</span>][i] &gt; <span class="number">1</span>) </span><br><span class="line">                   ||(++column[board[i][j]-<span class="string">'1'</span>][j] &gt;<span class="number">1</span>) </span><br><span class="line">                   ||(++box[board[i][j]-<span class="string">'1'</span>][(i/<span class="number">3</span>)*<span class="number">3</span> + j/<span class="number">3</span>] &gt;<span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-122-买卖股票的最佳时机II</title>
    <url>/2020/03/14/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>示例：</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>
</blockquote>
<a id="more"></a>
<p>这题比上一题还要更贪，也是贪心的思想。由于题目说了必须是买了卖卖了买这样的顺序。那么为了获得更多的钱，一旦发现今天的价格比昨天高就立马卖出去。不然的话就不卖，这样至少可以算出来理论上赚最多是多少钱。实质上就是每一位增量之和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                max += (prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-121-买卖股票的最佳时机</title>
    <url>/2020/03/14/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。<br>示例：</p>
<blockquote>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
</blockquote>
<a id="more"></a>
<p>就靠卖股票赚钱这几个字眼都能想到用贪心的思想。由于要的只是那个能赚到的最多的前，那就只考虑当下最好情况就好了。遍历的时候把之前遇到的最低谷记住，将之前的最低谷与当前价格的差值与之前计算得到的最大值比较，若更大就更新，遍历完之后返回最大值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> low = prices[<span class="number">0</span>],max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            low = Math.min(prices[i],low);</span><br><span class="line">            max = Math.max(prices[i] - low, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-28-实现strStr</title>
    <url>/2020/03/14/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<p>实现 strStr() 函数。<br>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。<br>示例：</p>
<blockquote>
<p>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>
</blockquote>
<p>说明：<br>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<a id="more"></a>
<p>这道题是一道简单题，所以应该是要求用朴素模式匹配就好了吧。但在明知有KMP算法的情况下就没有必要用朴素算法了。详情见<a href="/2020/02/26/KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" title="另一篇博客">另一篇博客</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle==<span class="string">""</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    int i(0), j(0);</span><br><span class="line">        <span class="keyword">int</span> *next = getNext(needle);</span><br><span class="line">        <span class="keyword">int</span> *nextval = getNextVal(needle,next);</span><br><span class="line">        <span class="keyword">delete</span>[] next;</span><br><span class="line">	    <span class="keyword">while</span> (i &lt; haystack.size())&#123;</span><br><span class="line">		    <span class="keyword">if</span> (j == <span class="number">-1</span>||haystack[i] == needle[j])&#123;i++;j++;&#125;</span><br><span class="line">		    <span class="keyword">else</span> j = nextval[j];</span><br><span class="line">            <span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">                <span class="keyword">delete</span> []nextval;</span><br><span class="line">                <span class="keyword">return</span> (i - j);</span><br><span class="line">            &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	    int i(0),j(-1);</span><br><span class="line">	    <span class="keyword">while</span> (i &lt; s.size()) &#123;</span><br><span class="line">		    <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == s[j])next[++i] = ++j;</span><br><span class="line">		    <span class="keyword">else</span> j = next[j];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getNextVal</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span>* next)</span></span>&#123;</span><br><span class="line">	    <span class="keyword">int</span>* nextval = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	    nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt; s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		    <span class="keyword">if</span> (s[next[i]] == s[i]) &#123;</span><br><span class="line">			    nextval[i] = nextval[next[i]];</span><br><span class="line">		    &#125;<span class="keyword">else</span> nextval[i] = next[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> nextval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-119-杨辉三角II</title>
    <url>/2020/03/13/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/</url>
    <content><![CDATA[<p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。<br><image src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<a id="more"></a>
<p>这题同<a href="/2020/03/13/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/" title="第118题">第118题</a>，还是简化版。当然还有个o(1)的方法供参考（狗头）。<br>正常方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; trans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=rowIndex;i++)&#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            ans.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i - <span class="number">1</span>;j++)&#123;</span><br><span class="line">                ans.add(trans.get(j)+trans.get(j + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>)ans.add(<span class="number">1</span>);</span><br><span class="line">            trans.clear();</span><br><span class="line">            trans.addAll(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>高效法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">pre33</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Integer[][] list = <span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">            &#123;<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">21</span>,<span class="number">35</span>,<span class="number">35</span>,<span class="number">21</span>,<span class="number">7</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">28</span>,<span class="number">56</span>,<span class="number">70</span>,<span class="number">56</span>,<span class="number">28</span>,<span class="number">8</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">36</span>,<span class="number">84</span>,<span class="number">126</span>,<span class="number">126</span>,<span class="number">84</span>,<span class="number">36</span>,<span class="number">9</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">120</span>,<span class="number">210</span>,<span class="number">252</span>,<span class="number">210</span>,<span class="number">120</span>,<span class="number">45</span>,<span class="number">10</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">11</span>,<span class="number">55</span>,<span class="number">165</span>,<span class="number">330</span>,<span class="number">462</span>,<span class="number">462</span>,<span class="number">330</span>,<span class="number">165</span>,<span class="number">55</span>,<span class="number">11</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">12</span>,<span class="number">66</span>,<span class="number">220</span>,<span class="number">495</span>,<span class="number">792</span>,<span class="number">924</span>,<span class="number">792</span>,<span class="number">495</span>,<span class="number">220</span>,<span class="number">66</span>,<span class="number">12</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">13</span>,<span class="number">78</span>,<span class="number">286</span>,<span class="number">715</span>,<span class="number">1287</span>,<span class="number">1716</span>,<span class="number">1716</span>,<span class="number">1287</span>,<span class="number">715</span>,<span class="number">286</span>,<span class="number">78</span>,<span class="number">13</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">14</span>,<span class="number">91</span>,<span class="number">364</span>,<span class="number">1001</span>,<span class="number">2002</span>,<span class="number">3003</span>,<span class="number">3432</span>,<span class="number">3003</span>,<span class="number">2002</span>,<span class="number">1001</span>,<span class="number">364</span>,<span class="number">91</span>,<span class="number">14</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">105</span>,<span class="number">455</span>,<span class="number">1365</span>,<span class="number">3003</span>,<span class="number">5005</span>,<span class="number">6435</span>,<span class="number">6435</span>,<span class="number">5005</span>,<span class="number">3003</span>,<span class="number">1365</span>,<span class="number">455</span>,<span class="number">105</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">16</span>,<span class="number">120</span>,<span class="number">560</span>,<span class="number">1820</span>,<span class="number">4368</span>,<span class="number">8008</span>,<span class="number">11440</span>,<span class="number">12870</span>,<span class="number">11440</span>,<span class="number">8008</span>,<span class="number">4368</span>,<span class="number">1820</span>,<span class="number">560</span>,<span class="number">120</span>,<span class="number">16</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">17</span>,<span class="number">136</span>,<span class="number">680</span>,<span class="number">2380</span>,<span class="number">6188</span>,<span class="number">12376</span>,<span class="number">19448</span>,<span class="number">24310</span>,<span class="number">24310</span>,<span class="number">19448</span>,<span class="number">12376</span>,<span class="number">6188</span>,<span class="number">2380</span>,<span class="number">680</span>,<span class="number">136</span>,<span class="number">17</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">18</span>,<span class="number">153</span>,<span class="number">816</span>,<span class="number">3060</span>,<span class="number">8568</span>,<span class="number">18564</span>,<span class="number">31824</span>,<span class="number">43758</span>,<span class="number">48620</span>,<span class="number">43758</span>,<span class="number">31824</span>,<span class="number">18564</span>,<span class="number">8568</span>,<span class="number">3060</span>,<span class="number">816</span>,<span class="number">153</span>,<span class="number">18</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">19</span>,<span class="number">171</span>,<span class="number">969</span>,<span class="number">3876</span>,<span class="number">11628</span>,<span class="number">27132</span>,<span class="number">50388</span>,<span class="number">75582</span>,<span class="number">92378</span>,<span class="number">92378</span>,<span class="number">75582</span>,<span class="number">50388</span>,<span class="number">27132</span>,<span class="number">11628</span>,<span class="number">3876</span>,<span class="number">969</span>,<span class="number">171</span>,<span class="number">19</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">20</span>,<span class="number">190</span>,<span class="number">1140</span>,<span class="number">4845</span>,<span class="number">15504</span>,<span class="number">38760</span>,<span class="number">77520</span>,<span class="number">125970</span>,<span class="number">167960</span>,<span class="number">184756</span>,<span class="number">167960</span>,<span class="number">125970</span>,<span class="number">77520</span>,<span class="number">38760</span>,<span class="number">15504</span>,<span class="number">4845</span>,<span class="number">1140</span>,<span class="number">190</span>,<span class="number">20</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">21</span>,<span class="number">210</span>,<span class="number">1330</span>,<span class="number">5985</span>,<span class="number">20349</span>,<span class="number">54264</span>,<span class="number">116280</span>,<span class="number">203490</span>,<span class="number">293930</span>,<span class="number">352716</span>,<span class="number">352716</span>,<span class="number">293930</span>,<span class="number">203490</span>,<span class="number">116280</span>,<span class="number">54264</span>,<span class="number">20349</span>,<span class="number">5985</span>,<span class="number">1330</span>,<span class="number">210</span>,<span class="number">21</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">231</span>,<span class="number">1540</span>,<span class="number">7315</span>,<span class="number">26334</span>,<span class="number">74613</span>,<span class="number">170544</span>,<span class="number">319770</span>,<span class="number">497420</span>,<span class="number">646646</span>,<span class="number">705432</span>,<span class="number">646646</span>,<span class="number">497420</span>,<span class="number">319770</span>,<span class="number">170544</span>,<span class="number">74613</span>,<span class="number">26334</span>,<span class="number">7315</span>,<span class="number">1540</span>,<span class="number">231</span>,<span class="number">22</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">253</span>,<span class="number">1771</span>,<span class="number">8855</span>,<span class="number">33649</span>,<span class="number">100947</span>,<span class="number">245157</span>,<span class="number">490314</span>,<span class="number">817190</span>,<span class="number">1144066</span>,<span class="number">1352078</span>,<span class="number">1352078</span>,<span class="number">1144066</span>,<span class="number">817190</span>,<span class="number">490314</span>,<span class="number">245157</span>,<span class="number">100947</span>,<span class="number">33649</span>,<span class="number">8855</span>,<span class="number">1771</span>,<span class="number">253</span>,<span class="number">23</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">24</span>,<span class="number">276</span>,<span class="number">2024</span>,<span class="number">10626</span>,<span class="number">42504</span>,<span class="number">134596</span>,<span class="number">346104</span>,<span class="number">735471</span>,<span class="number">1307504</span>,<span class="number">1961256</span>,<span class="number">2496144</span>,<span class="number">2704156</span>,<span class="number">2496144</span>,<span class="number">1961256</span>,<span class="number">1307504</span>,<span class="number">735471</span>,<span class="number">346104</span>,<span class="number">134596</span>,<span class="number">42504</span>,<span class="number">10626</span>,<span class="number">2024</span>,<span class="number">276</span>,<span class="number">24</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">25</span>,<span class="number">300</span>,<span class="number">2300</span>,<span class="number">12650</span>,<span class="number">53130</span>,<span class="number">177100</span>,<span class="number">480700</span>,<span class="number">1081575</span>,<span class="number">2042975</span>,<span class="number">3268760</span>,<span class="number">4457400</span>,<span class="number">5200300</span>,<span class="number">5200300</span>,<span class="number">4457400</span>,<span class="number">3268760</span>,<span class="number">2042975</span>,<span class="number">1081575</span>,<span class="number">480700</span>,<span class="number">177100</span>,<span class="number">53130</span>,<span class="number">12650</span>,<span class="number">2300</span>,<span class="number">300</span>,<span class="number">25</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">26</span>,<span class="number">325</span>,<span class="number">2600</span>,<span class="number">14950</span>,<span class="number">65780</span>,<span class="number">230230</span>,<span class="number">657800</span>,<span class="number">1562275</span>,<span class="number">3124550</span>,<span class="number">5311735</span>,<span class="number">7726160</span>,<span class="number">9657700</span>,<span class="number">10400600</span>,<span class="number">9657700</span>,<span class="number">7726160</span>,<span class="number">5311735</span>,<span class="number">3124550</span>,<span class="number">1562275</span>,<span class="number">657800</span>,<span class="number">230230</span>,<span class="number">65780</span>,<span class="number">14950</span>,<span class="number">2600</span>,<span class="number">325</span>,<span class="number">26</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">27</span>,<span class="number">351</span>,<span class="number">2925</span>,<span class="number">17550</span>,<span class="number">80730</span>,<span class="number">296010</span>,<span class="number">888030</span>,<span class="number">2220075</span>,<span class="number">4686825</span>,<span class="number">8436285</span>,<span class="number">13037895</span>,<span class="number">17383860</span>,<span class="number">20058300</span>,<span class="number">20058300</span>,<span class="number">17383860</span>,<span class="number">13037895</span>,<span class="number">8436285</span>,<span class="number">4686825</span>,<span class="number">2220075</span>,<span class="number">888030</span>,<span class="number">296010</span>,<span class="number">80730</span>,<span class="number">17550</span>,<span class="number">2925</span>,<span class="number">351</span>,<span class="number">27</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">28</span>,<span class="number">378</span>,<span class="number">3276</span>,<span class="number">20475</span>,<span class="number">98280</span>,<span class="number">376740</span>,<span class="number">1184040</span>,<span class="number">3108105</span>,<span class="number">6906900</span>,<span class="number">13123110</span>,<span class="number">21474180</span>,<span class="number">30421755</span>,<span class="number">37442160</span>,<span class="number">40116600</span>,<span class="number">37442160</span>,<span class="number">30421755</span>,<span class="number">21474180</span>,<span class="number">13123110</span>,<span class="number">6906900</span>,<span class="number">3108105</span>,<span class="number">1184040</span>,<span class="number">376740</span>,<span class="number">98280</span>,<span class="number">20475</span>,<span class="number">3276</span>,<span class="number">378</span>,<span class="number">28</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">29</span>,<span class="number">406</span>,<span class="number">3654</span>,<span class="number">23751</span>,<span class="number">118755</span>,<span class="number">475020</span>,<span class="number">1560780</span>,<span class="number">4292145</span>,<span class="number">10015005</span>,<span class="number">20030010</span>,<span class="number">34597290</span>,<span class="number">51895935</span>,<span class="number">67863915</span>,<span class="number">77558760</span>,<span class="number">77558760</span>,<span class="number">67863915</span>,<span class="number">51895935</span>,<span class="number">34597290</span>,<span class="number">20030010</span>,<span class="number">10015005</span>,<span class="number">4292145</span>,<span class="number">1560780</span>,<span class="number">475020</span>,<span class="number">118755</span>,<span class="number">23751</span>,<span class="number">3654</span>,<span class="number">406</span>,<span class="number">29</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">30</span>,<span class="number">435</span>,<span class="number">4060</span>,<span class="number">27405</span>,<span class="number">142506</span>,<span class="number">593775</span>,<span class="number">2035800</span>,<span class="number">5852925</span>,<span class="number">14307150</span>,<span class="number">30045015</span>,<span class="number">54627300</span>,<span class="number">86493225</span>,<span class="number">119759850</span>,<span class="number">145422675</span>,<span class="number">155117520</span>,<span class="number">145422675</span>,<span class="number">119759850</span>,<span class="number">86493225</span>,<span class="number">54627300</span>,<span class="number">30045015</span>,<span class="number">14307150</span>,<span class="number">5852925</span>,<span class="number">2035800</span>,<span class="number">593775</span>,<span class="number">142506</span>,<span class="number">27405</span>,<span class="number">4060</span>,<span class="number">435</span>,<span class="number">30</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">31</span>,<span class="number">465</span>,<span class="number">4495</span>,<span class="number">31465</span>,<span class="number">169911</span>,<span class="number">736281</span>,<span class="number">2629575</span>,<span class="number">7888725</span>,<span class="number">20160075</span>,<span class="number">44352165</span>,<span class="number">84672315</span>,<span class="number">141120525</span>,<span class="number">206253075</span>,<span class="number">265182525</span>,<span class="number">300540195</span>,<span class="number">300540195</span>,<span class="number">265182525</span>,<span class="number">206253075</span>,<span class="number">141120525</span>,<span class="number">84672315</span>,<span class="number">44352165</span>,<span class="number">20160075</span>,<span class="number">7888725</span>,<span class="number">2629575</span>,<span class="number">736281</span>,<span class="number">169911</span>,<span class="number">31465</span>,<span class="number">4495</span>,<span class="number">465</span>,<span class="number">31</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">32</span>,<span class="number">496</span>,<span class="number">4960</span>,<span class="number">35960</span>,<span class="number">201376</span>,<span class="number">906192</span>,<span class="number">3365856</span>,<span class="number">10518300</span>,<span class="number">28048800</span>,<span class="number">64512240</span>,<span class="number">129024480</span>,<span class="number">225792840</span>,<span class="number">347373600</span>,<span class="number">471435600</span>,<span class="number">565722720</span>,<span class="number">601080390</span>,<span class="number">565722720</span>,<span class="number">471435600</span>,<span class="number">347373600</span>,<span class="number">225792840</span>,<span class="number">129024480</span>,<span class="number">64512240</span>,<span class="number">28048800</span>,<span class="number">10518300</span>,<span class="number">3365856</span>,<span class="number">906192</span>,<span class="number">201376</span>,<span class="number">35960</span>,<span class="number">4960</span>,<span class="number">496</span>,<span class="number">32</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">33</span>,<span class="number">528</span>,<span class="number">5456</span>,<span class="number">40920</span>,<span class="number">237336</span>,<span class="number">1107568</span>,<span class="number">4272048</span>,<span class="number">13884156</span>,<span class="number">38567100</span>,<span class="number">92561040</span>,<span class="number">193536720</span>,<span class="number">354817320</span>,<span class="number">573166440</span>,<span class="number">818809200</span>,<span class="number">1037158320</span>,<span class="number">1166803110</span>,<span class="number">1166803110</span>,<span class="number">1037158320</span>,<span class="number">818809200</span>,<span class="number">573166440</span>,<span class="number">354817320</span>,<span class="number">193536720</span>,<span class="number">92561040</span>,<span class="number">38567100</span>,<span class="number">13884156</span>,<span class="number">4272048</span>,<span class="number">1107568</span>,<span class="number">237336</span>,<span class="number">40920</span>,<span class="number">5456</span>,<span class="number">528</span>,<span class="number">33</span>,<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(pre33.list[rowIndex]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-118-杨辉三角</title>
    <url>/2020/03/13/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><image src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif"><br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<a id="more"></a>
<p>很基础的一道和递推关系有关的题，但比斐波那契数列稍微麻烦的是，杨辉三角是由前一行推出后一行，因此除了参与运算的一个序列之外，还要有一个序列用来保存结果。两个序列交替往下，直到满足条件。每一次循环将结果更新一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; trans1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; trans2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numRows; i++)&#123;</span><br><span class="line">            trans1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            trans1.add(<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; i - <span class="number">2</span> ; j++)</span><br><span class="line">            	trans1.add(trans2.get(j) + trans2.get(j + <span class="number">1</span>));</span><br><span class="line">            trans2.clear();</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>)trans1.add(<span class="number">1</span>);</span><br><span class="line">            trans2.addAll(trans1);</span><br><span class="line">            ans.add(trans1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-17-电话号码的字母组合</title>
    <url>/2020/03/13/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br><image src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png"><br>示例：</p>
<blockquote>
<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<p>说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<a id="more"></a>
<p>这类要求得到可能的所有情况的题，是肯定需要穷举一遍的。因此思路很快就出来了，但由于可能给出的数字个数不确定，因此循环难以达到效果，所以想到递归。那么这题就转化为树的深度优先遍历了，并要用一个序列来存储每一条路径。用一个循环去访问树的同一层的节点。树的层数由候选序列的长度决定，因此递归传入的候选序列长度每次都要减一，直到候选序列变为零意味着递归需要终止。</p>
<p>这题对现在的我来说依然是一道思路五分钟，调bug两小时的题，看来还是要锻炼清晰的思路才行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; keyboard&#123; <span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span> &#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">queue</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(digits!=<span class="string">""</span>)recall(digits, <span class="built_in">queue</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">string</span> digits, <span class="built_in">string</span>&amp; <span class="built_in">queue</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!digits.size()) &#123;ans.push_back(<span class="built_in">queue</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>);j &lt; keyboard[digits[<span class="number">0</span>]<span class="number">-50</span>].size();j++) &#123;</span><br><span class="line">            <span class="built_in">queue</span> += keyboard[digits[<span class="number">0</span>]<span class="number">-50</span>][j];</span><br><span class="line">            recall(digits.substr(<span class="number">1</span>, digits.size() <span class="number">-1</span>), <span class="built_in">queue</span>, ans);</span><br><span class="line">            <span class="built_in">queue</span> = <span class="built_in">queue</span>.substr(<span class="number">0</span>, <span class="built_in">queue</span>.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-88-合并两个有序数组</title>
    <url>/2020/03/12/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。<br>说明:</p>
<blockquote>
<ul>
<li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 </li>
<li>你可以假设 nums1 有足够的空间(空间大小大于或等于m+n)来保存 nums2 中的元素。</li>
</ul>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p>
</blockquote>
<a id="more"></a>
<p>由于给定的数组nums1的尾部是有足够空间的，因此应该考虑新有序数组从nums1的后方开始填入，那么可以分别从后往前比较两个数组的元素大小，大的可填入空位并指针前移，直到一个数组为空，将该数组完全填入新数组前部即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)nums1=nums2;</span><br><span class="line">        int k(m + n - 1),i(m-1),j(n-1);</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)nums1[k--] =( i &gt;= <span class="number">0</span>&amp;&amp;nums1[i] &gt; nums2[j] )? nums1[i--] : nums2[j--];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-13-罗马数字转整数</title>
    <url>/2020/03/12/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<blockquote>
<p> 字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值<br>I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50<br>C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100<br>D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500<br>M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000</p>
</blockquote>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<blockquote>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
</blockquote>
<p> 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。<br> <a id="more"></a><br> 这题就是对整数转罗马数字的求逆，对于多分支结构果真还是switch舒服一些，算是遍历串的很基础的内容。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'M'</span>:ans+=<span class="number">1000</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'D'</span>:ans+=<span class="number">500</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'C'</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'D'</span>)&#123;ans+=<span class="number">400</span>;i++;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'M'</span>)&#123;ans+=<span class="number">900</span>;i++;&#125;<span class="keyword">else</span> ans+=<span class="number">100</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'L'</span>:ans+=<span class="number">50</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'X'</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'L'</span>)&#123;ans+=<span class="number">40</span>;i++;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'C'</span>)&#123;ans+=<span class="number">90</span>;i++;&#125;<span class="keyword">else</span> ans+=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'V'</span>:ans+=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'I'</span>:<span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'V'</span>)&#123;ans+=<span class="number">4</span>;i++;&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">'X'</span>)&#123;ans+=<span class="number">9</span>;i++;&#125;<span class="keyword">else</span> ans+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-39-组数总和</title>
    <url>/2020/03/11/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-39-%E7%BB%84%E6%95%B0%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。<br>说明：</p>
<blockquote>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
</blockquote>
<p>示例：</p>
<blockquote>
<p>输入: candidates = [2,3,6,7], target = 7,<br>所求解集为:<br>[<br>  [7],<br>  [2,2,3]<br>]</p>
</blockquote>
<a id="more"></a>
<p>这题乍一看有点像之前的寻找两数和三数和四数和的类型，但是显然情况会多很多，因为允许相加的元素使用多次。那就只好建立一个树，然后采用深度优先搜索算法进行遍历。</p>
<p>首先将候选序列进行排序，排序有两个好处，一是能够去重，二是可以减少搜索时间。用一个栈类型的序列来存储可能满足条件的序列，达到满足条件的时候将该序列追加至结果序列。树的每一层的循环递归搜索应当避免从头开始，由于已经排好序，可以每次递归传入一个参数来确定当前层开始遍历的索引。采用传引用的递归方式可以无需返回值，大大简化了搜索逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(),candidates.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">        recall(ans,candidates,<span class="number">0</span>,<span class="built_in">queue</span>,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recall</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> begin,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">queue</span>,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(begin);i&lt;candidates.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target-candidates[i]&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target-candidates[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                recall(ans,candidates,i,<span class="built_in">queue</span>,target - candidates[i]);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">queue</span>.push_back(candidates[i]);</span><br><span class="line">                ans.push_back(<span class="built_in">queue</span>);</span><br><span class="line">                <span class="built_in">queue</span>.pop_back();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-12-整数转罗马数字</title>
    <url>/2020/03/11/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<blockquote>
<p>字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值<br>I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br>V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br>X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50<br>C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100<br>D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;500<br>M&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1000</p>
</blockquote>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<blockquote>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
</blockquote>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<a id="more"></a>
<p>这个问题其实很简单，就是把这个限定范围的数字拆解之后用给定规则的字母表达出来，时间复杂度必然是o(1)，因为变换规则始终是有限的，数字如果还要增大就需要加入新的规则。</p>
<p>看了其他那些大佬的题解之后，我承认自己的想法挺弱智，毕竟他们想到了贪心算法。但下图已经让我很满足：<br><image src="https://lh3.googleusercontent.com/XaKIdSGvpxxg4hMEiKK_iWuw4D9FVpdEjiHJB8VYVpiCmS0bmHEpiuk1VftOQliYCSDF7hulXjxkAsRKLn-Wgf-JSvgqWY-kzJTGvMtmnFKSMZjJ_id0iDy8MrUZzJHQQNOH5Pj-6cehTdURF3woQXnSMpfKVXMrP0EGQ2EPZDXBItShLay3uEU4h4h-MzfdG8SVtXMoDjukreI0hmjf_5VpOuLKwA_jSNwEjKNVYluzFn9QEoszxxbkZPHL1hrMp8u21hHaXVWyR6JJyFTASghVJQllarBFhAq5dSLCZFS-jq3ZOellLxHr187xfx1z_YWTdf7JvcclFx4VyDlAjnD5V__bUIUEeTCl-eXcVsJqwNZNi_t2YbS-PLMwGUKfOJrNlhM8NbWwai-x4KuNylVOvEblByv3SEBV8QnV9gfvS5NEoOpB2UfABLAi2KKSJO75483Ymrx3tcQXWBQd9yexWuu-2G3Nx0dXpuUzt-phyPHT3HmZGgO5eRs7wSu-xsiLKSkvy3NoZDZ8rIXP3IkkQnIxs8-bay36pDVVVAa81PIONA2cqcUHU8tKBA1OL1F3-qZKXC6JxrdOPjlH7sAz-y88WHysHWwqqL8N0x6QgxtCJt9i4CPk9exXMEngUJAVM0h3Bsm7oGWj86sscOahEGX3999ZnPRAAuVHRUXgJqlsY3KG72C2OXs6=w621-h215-no"><br>贪心算法实质上是对于当前状态的数字，寻找能够拆分成的最大字母，然后两者相减得到新的数字，也就是把我的条件判断整合成循环而已。当然，以后贪心算法还是要好好研究的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(num/<span class="number">1000</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"M"</span>;</span><br><span class="line">            num %=<span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">900</span>)&#123;</span><br><span class="line">            ans+=<span class="string">"CM"</span>;</span><br><span class="line">            num -=<span class="number">900</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">500</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">500</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"D"</span>;</span><br><span class="line">            num %=<span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">400</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"CD"</span>;</span><br><span class="line">			num -=<span class="number">400</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"C"</span>;</span><br><span class="line">            num %=<span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">90</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"XC"</span>;</span><br><span class="line">			num-=<span class="number">90</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">50</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">50</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"L"</span>;</span><br><span class="line">            num %=<span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">40</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"XL"</span>;</span><br><span class="line">			num-=<span class="number">40</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"X"</span>;</span><br><span class="line">            num %=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">9</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"IX"</span>;</span><br><span class="line">			num-=<span class="number">9</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num/<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num/<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"V"</span>;</span><br><span class="line">            num %=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(num/<span class="number">4</span>)&#123;</span><br><span class="line">			ans+=<span class="string">"IV"</span>;</span><br><span class="line">			num-=<span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">if</span>(num)&#123;</span><br><span class="line">            <span class="keyword">int</span> counter = num;</span><br><span class="line">            <span class="keyword">while</span>(counter--&gt;<span class="number">0</span>)ans+=<span class="string">"I"</span>;</span><br><span class="line">            num-=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-66-加一</title>
    <url>/2020/03/10/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<br>示例：</p>
<blockquote>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
</blockquote>
<a id="more"></a>
<p>将一个数字加一，大多数情况其实就是把它的个位数加一，但还有一种特殊情况，就是要进位的时候。那就直接模拟加法竖式的进位，由于是加一，还是简化版。</p>
<p>判断出最低位为9，那么需要进位，进位的同时该位置0，看上一位，如果非9，那么直接加一，否则重复上述步骤。一直到所有位都为9的时候，也就是从后往前已经遍历到第一位的时候，这时候表明所有位已经都是0了。那么为了在开头插入一个1，有个巧妙的方法就是数组第一位置1，最后一位插入一个0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = digits.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i]==<span class="number">9</span>)&#123;</span><br><span class="line">                digits[i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    digits[i] = <span class="number">1</span>;</span><br><span class="line">                    digits.push_back(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> digits;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-53-最大子序和</title>
    <url>/2020/03/09/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br>示例:</p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<p>进阶:<br>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<a id="more"></a>
<p>时间复杂度为o(n)的算法：<br>这个算法其实就是贪心算法，总是考虑加上现在遍历到的这个数是否会比现在大，会的话就算上，不会的话之前的序列就不要了，从现在这个元素开始看有没有新的序列比较大。由于有一个变量用来实时保存最大序列和，所以遍历整个序列之后，总能得到一个最大的子序和。时间复杂度o(n)，空间复杂度o(1)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        int n(1),sum(nums[0]),ans(nums[0]);</span><br><span class="line">        <span class="keyword">while</span>(n&lt;nums.size())&#123;</span><br><span class="line">            sum = max(nums[n] + sum,nums[n]);</span><br><span class="line">            ans = max(sum,ans);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然还有一种形式上差不了太多，就是多一个指针，用滑动窗口的方法也能做出来，算是动态规划。至于题目里面说到的那个“更为精妙的分治法”，这个问题貌似确实能用分治法，但更为精妙就…没感受出来。<br>以下是leetcode官方题解中的分治法，时间复杂度o(nlog(n))，空间复杂度o(log(n))</p>
<blockquote>
<p>当最大子数组有 n 个数字时：<br>若 n==1，返回此元素。<br>left_sum 为最大子数组前 n/2 个元素，在索引为 (left + right) / 2 的元素属于左子数组。<br>right_sum 为最大子数组的右子数组，为最后 n/2 的元素。<br>cross_sum 是包含左右子数组且含索引 (left + right) / 2 的最大值。<br><image src="https://pic.leetcode-cn.com/3aa2128a7ddcf1123454a6e5364792490c5edff62674f3cfd9c81cb7b5e8e522-file_1576478143567"></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftSubsum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> currSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p; i &gt; left - <span class="number">1</span>; --i) &#123;</span><br><span class="line">      currSum += nums[i];</span><br><span class="line">      leftSubsum = Math.max(leftSubsum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightSubsum = Integer.MIN_VALUE;</span><br><span class="line">    currSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; right + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      currSum += nums[i];</span><br><span class="line">      rightSubsum = Math.max(rightSubsum, currSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftSubsum + rightSubsum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftSum = helper(nums, left, p);</span><br><span class="line">    <span class="keyword">int</span> rightSum = helper(nums, p + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> crossSum = crossSum(nums, left, right, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(leftSum, rightSum), crossSum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-22-括号生成</title>
    <url>/2020/03/09/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n = 3，生成结果为：</p>
<blockquote>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
</blockquote>
<a id="more"></a>
<p>这道题一开始看到的时候，直觉告诉我要要遍历一棵树才能得到这样一个穷举的序列，但实在是太麻烦了。</p>
<p>后面想到动态规划的思想，可以把从1个括号的组合开始，到n个括号的组合这样的一个个序列看成一个个状态。细心可以发现，第n个状态是可以用第n-1个状态推出来的。即，第n个状态就是在第n-1的所有状况的基础上多出来一对括号，现在就只需要讨论这多出来的一对括号如何摆放。</p>
<p>假设将要加入的那一对括号固定，假设前一个状态被分为两个子序列p，q，并且p，q也同样是满足题意的两个状态，这样才能保证组合成的状态n是有效的。之后也就是反过来将已有的序列插入两个括号中四个位置中的两个位置。由于p的长度为0到n-1，对于每一个p都有q = n-1-p，因此可以有以下两种插法：</p>
<blockquote>
<p>“(“ + p + “)” + q<br>p + “(“ + q + “)”</p>
</blockquote>
<p>可以发现两种插法其实是等效的，所以只需要取一种就可以保证不重复。那么直观一些可以用递归的方法。对每一个p求对应的q，由于p和q都分别是所对应状态的一组序列，所以要将他们递归求出之后再分别遍历并两两组合，将组合的结果放入答案序列中。</p>
<p>递归的方法很简洁直观，但递归树呈二叉树的形态发展，时间空间复杂度惊人。非递归化的方法就是在外面套一层循环，将迭代算出的结果放入定义好的数据结构中，再用已有的数据去算下一个状态。</p>
<p>实质上这题就是要发现状态n与状态n-1之间的关系，这样会很好做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)ans.push_back(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">string</span> p:generateParenthesis(i))</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> q:generateParenthesis(n<span class="number">-1</span>-i))</span><br><span class="line">                    ans.push_back(<span class="string">"("</span>+p+<span class="string">")"</span>+q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-48-旋转图像</title>
    <url>/2020/03/08/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。<br>说明：<br>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。<br>示例：</p>
<blockquote>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
</blockquote>
<a id="more"></a>
<p>这题乍一看很复杂，实质上就是将矩阵逆置一次，再左右翻转一次。整个的时间复杂度是o(n^2)，n是方阵阶数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[j][i];</span><br><span class="line">                matrix[j][i] = matrix[i][j]^matrix[j][i];</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;matrix.length/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[i][matrix.length-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][matrix.length-j-<span class="number">1</span>] = matrix[i][j]^matrix[i][matrix.length-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][j] = matrix[i][j]^matrix[i][matrix.length-j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-38-外观数列</title>
    <url>/2020/03/08/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<blockquote>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221<br>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</li>
</ol>
</blockquote>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。<br>注意：整数序列中的每一项将表示为一个字符串。</p>
<a id="more"></a>
<p>虽然是简单题，但读题都花了好长时间。弄懂了什么意思之后，还找了很久是不是第n个字符串和n之间有什么关系。目前是，没有。</p>
<p>只好按照递推关系做，显然这种递推关系既可以用循环也可以用递归。虽然递归会有o(n)的空间消耗，但毕竟写起来舒服，对于n-1的字符串的扫描操作，递归和循环是一样的。循环只不过是在不用调用自身的基础上，在外面又套了一层循环而已。下面是耗费空间打败5%用户的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        <span class="built_in">string</span> str = countAndSay(n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">string</span> strnext = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;str.size();i++)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">counter</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">while</span>(str[i]==str[i+<span class="number">1</span>])&#123;</span><br><span class="line">                counter++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            strnext=strnext + (<span class="keyword">char</span>)(counter+<span class="number">48</span>)+str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-35-搜索插入位置</title>
    <url>/2020/03/07/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。<br>示例：</p>
<blockquote>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
</blockquote>
<a id="more"></a>
<p>既然这种题都能出出来，摆明了不能用暴力解法。除此之外就是二分查找了，由于我二分查找喜欢让左右边界紧挨就停止循环，这样就不需要在每次缩小范围的时候进行边界判断，而只需要在结束状态做判断就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        int i(0),j(nums.size()-1);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">((i + j)&gt;&gt;<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;target)j = k;</span><br><span class="line">            <span class="keyword">else</span> i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[i]&gt;=target?i:(nums[j]&lt;target?j+<span class="number">1</span>:j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当然还有作弊解法。。而且原理就是二分查找：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lower_bound(nums.begin(), nums.end(), target) - nums.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-61-旋转链表</title>
    <url>/2020/03/07/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>示例 1:</p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
</blockquote>
<a id="more"></a>
<p>这题里说的旋转，实质上就是找到倒数第k个节点，将其断开，再将前半段尾接到后半段上，就完成了所谓的旋转。</p>
<p>需要注意的是，k的值是有可能大于整个链表长度的，所以应该用链表长度对k取模，这样才是需要断开节点的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p(head),*q(head);</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)&#123;p = p-&gt;next;size++;&#125;</span><br><span class="line">        k %=size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;k;i++)q = q-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(p = head;q-&gt;next;q=q-&gt;next,p=p-&gt;next);</span><br><span class="line">        q-&gt;next = head;</span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-34-在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/03/06/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。<br>示例：</p>
<blockquote>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p>
</blockquote>
<a id="more"></a>
<p>看到这个要求的时间复杂度，那么还是考虑二分查找。对于二分查找的两个指针，一旦有一个指针的值是target的值，那么就可以直接以这个位置为终点，循环向两边查找有没有其他的相同的值，然后返回两指针的位置。要是两个指针都碰一起了还没有一个指针找到target，那么就退出循环，返回两个-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target)k = i;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == target)k = j;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=k)j = k;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[k]&lt;target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=k)i = k;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = k;j = k;</span><br><span class="line">                <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])i--;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;nums.length-<span class="number">1</span>&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])j++;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-21-合并两个有序链表</title>
    <url>/2020/03/06/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p>
<blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<a id="more"></a>
<p>思路十分的简单，确立一个新链表的指针，两个分别指向原有序链表的指针，从头开始比较两个链表指向节点元素的大小，把小的给新链表，小的指针后移。直到短的那个链表遍历完成。最后只要将长的链表剩下的一段全部给新链表就下了。单链表就是方便在成批的复制数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = l1,*q = l2,*k = head;</span><br><span class="line">        <span class="keyword">while</span>(p&amp;&amp;q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;=q-&gt;val)&#123;</span><br><span class="line">                k-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            k = k-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        k-&gt;next = p?p:q;</span><br><span class="line">        ListNode *ans = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-9-回文数</title>
    <url>/2020/03/05/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<a id="more"></a>
<p>从题目可以看出，负数不可能是回文数，首先排除。对于整数，若将其反转，回文数的数值大小应该保持不变。因此思路就出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> reverse=<span class="number">0</span>,y = x;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(reverse&gt;INT_MAX/<span class="number">10</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            reverse = reverse*<span class="number">10</span> + y%<span class="number">10</span>;</span><br><span class="line">            y/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (reverse==x)?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-20-有效的括号</title>
    <url>/2020/03/05/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：<br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<a id="more"></a>
<p>栈的应用在括号匹配这一方面体现的极为契合。但有一点，栈空的时候不能弹出元素或访问栈顶元素，因此我将一个可辨识的元素压入栈底作为标识。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line">        brackets.push(<span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'('</span>||s[i]==<span class="string">'['</span>||s[i]==<span class="string">'&#123;'</span>)brackets.push(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(brackets.top()==<span class="string">'('</span>)brackets.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(brackets.top()==<span class="string">'['</span>)brackets.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(brackets.top()==<span class="string">'&#123;'</span>)brackets.pop();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> brackets.top()==<span class="string">'0'</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Fibonacci数列算法效率对比</title>
    <url>/2020/03/03/Fibonacci%E6%95%B0%E5%88%97%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>由于计算时间复杂度是研究数据结构与算法的一项非常重要的工作，现在以经典的求解斐波那契数列的第n项为例，探讨各个算法的时空复杂度。</p>
<a id="more"></a>
<h1 id="斐波那契数列简介"><a href="#斐波那契数列简介" class="headerlink" title="斐波那契数列简介"></a>斐波那契数列简介</h1><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：</p>
<blockquote>
<p>1、1、2、3、5、8、13、21、34、……</p>
</blockquote>
<p>在数学上，斐波那契数列以如下被以递推的方法定义：</p>
<blockquote>
<p>F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）</p>
</blockquote>
<p>在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用。</p>
<p>由斐波那契的定义式可看出，这是一个递归定义，由前后递推关系得出的一个数列。</p>
<h1 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h1><p>直接由定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Fibonacci(<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>递归的时间复杂度计算方式为递归的次数*函数体内执行的语句数，而在这里只涉及到递归的次数。每个函数均要调用两次递归，递归的深度为（n-2），那么容易得到这种算法的时间复杂度为<code>o(2^n)</code>。</p>
<p>如果要从数值上准确计算执行时间，那么就是将数列的一般公式</p>
<blockquote>
<p>F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）</p>
</blockquote>
<p>转化为二阶常系数齐次差分方程。</p>
<blockquote>
<p>在F(0)=1，F(1)=1的情况下，为了求F(n)，可以得到特征方程为 x^2-x-1=0，解得x=(1±√5)/2 ，<br>因此F(n)的通解为F(n)=C1((1+√5)/2)^n + C2((1-√5)/2)^n，<br>再将F(0)=1，F(1)=1作为初值带入解得C1，C2.</p>
</blockquote>
<p>因此其资源消耗是极其恐怖的，假设要求数列的第五项，其所对应的递归树如图所示：<br><image src="https://lh3.googleusercontent.com/fdb87r1z-pXdar1TEe2lzm9-JLVLkx6sJRR7hWPIJaijieFDbdmAWOKKdlAqnEdq-ozfdSKSNLT_YY-tqt_BIAGGKMzDdCWl-MzdSFgu9s8r3Qksjwp_UtagKgByeW1TVvaWgBTthMfWEb-Def5spnDUUcWdYqF4dUkjfeAUFpEOjQ651ZjwcQZFQIahHRUBksSiJr7TiiXCH_Q5Zd7DkqZVJtH_5h42OLWHXNclSGF9-UMSprX5drfNWixkwWF0u6fVEjctLaU9r1oR88IDemkUPBU7kVhR1T207GAKnU2AFYNIoyytF_1HZplx4Lk1KN1hZ0zpycby-jG463ctsDtxJLt52IIXMG9fCxIVNO9tZyXhqKU9oqYaXdsD-fPUoHJHFLh_i2UhqCnaqqsw0X7lxwNNPgbyZOGxuSiQ_eHg_2xRMZWiZoaaMdKT8CxU0k6MnpD5Wv9bIFnYvCu61u1B3lmZgihlg2Cl27f-RsxfkVQ-YSfblWg-q0V6CSigilwNpdO_nL9My3XShSip5PfV58hyYdWFiY3lkHAeMCc_Iw52__FVkAu8gLjOWa1e_we2F1Pb7re0F2dpDzlcaeR0iGmE4Oyh3HBBCoQ8zBwFQd3WIqko-R43NWf5Jg9i9gJv5qChVC-L8gUlsVe3dTEpUkIgWaRFzjh1zDo6ijkjpiaEQ7akFiInrPHY=w1340-h706-no"><br>可以从图中看到，数列第三项计算了两次，数列第二项计算了三次，数列第一项计算了三次。这个算法慢的本质其实是调用了过多重复计算的项。</p>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>递归算法的空间复杂度等于递归深度*每次递归需要的辅助空间，因此应该是<code>o(n)</code>。</p>
<h1 id="尾递归解法"><a href="#尾递归解法" class="headerlink" title="尾递归解法"></a>尾递归解法</h1><p>由于照抄定义的直接递归解法效率过低，这里就提出了一种优化方案，以减少重复计算数列中项的次数，但代价是要传入两个初值作为参数，换句话说，这样递归的方向就是把普通递归的方向反过来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">3</span>)<span class="keyword">return</span> a + b;</span><br><span class="line">	<span class="keyword">return</span> Fibonacci(b, a + b, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Fibonacci(<span class="number">1</span>,<span class="number">1</span>,<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>由于尾递归将所有的运算提到递归语句之前因此减少了大量的回调，可直接返回递归最深层的返回值。而从该递归的递推关系可以理解为，要求前两项为1，1的斐波那契数列，那就不断的调用自身的累加计算，结束条件就是加够(n-2)次，因此递归深度就是(n-2)，由此可得时间复杂度为<code>o(n)</code>。递归树如下：<br><image align=" center" src="https://lh3.googleusercontent.com/jG2vRP6MyF0Ht9EsPbSemJVUr_ei_4kG8kDtlgMPo18BRBdzdIOf847DScnK8-qWEFUm7h8I7wrwUeW9LiWSO43KFdFaWZ2xZPxBhTjGKljIFUWwDqSFaB_L6woGFnz7aomNWu4YrZMV4WgnBCV9DyIC_B5tW3sCr5i6h8zrJ1eY91JGazyut9CTmK1qQ73CJAhBfCU1hBiOw3FU82_NFeY2HScOIRRBw3OXS8jg3BEuggox0gfGKqcPvHQLG2UI69e9Ta5-rIIQlUKji4uBBOLdwrvCSMU_mfuHNFijzdorRHRKrEASoe048PJXwzGmKJS3T82LeB6fPeYij5tNP7_s0iUiMVXFSW-Gr9maNuaJmXguvELw-JqF2Wd1fLv7hwHZ8h-qmF8uZjxODUTBbwXuzp8o42Edg-OrGps4cL_KfyeS4ZuXWJE9wGrJPuGKqXJpHJpG2rj0Tz3P88yPCmgJZxo7hYOT9PNxkc86V7YmYhnF7-fB48msMOE_ICAKqddsaAyXvozV-g_0cKXf3o5MThYFrxHQCYh0p0A_T8h6L6M13sQ8ec1yJDGMMjuEJtLaEQ6fKYtYr6Ck-n5JXIwJnOUd1mtOZeR9jMn6zU99I1Md17Wx-QarBfXr8EyikC_TnH9na-J0peE45kU1hSmM5bQ_t_xIr2QiSXpXInH4I1oceX5Hx3KJieRd=w432-h650-no"><br>尾递归在改善递效率上有着很好的效果。</p>
<h2 id="空间复杂度分析-1"><a href="#空间复杂度分析-1" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>尾递归依然是递归，在空间的开销上就注定比较大，因为递归深度为(n-2)，因此斐波那契数列的尾递归算法空间复杂度为<code>o(n)</code>。</p>
<h1 id="循环算法"><a href="#循环算法" class="headerlink" title="循环算法"></a>循环算法</h1><p>这种算法算是抛弃了递归的弊端，直接将递推公式写在了循环里，但事实上，循环和递归本身也有许多相似之处，他们对于初值，运算的条件都有限制。这是一种性能尚佳，容易想出的算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int j(1), k(1);</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">3</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> t = k;</span><br><span class="line">		k = j + t;</span><br><span class="line">		<span class="keyword">if</span> (k &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		j = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j + k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fibonacci(<span class="number">30</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>根据循环的条件以及终止条件可以看出，循环体将执行(n-3)次，因此时间复杂度为<code>o(n)</code>。</p>
<h2 id="空间复杂度分析-2"><a href="#空间复杂度分析-2" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>由于该算法只使用了常数级的辅助空间，因此原地工作的空间复杂度为<code>o(1)</code>。</p>
<h1 id="矩阵快速幂解法"><a href="#矩阵快速幂解法" class="headerlink" title="矩阵快速幂解法"></a>矩阵快速幂解法</h1><h2 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h2><p>首先介绍一下快速幂算法，在计算机中，如果要计算m^n，通常的朴素算法是在循环中将m乘n次，但是有些时候这种算法的效率较为低下。</p>
<p>不妨设想，假如我要在记事本中将 “ hello world! “ 这句话复制1000份，如果是朴素算法，那就是连按1000下的p。但我们显然有更高效的方法，比如先将一句话复制10遍，再全选，再复制10遍，再全选，再复制10遍。转化为代数式就是</p>
<blockquote>
<p>1000 = 10^3 = 10^0 * 10^1 * 10^2</p>
</blockquote>
<p>这样做的效率将大大增加，快速幂的思想就是源于此，本质就是通过指数的分解，降低进行乘法的次数，因此该算法重点研究的就是指数的分解。</p>
<p>以上是快速幂在手算中比较直观的体验，但是在计算机中，效率还会更高。因为二进制表示法中，移位可以代替大量的乘除法，并且开销极小。</p>
<p>下面来看计算3^13，为了将其分解为能够进行移位运算的模式，需要将指数拆分成2的次幂的和，并确保项数最小。那么就可以拆分成</p>
<blockquote>
<p>13 = 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0</p>
</blockquote>
<p>的形式，而这也正好契合了二进制数的基本形态，13的二进制恰好是1101，因此可以从低位至高位依次扫描每一位。进一步观察，拆分之后的每一项的前者与后者呈平方关系，并且系数由二进制数的对应位所确定。因此算法的基本框架就成型了。很显然，系数为0的项数是不需要算的，并且需要计算的乘法只包括前一项向后一项的平方递推，还有该位系数为1时可以将对应的该项乘入结果。</p>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>但如何将快速幂运算与斐波那契数列的求解结合呢。<br>由斐波那契数列的定义式：</p>
<blockquote>
<p>F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）</p>
</blockquote>
<p>如果将其写成矩阵形式，将会是：</p>
<blockquote>
<p>(1 1)叉乘（F(n-1) 等于（F(n)）<br>(1 0)    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(F(n-2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(F(n-1))</p>
</blockquote>
<p>那么其与幂运算之间的关系将会一目了然，由于初值为（1 1），现在要求解斐波那契数列就能转化为求（1 1）叉乘（1 1，1 0）的（n-2）次幂，其结果的第一行第一行第一列的元素就是我们所要求的斐波那契数列的第n项。根据快速幂运算的原理，只是通过拆分指数的方式就能达到提高效率的目的。因此只需要将对普通数的快速幂运算中的底数换为矩阵，将乘法换为矩阵乘法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//矩阵乘法运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrix_Multiplication</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m1, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m2, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span>* ans = <span class="keyword">new</span> <span class="keyword">long</span>[n*n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>); j &lt; n; j++)&#123;</span><br><span class="line">			<span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k(<span class="number">0</span>);k &lt; n;k++) &#123;</span><br><span class="line">				sum += m1[i+k*n] * m2[k+j*n];</span><br><span class="line">			&#125;</span><br><span class="line">			ans[i+j*n] = sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m1.clear();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>);i &lt; n * n;i++)m1.push_back(ans[i]);</span><br><span class="line">	<span class="keyword">delete</span>[] ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n-=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; sum&#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>)matrix_Multiplication(sum, m, <span class="number">2</span>);</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		matrix_Multiplication(m, m, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; m&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	fibonacci(<span class="number">30</span>, m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析-3"><a href="#时间复杂度分析-3" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>由于上述用到的矩阵乘法恒为计算二阶方阵的乘法，因此单次乘法计算运行时间为常数级。由于每一次拆项都将n右移一位，而结束条件是n右移到0的时候。将n右移一位就相当于将n除以2，因此循环体内语句进行的次数应该为log(2)(n)，因此时间复杂度为<code>o(log(n))</code>。</p>
<h2 id="空间复杂度分析-3"><a href="#空间复杂度分析-3" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>由于该算法只用到了常数级的辅助空间，因此空间复杂度为<code>o(1)</code>。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>个人是对于斐波那契数列的美妙之处十分的赞叹，而光是该数列的求解算法就能直接列出来四种。并且也可以看出，算法的高效与否，在于程序员的倾注程度，比如说如果就按照定义来的递归求解，这根本不费脑子，却有着极低的效率，再看矩阵的幂运算，为了其算法的高效，在主算法之前还要做矩阵相关的铺垫。可以说，为了提高运行效率，写多几行代码是很有必要的，就好像是程序员替愚蠢的CPU想到了很多避免重复计算的情况，所以要写下来告诉CPU。这四个算法也告诉我们，递归一定要慎用。</p>
]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-8-字符串转换整数</title>
    <url>/2020/03/03/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：<br>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例：</p>
<blockquote>
<p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p>
</blockquote>
<a id="more"></a>
<p>本来字符串转整数是一件很简单的事情，但题干却加了很多限制条件，强行增加程序设计时要考虑的范围。可以先用一个循环跳过所有的非正负号和数字字符，由于从高位开始读取数字，因此在累加的时候记得移位。时间复杂度o(n)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> bol = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; str.size() &amp;&amp; str[i] == <span class="string">' '</span>)++i;</span><br><span class="line">		<span class="keyword">if</span> (i == str.size())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">'-'</span>) &#123; bol = <span class="number">-1</span>; ++i; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">'+'</span>) &#123; bol = <span class="number">1</span>; ++i; &#125;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; str.size() &amp;&amp; str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">			res = res * <span class="number">10</span> + str[i++] - <span class="number">48</span>;</span><br><span class="line">			<span class="keyword">if</span> (res &gt; INT_MAX) &#123;</span><br><span class="line">				<span class="keyword">if</span> (bol == <span class="number">1</span>)<span class="keyword">return</span> INT_MAX;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">return</span> INT_MIN;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res * bol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-14-最长公共前缀</title>
    <url>/2020/03/03/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。<br>示例：</p>
<blockquote>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p>
</blockquote>
<a id="more"></a>
<p>在算法储备还不太足的情况下我还是采用了这种按位比较的方法，效率不算慢，而且还很好想。练了一段时间的题，中等难度的题可能会花特别久时间，简单题还算是一看就有思路，很快就写出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">0</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(strs.size()==<span class="number">1</span>)<span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i(<span class="number">0</span>);i&lt;=strs[<span class="number">0</span>].size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j(<span class="number">1</span>);j&lt;strs.size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;strs[j].size())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(strs[j][i]==strs[<span class="number">0</span>][i])</span><br><span class="line">                        &#123;<span class="keyword">if</span>(j==strs.size()<span class="number">-1</span>)ans=strs[<span class="number">0</span>].substr(<span class="number">0</span>,i+<span class="number">1</span>);&#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-7-整数反转</title>
    <url>/2020/03/02/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例：</p>
<blockquote>
<p>输入: 123<br>输出: 321</p>
</blockquote>
<blockquote>
<p>输入: -123<br>输出: -321</p>
</blockquote>
<blockquote>
<p>输入: 120<br>输出: 21</p>
</blockquote>
<p>注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<a id="more"></a>
<p>将原数不断除10可以从左往右依次得到每一位，然后累加。需要注意的是每次累加需要将原数*10保证移位。还有在判断是否溢出的时候需要在溢出之前判断，如果想在溢出之后再判断的话就直接报错了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans&gt;INT_MAX/<span class="number">10</span>||ans&lt;INT_MIN/<span class="number">10</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans = ans*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-54-螺旋矩阵</title>
    <url>/2020/03/02/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。<br>示例：</p>
<blockquote>
<p>输入:<br>[<br>&nbsp; [ 1, 2, 3 ],<br>&nbsp; [ 4, 5, 6 ],<br>&nbsp; [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p>
</blockquote>
<a id="more"></a>
<p>这道题的意思也就是说需要换一种方式输出这个二维数组，那么就需要我们去为此制定一条规则。</p>
<p>对于整个数组，指针的移动一共可以有四种方向，因此指定四种状态。在循环中每种不同的状态对应的指针移动策略都不同，并且要有边界判断，当到达这个边界的时候边界要缩小，并且切换下一种状态。而这四种状态是不断地轮流切换的。而循环的终止条件可以设立为答案数组中的元素个数大于等于原矩阵中元素个数的时候。</p>
<p>这个规则还是很容易想的，但卡住人的还是在边界判断上，比如下面表示左或上边界的那个start，我就在那里卡了很久，本来我在第三第四种状态的边界条件成立的时候都把start++了，但事实证明触及左边界或上边界的时候只需要在先触及的那一次加就够了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(ans);</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==<span class="number">0</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        bool row(true),column(true);</span><br><span class="line">        int m(matrix.size()),n(matrix[0].size());</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="number">0</span>)</span></span>;    </span><br><span class="line">        int i(0),j(0);</span><br><span class="line">        <span class="keyword">while</span>(ans.size()&lt;matrix.size()*matrix[<span class="number">0</span>].size())&#123;</span><br><span class="line">            ans.push_back(matrix[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(row&amp;&amp;column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(++j&gt;=n)&#123;--j;++i;column=!column;--n;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(row&amp;&amp;!column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(++i&gt;=m)&#123;--i;--j;row = !row;--m;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!row&amp;&amp;!column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--j&lt;start)&#123;++j;--i;column = !column;++start;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!row&amp;&amp;column)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--i&lt;start)&#123;++i;++j;row = !row;&#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-29-两数相除</title>
    <url>/2020/03/01/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。<br>示例：</p>
<blockquote>
<p>输入: dividend = 10, divisor = 3<br>输出: 3<br>输入: dividend = 7, divisor = -3<br>输出: -2</p>
</blockquote>
<p>说明：</p>
<blockquote>
<p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
</blockquote>
<a id="more"></a>
<p>起初看到这道题的时候我以为我二十分钟必AK，但事实还是证明我太小看这道难度中等的题了。一开始很容易想到，将除法转化为减法，每减一次就让答案加一，直到把被除数减得比除数要小，那么就返回。这样确实简单，但这样的话如果遇到大数除小数的情况，时间开销就会非常大。</p>
<p>要想减少时间开销，就得减少用减法的次数，但又不能用乘除法。那就只剩下移位运算了，用移位再加上加减法理论上可以代替任何的乘除法。例如，10=2^3<br>+2^1。</p>
<p>计算机组成原理里面有提及到计算机内部的除法运算，在这时候就可以用高级语言的移位运算来模拟一遍了。而算法步骤就是由除法运算的竖式得来。在循环体中，先将被除数向右移位，从可移动的最大值开始往小试，直到刚好比除数大，因为在这个时候我们才可以开始往竖式上填入商中一位。之后将得到的这一位加到答案中，这里要注意每一位都差了一个数量级，因此要将答案左移之后再加上去。而竖式的每一步，被除数其实都在减少，那么减少的数应该是商中那一位的数值乘以除数，为了将剩下的位数补齐，所以需要将除数左移至与被除数对齐。之后再用新的被除数来除。</p>
<p>这个算法代码的可读性貌似不怎么好，但也不失为一种好的解题方法，我们从小学开始便学习乘法与除法的竖式解法，但令人惊奇的是到现在才对其中的含义似懂非懂，才开始去认真审视其中的原理。除此之外，在解算法题的过程中如果能想到平时就会手工运用的算法，也不失为一种好的选择。</p>
<p>最后还是吐槽一下这道题，由于对输入输出都有范围限制，导致又在判断程序的边界条件上浪费了很多时间，真的吐血。还有，虽是小学的算法，实现起来也蛮抽象的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend == divisor) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(divisor == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = dividend == INT_MIN;</span><br><span class="line">        <span class="keyword">if</span>(flag) dividend += <span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="keyword">bool</span> same = dividend &gt; <span class="number">0</span> ^ divisor &gt; <span class="number">0</span>;</span><br><span class="line">        dividend = <span class="built_in">abs</span>(dividend);</span><br><span class="line">        divisor = <span class="built_in">abs</span>(divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dividend &gt;&gt; i;</span><br><span class="line">            res = (res &lt;&lt; <span class="number">1</span>) + (temp &gt;= divisor);</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= divisor) dividend -= divisor &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> same ? -res - <span class="number">1</span>  :(res != INT_MAX ? res + <span class="number">1</span> : res);</span><br><span class="line">        <span class="keyword">return</span> same ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-5-最长回文子串</title>
    <url>/2020/02/29/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度1000。<br>示例 1：</p>
<blockquote>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
</blockquote>
<p>示例2：</p>
<blockquote>
<p>输入: “cbbd”<br>输出: “bb”</p>
</blockquote>
<a id="more"></a>
<p>根据题目中的提示，这样的最长回文子串应该有两种，一种是中心字符有两个相同的，另一种是中心字符只有一个。如果采用中心展开查找的方式的话，就应该分开两种方式查找。</p>
<p>中心展开用双指针的方式，用两个指针位置之差来比较子串长度，最后返回的子串应该是从前指针截断至后指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,counter = <span class="number">1</span>,max = <span class="number">0</span>,left,right,start = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//odd</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            counter = <span class="number">1</span>;</span><br><span class="line">            left = i - <span class="number">1</span>;</span><br><span class="line">            right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&gt;-<span class="number">1</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">                counter+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(counter&gt;max)&#123;</span><br><span class="line">                start = left + <span class="number">1</span>;</span><br><span class="line">                max = counter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//even</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counter=<span class="number">2</span>;</span><br><span class="line">                left = i-<span class="number">1</span>;</span><br><span class="line">                right = i+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&gt;-<span class="number">1</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">                    left--;</span><br><span class="line">                    right++;</span><br><span class="line">                    counter+=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(counter&gt;max)&#123;</span><br><span class="line">                    start = left + <span class="number">1</span>;</span><br><span class="line">                    max = counter;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-24-两两交换链表中的节点</title>
    <url>/2020/02/29/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例：</p>
<blockquote>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<a id="more"></a>
<p>属于链表的基础操作，最优的方法自然是双指针对链表进行迭代交换了，时间复杂度o(n)，空间复杂度o(1)，不好的地方就是思考两个节点交换的方式得在纸上画出来才一目了然，用递归的方法可以使代码更简洁也更清晰，步骤仍然是递归三部曲：<br>1、找终止条件，显然递归到链表为空或者只有一个节点的时候无法完成交换操作为止。<br>2、找返回值，每一次递归调用的返回值都是一个已经完成交换的子链表。<br>3、找交换过程，对于目前交换的元素来说，换到后面的那个连接的下一个节点应该是以下一个节点为头节点的子链表，而这个子链表应该也是用这个函数本身求出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* realhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        realhead-&gt;next = head;</span><br><span class="line">        ListNode* p = realhead;</span><br><span class="line">        ListNode* q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q&amp;&amp;q-&gt;next)&#123;</span><br><span class="line">            p-&gt;next=q-&gt;next;</span><br><span class="line">            q-&gt;next=q-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;next=q;</span><br><span class="line">            p=p-&gt;next-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> realhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//recursion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *temp;</span><br><span class="line">        ListNode *fi=head-&gt;next;</span><br><span class="line">        temp=fi-&gt;next;</span><br><span class="line">        fi-&gt;next=head;</span><br><span class="line">        head-&gt;next=swapPairs(temp);</span><br><span class="line">        <span class="keyword">return</span> fi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-19-删除链表的倒数第N个节点</title>
    <url>/2020/02/28/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<p>说明：给定的 n 保证是有效的。<br>进阶：你能尝试使用一趟扫描实现吗？</p>
<a id="more"></a>
<p>单向链表无法存储自己的上一个节点的位置，而这道题给出要求删除节点的次序却是倒数的。在尾部次序未知的情况下，我认为是不可能做到成功删除的。那么正常的思路应该是先遍历一遍得到链表的长度，再通过链表长度与给定的n的差值关系确定要删除元素的正序，然后再遍历一遍进行删除。</p>
<p>但是又看到了进阶说明——用一趟扫描，也就是一趟遍历。那么也容易想到，要减少遍历次数，遇事不决双指针嘛。让快指针先移动n步，再让快慢指针一起移动，直到快指针移动到链表尾部。这么看来，确实是遍历了一遍，但本质上跟最原始的办法也没有区别啊，还多用了一个指针。遍历两遍的那个全程只动了一个指针，而这个遍历一遍，却动了两根指针。虽然在同一个循环体内，代码也是依次执行的，所以这两种方式的时间复杂度是同样的线性的。我认为这个遍历一次并没有什么太大意义。</p>
<p>这道题需要注意的地方是，当测试员给出只包含两个节点的链表时，如果没有头节点的帮助，恐怕很难精确地处理这种情况。所以如果给出的链表没有头节点的话，手动加上头节点也是不错的选择。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head-&gt;next)<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="function">struct ListNode <span class="title">realhead</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        realhead.next = head;</span><br><span class="line">        ListNode* p = &amp;realhead;</span><br><span class="line">        ListNode* q = &amp;realhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)q=q-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q&amp;&amp;q-&gt;next)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next =q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>( q == head )head = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-2-两数相加</title>
    <url>/2020/02/28/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<a id="more"></a>
<p>这种题，连数字的在链表中的排序都是按照从低位向高位，那么明摆着就是要将传统的手算加法的规则转化为链表的操作而已。</p>
<p>需要注意的是，两个链表的加法运算，应该以长的链表结束为准来结束运算，而短的链表在缺少的部分理应用0来参与加法运算。</p>
<p>最后还是觉得用java来写跟链表或者地址，指针有关的东西，没内味儿，下次写链表的题还是用cpp吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>,x,y;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            x = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            y = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-33-搜索旋转排序数组</title>
    <url>/2020/02/27/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例：</p>
<blockquote>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p>
</blockquote>
<a id="more"></a>

<p>看到这个时间复杂度必须是o(logn)级别，那么很自然的就想要要用二分法。二分法的精髓在于对一个有序数组，可以通过逐步缩小首位指针的范围，直到范围无法再缩，就能够锁定需要查找的数的位置了。</p>
<p>但这题特殊在，它不是严格的有序数组，而如果对它进行排序，则会打乱我们要找的数的索引，所以不能排序。但即使这样，这个数组也是部分有序的，在二分查找中，只要合理的条件判断，也能够顺利进行下去。</p>
<p>由于我设置了两个指针，所以代码可能有点冗杂，但我做这题的时候也为了追求效率，放弃了优雅，也就选了个条理更清晰的方式。</p>
<p>主要说一下如何进行二分：首先首尾放置指针，仍然以最中间的那个数为基准来比较。根据旋转数组的特征，将中间数与目标数以及数组首位元素比较大小，将会得出目标数到底在中间数的左边还是右边，这时候就可以移动左右指针之一来缩小查找范围了。将中间数与目标数比较好理解，那么为什么还要与数组首位元素比较呢，作为旋转数组，可以知道的是首位元素一定比尾部元素大，同时也可以认为大小介于旋转点与后面那一点之间，这将是确定目标数位置的一个重要的参考，然后以旋转点为界，两侧的子数组是有序的。</p>
<p>当然，如果想追求代码简洁，可以适当用异或来判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>)<span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:(nums[<span class="number">1</span>]==target?<span class="number">1</span>:-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>, k = nums.length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;i&amp;&amp;j&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]==target)<span class="keyword">return</span> k;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)<span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==target)<span class="keyword">return</span> j;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                        j = k;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i = k; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    i = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k]&gt;target)&#123;</span><br><span class="line">                    j = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(target&gt;nums[<span class="number">0</span>])&#123;</span><br><span class="line">                        j = k;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k = (i + j) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP模式匹配算法</title>
    <url>/2020/02/26/KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>这几天复习到数据结构的串的模式匹配，看到KMP算法那么寥寥几行的代码，原本觉得这部分内容很简单，直到我开始尝试去理解它，我才发现我跟大佬的差别。</p>
<a id="more"></a>
<p>之后我花了整整一天半的时间研究这个算法，期间除了吃饭睡觉拉屎，去楼下药店帮拿了一点口罩之外，没有干其他任何事，总算是理解的差不多了。总结一下这个算法，对于模式串本身，如果经常出现重复的子串，用KMP算法确实可以比朴素模式匹配算法快上不少，但要是模式串前后几乎没几个一样的字符时，KMP算法就是用来秀操作的，因为我相信绝大多数的模式串都是短小精悍的，关键词什么的。要是自己写的话还容易纠结于下标的控制。虽然好像听说考研只会在选择题里考手工算next数组，但我还是想把这个无聊的算法彻底弄明白。下面谈谈我目前为止对这个算法的思考。</p>
<h1 id="KMP算法的基本思路"><a href="#KMP算法的基本思路" class="headerlink" title="KMP算法的基本思路"></a>KMP算法的基本思路</h1><p>KMP算法，是名分别为K、M、P的三个美国大佬发明的，算是对传统的朴素模式匹配算法的改进。我们先规定，讨论模式串下标均从1开始。朴素模式匹配算法就不谈了，这个有脑子就能想出来，但朴素模式匹配算法存在一个弊端——当模式串有较多重复元素存在时，主串指针i其实做了很多没有必要的回溯。</p>
<p>而如果想跳过这些没有必要比较的情况，那么就可以想到，主串指针是没有必要回退的，因为当发生与模式串失配的情况时，可以确定的是，此前成功匹配的若干元素形成的字串，其实就是模式串的一个真字串，那么对于这样的一个字串，它的头部和尾部如果发生了重复，就只需要往回移动模式串指针就好了，但是又不需要往回移到初始位置，因为我们看到他的头部和尾部发生了重复，又由于这个头部重复的部分与现在主串指针前的那个模式串真字串重复，而这部分就是真字串的尾部，所以最有利的做法应该是将模式串指针移动至头部重复字串的后一位，再来与当前的主串指针比较。这样，就避免了主串的回溯，单就这个算法本身，简单来看时间复杂度应该是o(n)。</p>
<p>以下是KMP主代码，对于模式串每一个位置发生失配模式串指针所应该回溯的位置，用一个叫next的整型数组来存储，发生失配时直接用里面的数据来对模式串指针进行回溯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMPmatch</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(needle==<span class="string">""</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	int i(0), j(0);</span><br><span class="line">	<span class="keyword">int</span> *next = getNext(needle);</span><br><span class="line">	<span class="keyword">int</span> *nextval = getNextVal(needle,next);</span><br><span class="line">	<span class="keyword">delete</span>[] next;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; haystack.size())&#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span>||haystack[i] == needle[j])&#123;i++;j++;&#125;</span><br><span class="line">		<span class="keyword">else</span> j = nextval[j];</span><br><span class="line">		<span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] nextval;</span><br><span class="line">			<span class="keyword">return</span> i - j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="确定模式串指针的回溯位置"><a href="#确定模式串指针的回溯位置" class="headerlink" title="确定模式串指针的回溯位置"></a>确定模式串指针的回溯位置</h1><p>但问题来了，如何确定在模式串的不同位置发生失配时模式串指针需要回溯的位置呢？我们可以发现，这些位置的确定，只跟模式串有关，并且对于每一个需要求的位置，只跟从模式串当前位置截断，取前者的这个字串有关。我们如果要来求这个神秘的next数组，就只需要看包含模式串第一位的模式串的各个字串就好。根据上述的推理，这个位置应该是这个字串前后重复的部分+1。到这里，我们可能自以为问题就解决了，以后我们遇到每一个模式串，手动去算一下它的next数组就好了。</p>
<p>可是呢，懒人总是有的，他就是不想去算这个next数组，觉得太麻烦了，怎么办呢，交给计算机算吧，所以又展开了一系列头脑风暴，被认为是KMP算法的核心，next数组的求解以及其原理。</p>
<h1 id="next数组代码实现原理"><a href="#next数组代码实现原理" class="headerlink" title="next数组代码实现原理"></a>next数组代码实现原理</h1><p>为了放松一下，先来看下代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNext</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	int i(0),j(-1);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; s.size()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == s[j])next[++i] = ++j;</span><br><span class="line">		<span class="keyword">else</span> j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是觉得很简单，就是这么简单的代码我研究了一天半。来讲解一下。</p>
<h2 id="传统思维"><a href="#传统思维" class="headerlink" title="传统思维"></a>传统思维</h2><p>在明白了next数组各个元素应该怎么填之后，我们的惯性思维就是将问题转化为，对于一个字符串，求其包含头部元素的每一个真字串的头部和尾部重复的最大部分。对了，为什么要的是最大重复个数，我的理解是，为了跳步骤，有辣么多重复的不跳，干嘛去挑一个短的来跳，对于这一点网上很多博客的说法有点复杂，我这个还挺好理解的。好，话说回来，为了解决这个问题，让我们先往暴力法方向想下，好不好将其代码化。我们人脑的思维是，看着这个串，看开头，看结尾，不重复，这次看长一点，看开头，看结尾，还是不重复，如此下去，直到找到重复的，但还要最长的重复串啊，好吧，那就继续…这个思路要翻译成代码，那就是要定义两个指针，一个用来指向头部，一个用来指向尾部，再定义一个变量，在循环中以这个变量的值不大于原串的长度为基准来循环，再再定义一个变量，用来记录最大重复串长度，每次比较之后选择性更新。这跟刚刚贴出来的代码相比，那真是又臭又长，主要是不怎么优雅。我们虽是懒人，代码的优雅性还是得考虑的，就这么简单的事情要搞两层循环？？我们KMP主函数的复杂度才o(n)呢，好吧，要说优化的方法，那肯定是有的。</p>
<h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>有时候觉得学计算机，数学的用处不大，但有时候，数学学的好确实能让你这个麻木的码农变得更加优雅。我的理解是，考虑数学归纳法，用递推关系来求next数组的元素。我们要找的是某个子串的头部与尾部重复的最大长度，那么直接用头部来匹配尾部不就好了，那我们就用尾部作为模式串来匹配头部。既然是归纳法，那就先考虑一般情况，先看中间。假设尾部指针指到了i这个位置，尾部指针指到了j这个位置，而且现在已经知道前面的结果，那么就只剩下两种情况，如果next[i]等于next[j]，考虑到一般情况下（如果指针不越界）next[i-1]=next[j-1]，那么重复的最大子串长度只要在原来的基础上加一，所以next[i]的值应该是数组起始位置到j目前位置的长度，那么就是j-0=j，那么直接将j的值给next[i]好了；另外一种情况，next[i]不等于next[j]，根据KMP算法的规则，不就是找包含模式串第一位一直到i-1位的这个子串的头部与尾部的最大重复长度吗，而且正好，这个值就在next[j]里面，因为next[j]的意思就是如果匹配到i位发生失配，模式串指针应该跳到next[j]这个位置，所以就直接将next[j]赋值给j，让j跳回去重新跟i比较。这样就形成一个循环体，还有一个问题，如果跳回去的过程中一直失配，那不就回不来了，那怎么行，模式串指针可是有一个下限的，那就是0，情况坏也得从0开始比较吧。如果j = -1的时候也需要让i和j都移动一位，那就可以让匹配一直进行下去了。</p>
<p>既然是数学归纳法，考虑完一般情况，还得考虑初值情况。我们说j是子串头部指针，i是子串尾部指针，开始的时候长度起码是2吧，不然的话就不用匹配了，这样的话就令j为-1，i为0，next[0]为-1，也就是说如果第一个位置就失配的话，那就让i无脑后移，然后j也可以到模式串的第一个位置。这样的好处是，由于j为-1，进入循环体之后i就能开始后移，j就算回跳到next[0]，也能够顺利进入让i进入到后移比较的阶段。也可以看出，在next数组里，除了next[0]为-1，后面的元素就都不可能是-1了。还能发现，next[1]肯定是0。整个算法过程如下图(这张图的下标从1开始，原理是一样的)：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS92Mi00N2IyNmRiNjY1OTM3NzQyMGY0MzI2YzMyOTZiYWE5OV9iLndlYnA?x-oss-process=image/format,png" alt="过程图"></p>
<p>这个算法巧妙的利用已知条件递推下一个答案，直到得到所有的答案。可是到了这里，大多数人觉得KMP算法告一段落了，但，还没完。</p>
<h1 id="KMP算法的优化"><a href="#KMP算法的优化" class="headerlink" title="KMP算法的优化"></a>KMP算法的优化</h1><p>目前的next数组令模式串的j指针在失配的回跳，但有的时候会连续回跳，而每一次的回跳都伴随着与主串的比较，如果每次回跳到的那个模式串的值等于目前失配的值的话，那还不如让模式串指针一次性跳到后面目标位置，一样的值就没有必要再次比较了。所以就引出了KMP算法的优化措施，将next数组转化为nextval数组，用来避免模式串j指针回跳之后的值等于目前的值而做的重复的比较。那么将next数组转化为nextval数组的方法也很简单，下标的定义仍然值得注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">getNextval</span><span class="params">(<span class="built_in">string</span> s,<span class="keyword">int</span>* next)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* nextval = <span class="keyword">new</span> <span class="keyword">int</span>[s.size()+<span class="number">1</span>];</span><br><span class="line">	nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt; s.size()+<span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[next[i]] == s[i]) &#123;</span><br><span class="line">			nextval[i] = nextval[next[i]];</span><br><span class="line">		&#125;<span class="keyword">else</span> nextval[i] = next[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nextval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>算上求next数组这一部分，整个KMP模式匹配算法的时间复杂度就大致是o(m+n)了，m是模式串的长度，n是主串的长度。网上其他的讲解基本会用到前缀后缀的概念，那样可能讲述起来会更严谨，但也不易懂。但总的来说，困扰大部分人的是难以理解如何让自己来匹配自己，但准确来讲，是用自己的尾部去匹配自己的头部，然后就是头部尾部指针的初值设定，搞清楚这两点，那就成功十之八九了。</p>
<p>不过我感觉我上述抽象的地方描述的也不算好，但算法这种东西，就是得花时间去磨，有些部分确实是难以言传的。总之，懂的人自然懂，不懂的人花时间磨，总能磨出来的。最后，向那些脑洞大开想出这种奇葩算法的三人组致敬。</p>
]]></content>
      <tags>
        <tag>datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-6-Z字形变换</title>
    <url>/2020/02/24/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<blockquote>
<p>L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R<br>   E&nbsp;&nbsp;T&nbsp;&nbsp;O&nbsp;&nbsp;E&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;G<br>   E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N</p>
</blockquote>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：</p>
<blockquote>
<p>“LCIRETOESIIGEDHN”。</p>
</blockquote>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<a id="more"></a>
<p>第一眼看到这道题的时候，愣是没弄懂这题在讲什么，看了半天才知道是到数学题，就是找规律。那就很简单了，直接把字符串中对应每一个字符的位置与新的位置形成映射，遍历一遍，就出来了。</p>
<p>然而显示很残酷，在计算公式的时候，我抱怨过无数次我的脑子寄存器不够用，根本难以理清关系。后来想到新建一个二维数组，真的以Z字形将字符串存入，再按行遍历，但这方法似乎太笨了些，知道后来看到了一个大佬的想法，才一语惊醒梦中人。</p>
<p>先将图画出来，可以直观的看出各元素的位置结构。先初始化numRows个容器来存储每一行的元素。总体上可以以numRows-1个元素作为一个周期，为什么是numRows-1个，看图看出来的。排除完特殊情况之后，遍历原字符串，计算可得出每一个元素所在的周期数和位序，但是其实周期也分两类，偶数和奇数，可以看出这两类周期的元素对于Z字形的行号的递增方向是不同的，所以用当前周期对二取模可辩别这是奇数还是偶数周期，再分别将字符压入相应的行中。遍历完成之后，将这numRows个容器拼接，就是所求字符串。</p>
<p>了解完这种解法，我只能发出由衷的感叹：妙啊！这就是所谓的数学直觉吗。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">t</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(s.size()&lt;<span class="number">1</span>||numRows&lt;<span class="number">1</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cycle = i/(numRows<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> order = i%(numRows<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cycle%<span class="number">2</span>==<span class="number">0</span>)t[order].push_back(s[i]);</span><br><span class="line">            <span class="keyword">else</span> t[numRows-order<span class="number">-1</span>].push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)ans+=t[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-3-无重复字符的最长子串</title>
    <url>/2020/02/23/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>示例：</p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<a id="more"></a>
<p>实质上是以每个字符开始为基准，看它们接下来最长的无重复字符串有多长。</p>
<p>窗口初始指针i=j=0，使用 HashSet 将字符存储在当前窗口 [i, j)中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p>
<p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，通常这种类似于字符串的模式匹配都可以用窗口法来分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;<span class="keyword">else</span> set.remove(s.charAt(i++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-31-下一个排列</title>
    <url>/2020/02/22/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<blockquote>
<p><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
</blockquote>
<a id="more"></a>

<p>根据题意，要将一个数组表达的数字重排列成一个比原来大，但要尽量小的一个数，如果这样的数不存在则返回重排列成表达最小的数。因此显然要从低位开始比较，也就是从数组的尾部沿着一个升序往回找，直到寻找路径不升反降为止。再考虑替换升序数组的后一位，最后将原来所谓的升序数组反转即可。</p>
<p>具体操作是：令遍历升序数组的指针i位于数组尾部，往回寻找升序数组结束的位置，比如遍历到某一位，发现遍历的上一位的值比目前这一位要大，这时候用指针j记录下这一位的位置，再让指针i往原数组的尾部遍历，找到一位刚好比指针j对应元素大的元素，将这两个元素的位置互换，此时指针j后面部分的元素必然是降序的，因此将它们反转就能得到答案。</p>
<p>这题表明，遍历数组之前要充分搞透原数组向目标数组的变化规律（可以用画图的方法），再用代码实现就显得游刃有余了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = nums.length - <span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                j = i++;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;nums.length&amp;&amp;nums[i]&gt;nums[j])i++;</span><br><span class="line">                swap(nums,j++,i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(i = nums.length - <span class="number">1</span>;j&lt;i;i--,j++)swap(nums,i,j);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>,i = nums.length - <span class="number">1</span>;j&lt;i;i--,j++)swap(nums,i,j);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">        nums[j] ^= nums[i];</span><br><span class="line">        nums[i] ^= nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-27-移除元素</title>
    <url>/2020/02/21/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<a id="more"></a>
<p>此题显然应当用双指针，但与删除重复元素那道题不同的是，此题需要删除指定元素，也就是说如果两个指针如果像之前那样，从同一侧出发，快指针赋值给慢指针的方式，势必会出现很多虽然合法，但是冗余的元素。这时候应当要换一种思维方式，让一个指针访问过的元素避免被另一个指针再次访问，但依然是一个指针主要负责检查，另一个指针负责遍历。</p>
<p>排除完特殊情况之后，首先令检查指针位于0处，遍历指针位于nums.length-1处，比较检查指针所对应的元素是否是target, 如果是的话就把遍历指针对应元素的值传入，遍历指针便可以往低位移动一次，否则就直接将检查指针向高位移动一次，继续检查，由于循环体每次要么移动检查指针，要么检查遍历指针，而无论是检查指针自身移动到的等于target的元素，还是遍历指针传入的等于target的元素，都会因为这个等于target的条件，继续被遍历指针的新元素所覆盖。所以到最后检查指针所经过的区域就是去除完所有target的数组，还保证了其他元素的完整性。</p>
<p>双指针的应用一定要根据具体题目快速判断，灵活运用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                nums[i] = nums[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-26-删除排序数组中的重复项</title>
    <url>/2020/02/21/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<a id="more"></a>

<p>这题当初想了很久，但最后没想到思路这么简单。原地修改数组，要么比较之后赋值，要么比较之后交换，而这里显然赋值就好，因为后面不需要的部分可以不用管。总体的趋势就是令数组前面的重复元素逐渐被后面不重复的元素取代，到最后如果不存在新的元素，那么就返回前面算得的那一段数组的长度。</p>
<p>首先是去重，当数组长度小于二时，就不存在元素什么重不重复了，直接返回数组长度。</p>
<p>如果长度大于二，就依然是双指针的做法，因为已经排好序了，所以重复的同一个元素一定是紧挨着的。将快指针与慢指针比较，如果发现两者相同，那么就慢指针不动，快指针后移一位，继续发现下一个不同的元素，如果不同，将慢指针后移一位，将快指针的值赋给慢指针。这样即可保证慢指针及其之前的元素都不重复，直到快指针遍历完数组所有的元素，慢指针作为结果数组的最后一位，需要返回的值即是慢指针后面那一位的下标，这才是不重复数组的数组长度。</p>
<p>快慢指针大概也算一个很典型的双指针思想，慢指针用来保存记录已经得到的东西，而用快指针在前面搜寻，与前面比较，时间复杂度o(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">2</span>)<span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=nums[j])nums[++i] = nums[j];</span><br><span class="line">				<span class="keyword">else</span> j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-18-四数之和</title>
    <url>/2020/02/20/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<blockquote>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  &nbsp;&nbsp;[-1,  0, 0, 1],<br>  &nbsp;&nbsp;[-2, -1, 1, 2],<br>  &nbsp;&nbsp;[-2,  0, 0, 2]<br>]</p>
</blockquote>
<a id="more"></a>

<p>我快吐了，两数和，三数和，又来个四数和，难道真的没题出了吗，不如出个n数和好了。四数和的做法我想应该可能会有低于o(n^3)时间复杂度的算法，但我是想不出来了（下次一定想）。</p>
<p>还是参考三数和的做法，也就是比三数和多了一个遍历指针，中间多了一层循环，在细节处理上稍复杂一些，还是很考验debug能力的。</p>
<p>废话不多说，上代码！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">4</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">            <span class="keyword">for</span>(a = <span class="number">0</span>; a &lt; nums.length;)&#123;</span><br><span class="line">                b = a+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(b&lt;nums.length - <span class="number">2</span>)&#123;</span><br><span class="line">                    c = b + <span class="number">1</span>; d = nums.length - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(c&lt;d)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[b] +nums[c] + nums[d]==target - nums[a])&#123;</span><br><span class="line">                            ans.add(Arrays.asList(nums[a],nums[b],nums[c],nums[d]));</span><br><span class="line">                            c++;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c-<span class="number">1</span>])c++;</span><br><span class="line">                            d--; <span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d+<span class="number">1</span>])d--;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[b] + nums[c] + nums[d] &lt;target - nums[a])&#123;</span><br><span class="line">                            c++;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[c]==nums[c-<span class="number">1</span>])c++;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            d--;<span class="keyword">while</span>(c&lt;d&amp;&amp;nums[d]==nums[d+<span class="number">1</span>])d--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    b++;<span class="keyword">while</span>(b&lt;nums.length - <span class="number">2</span>&amp;&amp;nums[b]==nums[b-<span class="number">1</span>])b++;</span><br><span class="line">                &#125;</span><br><span class="line">                a++;<span class="keyword">while</span>((a &lt; nums.length)&amp;&amp;(nums[a]==nums[a-<span class="number">1</span>]))a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-16-最接近的三数之和</title>
    <url>/2020/02/19/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>示例：</p>
<blockquote>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<a id="more"></a>

<p>此题的遍历方式与之前的<a href="/2020/02/18/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" title="寻找三数之和等于0">寻找三数之和等于0</a>类似，这题简单在只需要返回那个最接近目标数的三数和因此不需要去重，稍微复杂在这个最接近。</p>
<p>首先还是先对数组进行一次排序，以便指针的全面查找。用一个变量ans来存储目前最接近目标数的结果，初值可随意赋三个确定数组元素的和，比如初始ans = nums[0] + nums[1] + nums[2]。</p>
<p>令指针i做最外层循环，j，k做内层循环，始终保持i &lt; j &lt; k。因此对于每一个i，j的初值为i + 1，k的初值均为nums.length - 1, 比较此时算出的和与此前算得的ans，若更接近目标数则替换，k与j同时移动，若算出的和比target小，则移动指针j，若大，则移动k，否则便是相等，可直接返回，因为此时与目标数是最接近为0，且不可能存在更接近的数了。搜寻直到j &gt;= k，再看下一个的i，对应的j，k。</p>
<p>总之，在数组里要同时访问一定数目的元素的指针设定和移动是大同小异的，应当要会融会贯通。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>, k = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; k) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[j] + nums[k] + nums[i];</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(target - sum) &lt; Math.abs(target - ans))</span><br><span class="line">                    ans = sum;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target)</span><br><span class="line">                    k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)</span><br><span class="line">                    j++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-15-三数之和</title>
    <url>/2020/02/18/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例：</p>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br> [<br> &nbsp; &nbsp;[-1, 0, 1],<br> &nbsp; &nbsp;[-1, -1, 2]<br>]</p>
</blockquote>
<a id="more"></a>

<p>这道题用暴力法搜寻需要 o(n^3) 的时间复杂度，这里我依然用的是增加搜寻指针的方法，需要两次遍历，将时间复杂度降为o(n^2)。</p>
<p>首先是排除特殊情况。</p>
<p>先将数组从小到大排序。定义三个指针i，j，k，开始时i为指向数组第一个位置，j指向数组第二个位置，k指向数组最后一个位置。i的值在最外层增加，j，k，用于对于每一个nums[i]，寻找另外两个符合条件的值。为了保证遍历的有序，必须遵循i&lt;j&lt;k这个基本条件。</p>
<p>先看此时nums[i] + nums[j] +nums[k] 是否为0，如果是，那么就找到了一个符合条件的值，将此三元组放入答案集合中，同时将j和k左移或右移，为什么要同时移动？因为如果只移动其中一个，我们将来要找的对应的剩下那个值其实已经找到了，而数组是已经排好序的，所以搜寻的值只会越来越大或越来越小，现在情况就是nums[i] + nums[j] +nums[k]， 在nums[i]固定的情况下，num[j]如果增大了，nums[k]就必须减小才有可能找到新的三元组。</p>
<p>再看，如果nums[i] + nums[j] +nums[k] 不为0，那么我们就要想办法让指针往有利于让其等于0的方向移动，这里就可以分两种情况，一种是得到的值比0大，我们希望这个减小，按照数组的有序性，必须让k指针左移才能让值减小，之后再作判断，此时如果同时移动两个指针，将可能会少遍历到一些组合。另外一种情况也是以此类推，直到j&gt;=k的时候可以将i指针右移，然后j的初值再赋为i+1，k的初值为数组长度-1，开始寻找对于一个新的nums[i]，符合条件的nums[j]，nums[k]，直到i的位置到了整个数组的倒数第三个。</p>
<p>在每次移动指针的时候要按照题目进行去重处理，方法就是用一个while循环，因为有序数组的话相同的值一定是相邻的，在指针需要移动的时候比较移动前后的值，若相等则继续移动一个单位，注意的是循环条件还需要满足外层循环的条件，否则可能会数组下标越界。i的去重也同理。</p>
<p>这道题同时用到了有序数组的特性和多指针比较法来减少循环次数，不过其实想到一个办法之后能够快速的用代码实现才是更重要的，要是花大量的时间来debug就有点亏了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j, k;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]&lt;=<span class="number">0</span>&amp;&amp;i&lt;nums.length -<span class="number">1</span>)&#123;</span><br><span class="line">                j = i+<span class="number">1</span>; k = nums.length -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]==-nums[k])&#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i],nums[j],nums[k]));</span><br><span class="line">                        j++;k--;</span><br><span class="line">                        <span class="keyword">while</span>(nums[j]==nums[j-<span class="number">1</span>]&amp;&amp;j&lt;k)j++;</span><br><span class="line">                        <span class="keyword">while</span>(nums[k]==nums[k+<span class="number">1</span>]&amp;&amp;j&lt;k)k--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span>(nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;i&lt;nums.length-<span class="number">1</span>)i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-11-盛最多水的容器</title>
    <url>/2020/02/17/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg"  height="200" width="500">

<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p>示例：</p>
<blockquote>
<p>输入: [1,8,6,2,5,4,8,3,7]</p>
<p>输出: 49</p>
</blockquote>
<a id="more"></a>
<p>除了o(n^2)的暴力法之外，可以用双指针来完成一次遍历，近用o(n)找到这个最大的容积。</p>
<p>一开始，指针i位于数组最左侧，指针j位于数组最右侧，用一个变量maxvolume来存储迄今为止得到的最大容积，每次的移动指针都需要将此时算得的容积与旧值比较，若大则更新，否则继续移动指针。由题意可以得知，我们要求的这个容积的值取决于短的那根垂线，对于两根垂线中短的那一根，如果定住指针不动，移动另一指针，无论以后这一边的高是多少，也不可能再找到一个可以比现在更大的容积了。所以指针移动的策略是，比较height[i]与height[j]的大小，谁小就移动谁，直到i&gt;=j,遍历停止，这样的话，maxvolume的值会按正确方向向答案靠拢。</p>
<p>通过使用双指针的方法，通常可以减少一个数量级的时间复杂度，但是需要着重考虑指针移动的策略，以避开不需要的比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxvolume = <span class="number">0</span>, i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            maxvolume = Math.max(maxvolume, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxvolume;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现flybird小游戏</title>
    <url>/2020/02/16/python%E5%AE%9E%E7%8E%B0flybird%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>前段时间了解到python里pygame这个库，突发奇想用python来做一些有趣的小东西，随即就想到了读初中时候那个火了好一阵子失传已久的小游戏–flybird。 游戏逻辑很简单，可以用来体验一下pygame这个强大的将游戏开发专注于游戏逻辑本身的模块。</p>
<a id="more"></a>

<h1 id="整个小游戏的生命周期"><a href="#整个小游戏的生命周期" class="headerlink" title="整个小游戏的生命周期"></a>整个小游戏的生命周期</h1><h2 id="小游戏预览图"><a href="#小游戏预览图" class="headerlink" title="小游戏预览图"></a>小游戏预览图</h2><img src="https://lh3.googleusercontent.com/7gFjaMYGcGLidsiloxbvs_yJWi_GF3qCa67Udn7vrhyBfkRHetd52j9M2LJsTS-M0seEdFn-gBV_vu3uwG6b7WbZk4vNYEP9jQJsXEq9tz1CLxlUoAYUpmgB88aHrEsyuDjDB9grBb93dGn26WE0RcnYtqSknoimbXXN4MsCJNyRRFV4XXtqa2NZ3ovhrdicRB9uTTxEKtk2orOayIIM6npc8UGAj5h2lQTC3gY_wRde6Ix9NRAkrASzg0ONIQrVQ92-ci9ryqc8xGeSUoFaSj5SGRcL4--kV6OG9wd4aERk3sa_LJxPLPpIjFxIhWCAfn-freQcniYZ52_LqqeiooXv34M-1IGIMPuinCMIWje6XYhJPLiM18b8EY7nMJniZQkD-QlwNGhuvQ4Lsk36fe8cx1ylmI8Qz7njSVnrbkEwFePARxshQlRkXQA54ay-GQYdlkKqdj73povybkKobPOG3qPr_MB7XLFnm2HNwZtfJHg9OEsQB0SK_Bzhroj_8gv-9XIHRHekQS6dc83F5OITdpKHCj6Zwy32e6nUkzO8u2Hp9kNYFPZgtNe6UUmZ_AeVVXpAPnby63GPALdCTQCXGCT6eqW4uJvG1gu8NaiApF-inhsUuVr4DpSmpx0rJ-iztUnvHyo3o03qaYYTJiRt__H4KMWNHsPGBhbM-4Geks9NDq55jezsFbRt=w752-h783-no"  height="600" width="600">
<img src="https://lh3.googleusercontent.com/k--8j5e_1DcMLVhtxCSMvjPFYHrNRMyUTX2nNOfi9mMFSt4ps4-j6bMjPoZSGlGOHS6M4lIy2JmVyarYeWxlfnhtBgfHrWa0v54trcZprNmiylrX6JvM4amZxI_Q7IPI--SmqFA-k_0JDz3beWcMk3vE1r55np8vhaYx4QKIAxKxwMfcoXjqk-VwJP0Y7iZDNhaGdsOWbfQrRlM_Z_GWfvoYSOgULb0tNju0ix4xjm1IO1oj6Ce2PZkY9EN0LxJXSpWmzcH7-Hi2x-iDNzTzaLgf0lU0aQrRwoXa2haI4o0LmIsr_-_szA-hrIlQ3MtwtTrFgmWE12gu-lWt_mcwca91QIhCtYr5Oo6x8woe46Th1lXqEaGy8Kv20vKYIs5DzpE8FUa1mXPYG4vXm6V026AEZ0Dph1BwCMItfdb1-XAP4RvmRd8OVX2WPciWhMMSiKagbrIsqJ0LQuW1VKCSuVJC18-OShM_UJ076gc02OHZomLGSuo3m-iSmRXFMs63T0V0cwlfGaY1WPXh6zrTLqPTcwHtgtOwoz9ktZaM57mf8kXQzxKLqtttduhHsE25G-5cdP-fU3toz9SbKYVmLz0M4Gkd_kj16aSZmQ1G1iySt9SuIcrTYBLLQahZ1HjJJrc6gKIGiQcGOf9nHAimw6VJELzJS8Yr17W_e68eXF4Q008ig8UMEhneKdAs=w752-h783-no"  height="600" width="600">
<img src="https://lh3.googleusercontent.com/md-G0-cdwneAytq0j8i6OwmocMU58fwxY5nElS3E4ympSIJfKWC5CW7dO6Y-vS0Ot_3xVuzEjLQe93TuxK0Dq0GB4aO2FnkEywePXst0dFsYi-dLdfhHD5rX3eVTUhdWb40k3tW9Gese3YDxJgODsKRTL81oITiPZupWIQmv5yIxJD3rNe-gWGSrvp9mttbDYMkMY6iHS_a8jVJTOqJcDXgA-aEz6byICXFsljp0kCZJ74CFcFGBeCTl606d-PUCthDHdkDlu5rzodP-MWUKLpIyKvV4gER3iDL-bSuuRvl7q74gTKNb_eui_anC0ZLk2H7Oul-9A2h2UIGXsthfrIWQvyd6F1X5MSVeGyWGUITZb4L961ov5_vVmVPmsC4FBeDW2IWx3ed5XvZFXlo1iSjFWw21HwLEny7s3nqB6tHY9-MlGYg15bZ5ddLS1H0ar-dbioU3aLiwMWsADi5US_rVockhN9e_DxRvadDOGQ3WdDLfaXI5EjzYJ7fa8zujCGJsxHq634g-CihNsbvPHxYKAZCsbghRuHe87Gx8D-zzXHdSXDRBe4m3e5-c36fX_3di71frFN4m0sAcfMTcGLeA9vFISDWMeMX38Kt5KyGxUlobNokaaDwln526j3022b-ys8tLKquLPoHJCZeJqFULorUY45h2AaQWPkYO2NM-HmyR43I-7ug5oJ4Y=w752-h783-no"  height="600" width="600">

<h2 id="pygame的使用"><a href="#pygame的使用" class="headerlink" title="pygame的使用"></a>pygame的使用</h2><p>下载好pygame之后打开pycharm，导入pygame模块，sys中要用到游戏的退出函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame,sys</span><br></pre></td></tr></table></figure>
<p>初始化主窗口：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">size = width, height = <span class="number">600</span>,<span class="number">600</span>    <span class="comment">#窗口大小</span></span><br><span class="line">screen = pygame.display.set_mode(size)</span><br><span class="line">pygame.display.set_caption(<span class="string">"flybird"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="游戏机制"><a href="#游戏机制" class="headerlink" title="游戏机制"></a>游戏机制</h2><p>设计机制是游戏处于一个循环体内，不断刷新窗口内的像素位置，形成动画。以下循环展示了进入游戏的初始界面，首先是第一个<strong>for</strong>循环内的<strong>pygame.event.get()</strong>，所有的监听器处于这个消息队列中，每次循环都对其进行一次遍历。在我们的游戏中一个是要监听游戏关闭事件<strong>pygame.QUIT</strong>，另一个就是鼠标点击事件<strong>pygame.MOUSEBUTTONDOWN</strong>，通过返回鼠标的点击位置来判断是否开始游戏，或是对游戏内小鸟的控制。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">    <span class="keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">        exit()          <span class="comment">#游戏的退出</span></span><br><span class="line">    <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">        <span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:</span><br><span class="line">            loc = pygame.mouse.get_pos()</span><br><span class="line">            <span class="keyword">if</span> (loc[<span class="number">0</span>] &gt; width / <span class="number">2</span> <span class="number">-90</span>) <span class="keyword">and</span> (loc[<span class="number">0</span>] &lt; width / <span class="number">2</span> +<span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &gt; height / <span class="number">2</span> <span class="number">-80</span>) <span class="keyword">and</span> (loc [<span class="number">1</span>] &lt; height / <span class="number">2</span> +<span class="number">80</span>):</span><br><span class="line">                start_fly(screen <span class="comment">#进入start_fly表示进入开始游戏之后的循环体</span></span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>这个项目没有使用任何的图片素材，因此游戏画面内所有的元素由<strong>pygame.draw</strong>模块绘制完成，并且为了达到这种像素风，仅仅使用了<strong>pygame.draw.rect</strong>来完成基本矩形的绘制。以下谈到的像素均为自己定义的像素，而非实际像素。</p>
<h2 id="需要用到的类"><a href="#需要用到的类" class="headerlink" title="需要用到的类"></a>需要用到的类</h2><p>游戏画面采取的是笛卡尔坐标系，以窗口左上角为坐标原点，x轴正方向往屏幕右侧，y轴正方向往屏幕下侧。</p>
<ul>
<li><strong>class Pixel:</strong><br> 像素类，用来对定义的像素点做基本的绘制，移动操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixel</span>:</span></span><br><span class="line">    <span class="string">"""游戏内容均为像素点,实质上为固定大小的矩形"""</span></span><br><span class="line">    scale = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    location = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    color = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment">#构造方法 需要的参数有像素的长宽，起始位置，颜色，均由元组表示。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, scale , location, color)</span>:</span></span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.location = location</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,target)</span>:</span></span><br><span class="line">        self.location = target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ncolor</span><span class="params">(self,color)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self,screen)</span>:</span></span><br><span class="line">        pygame.draw.rect(screen,self.color,(self.location,self.scale))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>class element：</strong><br>这个类通过使用<strong>class Pixel:</strong>的实例化对象来绘制获得游戏内容。通过改变成员变量 <strong>shift[ x, y]</strong> 的值来控制图像外接矩形左上角的坐标，改变 <strong>speed[ x, y]</strong> 来控制图像在x轴及y轴上的平移速度。而该类提供了 <strong>move(location)</strong> 和 <strong>setSpeed(speed)</strong> 两个成员方法来改变上述两个量。图片的绘制信息位于 <strong>build_BIRD，build_CLOUD ，build_SWITCH ，build_OBSTACLE， LETTER</strong>几个变量中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pixel <span class="keyword">import</span> Pixel</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    pixelScale = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#此处的长宽代表像素点的个数</span></span><br><span class="line">    scale = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    mes = []</span><br><span class="line">    shifting = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    speed = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="comment">#构造方法，传入欲绘制图像的像素点长宽（元组），整个图像外接矩形的长宽（元组），图片的绘制信息格式为((x,y),color)，以此类元组形成的列表传入构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,pixelScale,scale,mes)</span>:</span></span><br><span class="line">        self.pixelScale = pixelScale</span><br><span class="line">        self.scale = scale</span><br><span class="line">        self.mes = mes</span><br><span class="line"><span class="comment">#将图像绘制到指定的surface对象上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self,screen)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(self.mes)):</span><br><span class="line">            location = [(self.mes[_][<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span>) * self.pixelScale[<span class="number">0</span>] + self.shifting[<span class="number">0</span>], (self.mes[_][<span class="number">0</span>][<span class="number">1</span>]) * self.pixelScale[<span class="number">1</span>] + self.shifting[<span class="number">1</span>]]</span><br><span class="line">            color = self.mes[_][<span class="number">1</span>]</span><br><span class="line">            pixel = Pixel(self.pixelScale,location,color)</span><br><span class="line">            pixel.draw(screen)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self,location)</span>:</span></span><br><span class="line">        self.shifting = location</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setSpeed</span><span class="params">(self,speed)</span>:</span></span><br><span class="line">        self.speed = speed</span><br></pre></td></tr></table></figure>

<h2 id="对象的构造"><a href="#对象的构造" class="headerlink" title="对象的构造"></a>对象的构造</h2><ul>
<li><strong>开始按钮</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">switch = Element((<span class="number">10</span>, <span class="number">10</span>),(<span class="number">13</span>, <span class="number">18</span>), build_SWITCH)</span><br><span class="line">switch.move((width / <span class="number">2</span> - <span class="number">90</span>,height / <span class="number">2</span> - <span class="number">80</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>小鸟</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鸟</span></span><br><span class="line">bird = Element((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">11</span>, <span class="number">17</span>), build_BIRD)</span><br><span class="line">bird.move((size[<span class="number">0</span>] / <span class="number">2</span> - <span class="number">60</span>, size[<span class="number">1</span>] / <span class="number">4</span>))</span><br><span class="line">bird.draw(screen)</span><br><span class="line">bird.speed = [<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>云</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cloud_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_1.move((size[<span class="number">0</span>] / <span class="number">6</span>, size[<span class="number">1</span>] / <span class="number">5</span>))</span><br><span class="line">cloud_1.setSpeed((<span class="number">-0.7</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">cloud_2 = Element((<span class="number">7</span>, <span class="number">7</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_2.move((size[<span class="number">0</span>] / <span class="number">1.2</span>, size[<span class="number">1</span>] / <span class="number">3</span>))</span><br><span class="line">cloud_2.setSpeed((<span class="number">-1.5</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">cloud_3 = Element((<span class="number">10</span>, <span class="number">10</span>), (<span class="number">15</span>, <span class="number">19</span>), build_CLOUD)</span><br><span class="line">cloud_3.move((size[<span class="number">0</span>] / <span class="number">2</span>, size[<span class="number">1</span>] / <span class="number">1.5</span>))</span><br><span class="line">cloud_3.setSpeed((<span class="number">-2</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>障碍物</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obstacle_1_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_1_1.move((size[<span class="number">0</span>], -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_1_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_1_2.move((size[<span class="number">0</span>], <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_1_2.scale[<span class="number">0</span>]*obstacle_1_2.pixelScale[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">obstacle_2_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_2_1.move((size[<span class="number">0</span>] *<span class="number">1.4</span> , -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_2_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_2_2.move((size[<span class="number">0</span>] *<span class="number">1.4</span>, <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_2_2.scale[<span class="number">0</span>]*obstacle_2_2.pixelScale[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">obstacle_3_1 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_3_1.move((size[<span class="number">0</span>] *<span class="number">1.7</span> , -size[<span class="number">1</span>] / <span class="number">3.5</span>))</span><br><span class="line">obstacle_3_2 = Element((<span class="number">5</span>, <span class="number">5</span>), (<span class="number">75</span>, <span class="number">21</span>), build_OBSTACLE)</span><br><span class="line">obstacle_3_2.move((size[<span class="number">0</span>] *<span class="number">1.7</span>, <span class="number">1.3</span>*size[<span class="number">1</span>] - obstacle_3_2.scale[<span class="number">0</span>]*obstacle_3_2.pixelScale[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>分数</strong></li>
</ul>
<p><strong>score</strong> 用来存储当前分数，游戏结束的时候返回游戏分数这个参数至主界面并显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每过一个障碍物加一分，显示分数</span></span><br><span class="line">        score_ten = Element( (<span class="number">10</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="number">5</span>), LETTER[ int (score / <span class="number">10</span>) ] )</span><br><span class="line">        score_one = Element( (<span class="number">10</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="number">5</span>), LETTER[ score % <span class="number">10</span>] )</span><br><span class="line">        score_ten.move((<span class="number">10</span>,<span class="number">0</span>))</span><br><span class="line">        score_one.move((<span class="number">60</span>,<span class="number">0</span>))</span><br><span class="line">        score_ten.draw(screen)</span><br><span class="line">        score_one.draw(screen)</span><br></pre></td></tr></table></figure>

<h1 id="游戏元素的动画"><a href="#游戏元素的动画" class="headerlink" title="游戏元素的动画"></a>游戏元素的动画</h1><p>所有的游戏动画均为平移，因此使用 <strong>class Element:</strong> 里的 <strong>move(location)</strong> 和 <strong>setSpeed(speed)</strong> 足以完成所有的动画效果。小鸟处于确定x坐标的竖直区域运动，云和障碍物不断的左移即可。</p>
<h2 id="开始游戏"><a href="#开始游戏" class="headerlink" title="开始游戏"></a>开始游戏</h2><p>在遍历消息队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pygame.mouse.get_pressed()[<span class="number">0</span>]:</span><br><span class="line">	loc = pygame.mouse.get_pos()</span><br><span class="line">                 <span class="comment">#开始新游戏</span></span><br><span class="line">       <span class="keyword">if</span> (loc[<span class="number">0</span>] &gt; width / <span class="number">2</span> - <span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">0</span>] &lt; width / <span class="number">2</span> + <span class="number">90</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &gt; height / <span class="number">2</span> - <span class="number">80</span>) <span class="keyword">and</span> (loc[<span class="number">1</span>] &lt; height / <span class="number">2</span> + <span class="number">80</span>):</span><br><span class="line">       	score = start_fly(screen)</span><br></pre></td></tr></table></figure>

<h2 id="云的左移"><a href="#云的左移" class="headerlink" title="云的左移"></a>云的左移</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_animation</span><span class="params">(cloud)</span>:</span></span><br><span class="line"><span class="comment">#若云的整体位置已越过窗口左侧，设置云的外接矩形左上角位于窗口最右侧。</span></span><br><span class="line">    <span class="keyword">if</span> cloud.shifting[<span class="number">0</span>] &lt; - (cloud.scale[<span class="number">1</span>] * cloud.pixelScale[<span class="number">1</span>]):</span><br><span class="line">        cloud.move((size[<span class="number">0</span>], cloud.shifting[<span class="number">1</span>]))</span><br><span class="line">    cloud.move(( cloud.shifting[<span class="number">0</span>] + cloud.speed[<span class="number">0</span>], cloud.shifting[<span class="number">1</span>] ))</span><br><span class="line">    cloud.draw(screen)</span><br></pre></td></tr></table></figure>
<h2 id="小鸟的向下匀加速直线运动"><a href="#小鸟的向下匀加速直线运动" class="headerlink" title="小鸟的向下匀加速直线运动"></a>小鸟的向下匀加速直线运动</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bird.move((bird.shifting[<span class="number">0</span>], bird.shifting[<span class="number">1</span>] + bird.speed[<span class="number">1</span>]))</span><br><span class="line">bird.speed[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">bird.draw(screen)</span><br></pre></td></tr></table></figure>
<h2 id="监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果"><a href="#监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果" class="headerlink" title="监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果"></a>监听鼠标右键点击事件对小鸟提供极大的瞬时向上的加速度，达到缓冲小鸟下落的效果</h2><p>在遍历消息队列中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">        mouse = pygame.mouse.get_pressed()</span><br><span class="line">        <span class="keyword">if</span> mouse[<span class="number">2</span>]:</span><br><span class="line">bird.speed[<span class="number">1</span>] -= <span class="number">25</span></span><br></pre></td></tr></table></figure>
<h2 id="障碍物的移动以及判断小鸟是否与障碍物相撞"><a href="#障碍物的移动以及判断小鸟是否与障碍物相撞" class="headerlink" title="障碍物的移动以及判断小鸟是否与障碍物相撞"></a>障碍物的移动以及判断小鸟是否与障碍物相撞</h2><p>（由于一开始游戏难度过大， 我将障碍物设置为空心，即小鸟不会和障碍物的正下方或正上方相撞，但会和障碍物的侧边相撞）<br>通过传入一定范围内的随机参数ran控制障碍物从最右端开始向左平移的初始位置。在每个障碍物对象经过小鸟的位置令分数+1，便可完成分数的记录。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obstacle_animation</span><span class="params">(obstacle,ran,bird_height)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; - (obstacle.scale[<span class="number">1</span>] * obstacle.pixelScale[<span class="number">1</span>]):</span><br><span class="line">        obstacle.move((size[<span class="number">0</span>], obstacle.shifting[<span class="number">1</span>] + ran * (obstacle.scale[<span class="number">1</span>] * obstacle.pixelScale[<span class="number">1</span>]) ))</span><br><span class="line">    obstacle.move(( obstacle.shifting[<span class="number">0</span>] - <span class="number">1</span>, obstacle.shifting[<span class="number">1</span>] ))</span><br><span class="line">    obstacle.draw(screen)</span><br><span class="line">    <span class="keyword">if</span> (obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>) <span class="keyword">and</span> (obstacle.shifting[<span class="number">0</span>] &gt; size[<span class="number">0</span>] / <span class="number">2</span> - <span class="number">60</span>):   <span class="comment">#可能发生碰撞的矩形区域</span></span><br><span class="line">        <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] &lt; <span class="number">0</span>:  <span class="comment">#和上管道相撞的区域</span></span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] + <span class="number">375</span> &gt;= bird_height: <span class="comment">#和上管道右侧相撞的区域</span></span><br><span class="line">                <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] + <span class="number">375</span> &gt;=bird_height:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> obstacle.shifting[<span class="number">1</span>] &lt; bird_height:</span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> obstacle.shifting[<span class="number">0</span>] &lt; size[<span class="number">0</span>] / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> obstacle.shifting[<span class="number">1</span>] &lt; bird_height:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="小游戏的打包"><a href="#小游戏的打包" class="headerlink" title="小游戏的打包"></a>小游戏的打包</h1><p>(已安装<strong>pyinstaller</strong>)<br>在命令行窗口，进入到游戏入口文件的路径下输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyinstaller -w -F 文件名.py 文件名.py...</span><br></pre></td></tr></table></figure>
<p>打包完成之后可执行文件处于<strong>dist</strong>目录下。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>pygame确实十分的方便，功能其实远不止这个小游戏所用到的这些，而我的这种自己建类绘制图形其实没有什么必要，直接导入图片资源，pygame就能够构造以这个图片资源为基础的surface对象，并提供了许多方法来操作，远比上述自己创造的类方法要灵活，最主要的是，在设计2D游戏的过程中，完全不需要花大量时间在游戏框架的构造上，一个小游戏一天便可开发完成。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题笔记-1-两数之和</title>
    <url>/2020/02/16/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例：</p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</p>
</blockquote>
<a id="more"></a>

<p>我本来想通过暴力解法来解这种题，因为逻辑并不复杂。但是后面又想到了一种通过使用HashMap的方法，能够将时间复杂度降为o(n)。</p>
<p>我们要想知道数组中和等于target的两个下标，也就是想要知道对于一个数组中的数，如果target减这个数也存在数组中，那么这两个数的下标就是我们要的答案。在对数组的一次遍历中，将遍历到的数的值作为键，下标作为值，以这样一个二元组加入到一个HashMap集合中。因为通过键访问值只需要常数级的时间复杂度。所以在每一次对数组元素的访问中，查看HashMap集合中是否存在一个以target-nums[i]为键的元组，若存在，则返回它的值，它的值就是我们在此前一起传入的下标。我们要的答案就是现在的i,和通过HashMap集合找到对应的值，即原本的下标。</p>
<p>这道题表明使用哈希表来存储需要通过值来访问得到序号的二元组是十分有效的，因为哈希表的键可以存储任意类型的元素，用值来存储整型的下标。需要注意的是，哈希表中一个键只能对应一个值，一个值却可以对应多个键，类似于函数中的单射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(target - nums[i]), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>三角函数关系</title>
    <url>/2019/12/19/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>要考研了，复习高数不定积分那一块的时候竟然发现有一些三角函数居然都没见过，特此记录一下他们与sin，cos，tan之间的关系，主要是正割余割。至于和差化积那些转换关系，既然考研不要求就不记了。</p>
<a id="more"></a>
<h2 id="倒数关系"><a href="#倒数关系" class="headerlink" title="倒数关系"></a>倒数关系</h2><blockquote>
<p>sin a * csc a=1<br>cos a * sec a=1<br>tana * cota=1</p>
</blockquote>
<h2 id="商数关系"><a href="#商数关系" class="headerlink" title="商数关系"></a>商数关系</h2><blockquote>
<p>tana=sin a / cos a<br>cota=cos a / sin a</p>
</blockquote>
<h2 id="平方关系"><a href="#平方关系" class="headerlink" title="平方关系"></a>平方关系</h2><blockquote>
<p>(sin a)^2 + (cos a)^2=1<br>1+(tan a)^2 = (sec a)^2<br>1+(cot a)^2 = (csc a)^2</p>
</blockquote>
]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
</search>
